ğŸš€ Claude Code ë¦¬íŒ©í† ë§ ëª…ë ¹ì–´ ì„¸íŠ¸
1. ğŸ” ì½”ë“œ ë¶„ì„ ëª…ë ¹ì–´
bash# ìŠˆí¼í´ë¡œë“œ ì½”ë“œ í’ˆì§ˆ ë¶„ì„
--analyze code-quality --depth deep
--metrics complexity,duplication,coverage
--report detailed-with-suggestions

# ì·¨ì•½ì  ìŠ¤ìº”
--scan security-vulnerabilities
--include owasp-top-10,sql-injection,xss
--fix-suggestion enabled

# ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§
--profile performance
--identify bottlenecks,memory-leaks,n+1-queries
--suggest optimizations
2. ğŸ› ï¸ ìë™ ë¦¬íŒ©í† ë§ ëª…ë ¹ì–´
bash# ì½”ë“œ ì¤‘ë³µ ì œê±°
--refactor remove-duplication
--threshold 85% --extract-method auto
--preserve-functionality strict

# ë³µì¡ë„ ê°ì†Œ
--refactor reduce-complexity
--max-cognitive-complexity 10
--split-functions auto --maintain-interface

# ë””ìì¸ íŒ¨í„´ ì ìš©
--refactor apply-pattern
--patterns singleton,factory,repository
--context-aware true

ğŸ“ ë‹¨ê³„ë³„ ë¦¬íŒ©í† ë§ ì‘ì—… ì§€ì‹œì„œ
Phase 1: ì¦‰ì‹œ ìˆ˜ì • (Critical Issues)
python"""
ìŠˆí¼í´ë¡œë“œ ê¸´ê¸‰ ìˆ˜ì • ì§€ì‹œ:
--priority critical --auto-fix enabled
--backup-before-change true

1. SQL ì¸ì ì…˜ ì·¨ì•½ì  ìˆ˜ì •
   - ëª¨ë“  raw queryë¥¼ parameterized queryë¡œ ë³€ê²½
   - SQLAlchemy ORM ì‚¬ìš© ê°•ì œ

2. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ í•´ê²°
   - ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ì‹œ ìŠ¤íŠ¸ë¦¬ë° ì ìš©
   - ë¶ˆí•„ìš”í•œ ê°ì²´ ì°¸ì¡° ì œê±°
   - Context manager íŒ¨í„´ ì ìš©

3. ë™ì‹œì„± ë¬¸ì œ í•´ê²°
   - Race condition ìˆëŠ” ì½”ë“œ ì‹ë³„
   - ì ì ˆí•œ Lock ë©”ì»¤ë‹ˆì¦˜ ì ìš©
   - AsyncIO íŒ¨í„´ ì¼ê´€ì„± í™•ë³´

ì˜ˆì‹œ ë³€í™˜:
# Before (ìœ„í—˜)
query = f"SELECT * FROM users WHERE id = {user_id}"

# After (ì•ˆì „)
query = select(User).where(User.id == user_id)
"""
Phase 2: êµ¬ì¡° ê°œì„  (Architecture)
python"""
ìŠˆí¼í´ë¡œë“œ ì•„í‚¤í…ì²˜ ê°œì„  ì§€ì‹œ:
--refactor architecture --pattern clean-architecture
--maintain backward-compatibility true

1. ë ˆì´ì–´ ë¶„ë¦¬ ê°•í™”
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Presentationâ”‚ (API Routes)
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Application â”‚ (Use Cases)
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚   Domain    â”‚ (Business Logic)
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚Infrastructureâ”‚ (DB, External APIs)
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. ì˜ì¡´ì„± ì£¼ì… íŒ¨í„´ ì ìš©
   - ëª¨ë“  ì„œë¹„ìŠ¤ë¥¼ Interfaceë¡œ ì¶”ìƒí™”
   - FastAPI Depends() í™œìš©
   - í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ êµ¬ì¡°ë¡œ ë³€ê²½

3. Repository íŒ¨í„´ ë„ì…
   # Before
   def get_user(db: Session, user_id: int):
       return db.query(User).filter(User.id == user_id).first()
   
   # After
   class UserRepository:
       def __init__(self, db: Session):
           self.db = db
       
       async def get_by_id(self, user_id: int) -> Optional[User]:
           return await self.db.get(User, user_id)
"""
Phase 3: ì½”ë“œ í’ˆì§ˆ ê°œì„  (Quality)
python"""
ìŠˆí¼í´ë¡œë“œ í’ˆì§ˆ ê°œì„  ì§€ì‹œ:
--improve code-quality --style pep8
--type-hints complete --docstrings google-style

1. í•¨ìˆ˜ ë‹¨ìˆœí™” (Single Responsibility)
   # Before (ë³µì¡)
   def process_employee_data(data):
       # 100ì¤„ì˜ ë³µì¡í•œ ë¡œì§...
       
   # After (ë‹¨ìˆœ)
   def process_employee_data(data: EmployeeData) -> ProcessedData:
       validated_data = self._validate(data)
       enriched_data = self._enrich(validated_data)
       return self._transform(enriched_data)

2. ì—ëŸ¬ í•¸ë“¤ë§ í‘œì¤€í™”
   class AnalysisError(AppException):
       error_code = "ANALYSIS_001"
       status_code = 400
       
   # ì¼ê´€ëœ ì—ëŸ¬ ì‘ë‹µ
   @app.exception_handler(AppException)
   async def app_exception_handler(request, exc):
       return JSONResponse(
           status_code=exc.status_code,
           content={"error": exc.error_code, "detail": exc.detail}
       )

3. íƒ€ì… ì•ˆì •ì„± ê°•í™”
   # ëª¨ë“  í•¨ìˆ˜ì— íƒ€ì… íŒíŠ¸ ì¶”ê°€
   from typing import List, Optional, Dict, Any
   
   async def analyze_hr_data(
       file_path: Path,
       options: AnalysisOptions,
       user_context: UserContext
   ) -> AnalysisResult:
       ...
"""
Phase 4: ì„±ëŠ¥ ìµœì í™” (Performance)
python"""
ìŠˆí¼í´ë¡œë“œ ì„±ëŠ¥ ìµœì í™” ì§€ì‹œ:
--optimize performance --target response-time,throughput
--benchmark before-after --profile enabled

1. ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”
   # N+1 ë¬¸ì œ í•´ê²°
   # Before
   employees = db.query(Employee).all()
   for emp in employees:
       dept = emp.department  # Nê°œì˜ ì¶”ê°€ ì¿¼ë¦¬
   
   # After
   employees = db.query(Employee).options(
       joinedload(Employee.department)
   ).all()

2. ìºì‹± ì „ëµ êµ¬í˜„
   from functools import lru_cache
   from redis import Redis
   
   @lru_cache(maxsize=128)
   def get_hr_policy(policy_id: str) -> HRPolicy:
       return fetch_from_db(policy_id)
   
   # Redis ìºì‹± for ë¶„ì‚° í™˜ê²½
   async def get_analysis_result(analysis_id: str) -> AnalysisResult:
       cached = await redis.get(f"analysis:{analysis_id}")
       if cached:
           return AnalysisResult.parse_raw(cached)
       ...

3. ë¹„ë™ê¸° ì²˜ë¦¬ ìµœì í™”
   # ë³‘ë ¬ ì²˜ë¦¬ ì ìš©
   async def batch_analyze(files: List[Path]) -> List[Result]:
       tasks = [analyze_file(f) for f in files]
       return await asyncio.gather(*tasks)
"""

ğŸ”„ MCP í†µí•© ë¦¬íŒ©í† ë§
MCP ëª¨ë“ˆë³„ í‘œì¤€í™”
python"""
ìŠˆí¼í´ë¡œë“œ MCP í†µí•© ì§€ì‹œ:
--integrate mcp-modules --standard unified-interface
--maintain loose-coupling

1. FileServer í†µí•© í‘œì¤€
   class FileServerAdapter:
       async def save_analysis_result(
           self, 
           result: AnalysisResult,
           metadata: Dict[str, Any]
       ) -> FilePath:
           # MCP fileserver í˜¸ì¶œ
           return await self.mcp_client.save(
               content=result.to_json(),
               path=f"analysis/{result.id}",
               metadata=metadata
           )

2. Sequential Thinking í†µí•©
   class AnalysisOrchestrator:
       def __init__(self, sequential_client: SequentialClient):
           self.seq = sequential_client
           
       async def run_analysis(self, data: InputData) -> Result:
           # ë‹¨ê³„ë³„ ì²˜ë¦¬ ì •ì˜
           pipeline = self.seq.create_pipeline([
               ("validate", self.validate_data),
               ("preprocess", self.preprocess_data),
               ("analyze", self.run_ai_analysis),
               ("postprocess", self.format_results)
           ])
           return await pipeline.execute(data)

3. Task Manager í†µí•©
   class TaskQueueAdapter:
       async def enqueue_analysis(
           self, 
           task: AnalysisTask
       ) -> TaskId:
           return await self.task_manager.create_task(
               name=f"analysis_{task.id}",
               handler="analyze_hr_data",
               params=task.to_dict(),
               priority=task.priority
           )
"""

ğŸ“Š ë¦¬íŒ©í† ë§ ì¸¡ì • ì§€í‘œ
ìë™ ì¸¡ì • ëª…ë ¹ì–´
bash# ë¦¬íŒ©í† ë§ ì „í›„ ë¹„êµ
--measure refactoring-impact
--metrics all --format comparison-table

# ì‹¤ì‹œê°„ í’ˆì§ˆ ëª¨ë‹ˆí„°ë§
--monitor code-quality --real-time
--alert-threshold complexity:15,duplication:10%
ì£¼ìš” ì§€í‘œ
ì§€í‘œëª©í‘œì¸¡ì • ë°©ë²•ì½”ë“œ ë³µì¡ë„< 10Cyclomatic Complexityì¤‘ë³µ ì½”ë“œ< 5%Duplication Indexí…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€> 85%Coverage Reportì‘ë‹µ ì‹œê°„< 200msPerformance Profileë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰< 512MBMemory Profileíƒ€ì… ì»¤ë²„ë¦¬ì§€100%Type Check

ğŸ¬ ì‹¤ì „ ë¦¬íŒ©í† ë§ ì‹œë‚˜ë¦¬ì˜¤
ì‹œë‚˜ë¦¬ì˜¤ 1: ë ˆê±°ì‹œ ë¶„ì„ ëª¨ë“ˆ ê°œì„ 
bash# Claude Code ì‹¤í–‰ ëª…ë ¹
claude-code refactor legacy-analyzer \
  --identify-issues auto \
  --apply-fixes incremental \
  --test-each-change true \
  --rollback-on-failure true
ì‹œë‚˜ë¦¬ì˜¤ 2: API ì‘ë‹µ ì†ë„ ê°œì„ 
bash# ì„±ëŠ¥ ë³‘ëª© ì§€ì  ì°¾ê¸°
claude-code profile api-performance \
  --endpoints all \
  --load-test concurrent:100 \
  --identify slow-queries,blocking-io \
  --suggest-fixes caching,async,pagination
ì‹œë‚˜ë¦¬ì˜¤ 3: ë³´ì•ˆ ì·¨ì•½ì  ê¸´ê¸‰ íŒ¨ì¹˜
bash# ë³´ì•ˆ ìŠ¤ìº” ë° ìë™ ìˆ˜ì •
claude-code security-patch \
  --scan-depth deep \
  --fix-priority critical,high \
  --test security-regression \
  --deploy-safe-mode true

ğŸ“ ë¦¬íŒ©í† ë§ ì²´í¬ë¦¬ìŠ¤íŠ¸ í…œí”Œë¦¿
markdown## ë¦¬íŒ©í† ë§ ì‘ì—… í‹°ì¼“

### ëŒ€ìƒ ì½”ë“œ
- íŒŒì¼: `services/analyzer.py`
- í•¨ìˆ˜: `process_employee_data()`
- í˜„ì¬ ë³µì¡ë„: 25
- ëª©í‘œ ë³µì¡ë„: < 10

### ë¬¸ì œì 
- [ ] í•¨ìˆ˜ê°€ ë„ˆë¬´ ê¸¸ë‹¤ (150ì¤„)
- [ ] ì—¬ëŸ¬ ì±…ì„ì„ ê°€ì§€ê³  ìˆë‹¤
- [ ] í…ŒìŠ¤íŠ¸í•˜ê¸° ì–´ë µë‹¤
- [ ] ì—ëŸ¬ í•¸ë“¤ë§ì´ ì¼ê´€ì„± ì—†ë‹¤

### ê°œì„  ê³„íš
1. [ ] ë‹¨ì¼ ì±…ì„ ì›ì¹™ ì ìš©
2. [ ] ì„œë¸Œ í•¨ìˆ˜ë¡œ ë¶„ë¦¬
3. [ ] ì˜ì¡´ì„± ì£¼ì… ì ìš©
4. [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì¶”ê°€

### ê²€ì¦ ê¸°ì¤€
- [ ] ëª¨ë“  ê¸°ì¡´ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ìƒˆë¡œìš´ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì¶”ê°€
- [ ] ì„±ëŠ¥ ì €í•˜ ì—†ìŒ
- [ ] ì½”ë“œ ë¦¬ë·° ìŠ¹ì¸

ğŸš¨ ìœ„í—˜ ì‹ í˜¸ ìë™ ê°ì§€
python"""
ìŠˆí¼í´ë¡œë“œ ìœ„í—˜ íŒ¨í„´ ê°ì§€:
--detect code-smells,anti-patterns
--auto-suggest refactoring-candidates

ê°ì§€ ëŒ€ìƒ:
1. God Class (í•˜ë‚˜ì˜ í´ë˜ìŠ¤ê°€ ë„ˆë¬´ ë§ì€ ì¼ì„ í•¨)
2. Long Method (50ì¤„ ì´ìƒì˜ í•¨ìˆ˜)
3. Duplicate Code (85% ì´ìƒ ìœ ì‚¬)
4. Dead Code (ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì½”ë“œ)
5. Circular Dependencies (ìˆœí™˜ ì°¸ì¡°)
6. Magic Numbers (í•˜ë“œì½”ë”©ëœ ê°’)
7. Inconsistent Naming (ëª…ëª… ê·œì¹™ ë¶ˆì¼ì¹˜)
"""