{% extends "base_revolutionary.html" %}
{% load static %}

{% block title %}차세대 조직도 | AI HRM{% endblock %}

{% block extra_css %}
<style>
    /* 기본 레이아웃 */
    .org-chart-container {
        background: linear-gradient(135deg, #0a0f1b 0%, #1a1f2e 100%);
        min-height: calc(100vh - 70px);
        position: relative;
        display: flex;
        flex-direction: column;
    }

    /* 툴바 스타일 */
    .org-toolbar {
        background: rgba(26, 31, 46, 0.95);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        padding: 1rem;
        position: sticky;
        top: 0;
        z-index: 1000;
    }

    .toolbar-inner {
        display: flex;
        align-items: center;
        gap: 1.5rem;
        max-width: 1600px;
        margin: 0 auto;
    }

    /* 뷰 모드 선택 */
    .view-modes {
        display: flex;
        gap: 0.5rem;
        background: rgba(10, 15, 27, 0.6);
        padding: 0.25rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(0, 212, 255, 0.2);
    }

    .view-mode-btn {
        padding: 0.5rem 1rem;
        background: transparent;
        color: #94a3b8;
        border: none;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .view-mode-btn.active {
        background: linear-gradient(135deg, #00d4ff, #0099cc);
        color: white;
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
    }

    .view-mode-btn:hover:not(.active) {
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
    }

    /* 레벨 필터 */
    .level-filters {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    .level-filter-btn {
        padding: 0.375rem 0.75rem;
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.813rem;
    }

    .level-filter-btn.active {
        background: rgba(0, 212, 255, 0.2);
        border-color: #00d4ff;
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.2);
    }

    /* 검색 박스 */
    .org-search-box {
        position: relative;
        flex: 1;
        max-width: 400px;
    }

    .org-search-input {
        width: 100%;
        padding: 0.625rem 1rem 0.625rem 2.5rem;
        background: rgba(10, 15, 27, 0.6);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        color: white;
        font-size: 0.875rem;
        transition: all 0.3s ease;
    }

    .org-search-input:focus {
        border-color: #00d4ff;
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        outline: none;
    }

    .org-search-icon {
        position: absolute;
        left: 0.875rem;
        top: 50%;
        transform: translateY(-50%);
        color: #94a3b8;
    }

    /* 자동완성 드롭다운 */
    .search-autocomplete {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        margin-top: 0.5rem;
        background: rgba(26, 31, 46, 0.98);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        z-index: 1001;
    }

    .search-autocomplete.active {
        display: block;
    }

    .autocomplete-item {
        padding: 0.75rem 1rem;
        color: #cbd5e1;
        cursor: pointer;
        transition: all 0.2s ease;
        border-bottom: 1px solid rgba(0, 212, 255, 0.1);
    }

    .autocomplete-item:hover {
        background: rgba(0, 212, 255, 0.1);
        color: white;
    }

    .autocomplete-item-name {
        font-weight: 500;
        color: white;
    }

    .autocomplete-item-path {
        font-size: 0.75rem;
        color: #64748b;
        margin-top: 0.25rem;
    }

    /* 줌 컨트롤 */
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background: rgba(10, 15, 27, 0.6);
        padding: 0.25rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(0, 212, 255, 0.2);
    }

    .zoom-btn {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        color: #94a3b8;
        border: none;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .zoom-btn:hover {
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
    }

    .zoom-level {
        color: #00d4ff;
        font-size: 0.813rem;
        min-width: 50px;
        text-align: center;
    }

    /* 메인 차트 영역 */
    .chart-viewport {
        flex: 1;
        position: relative;
        overflow-y: auto;
        overflow-x: hidden; /* 가로 스크롤 방지 */
        padding: 2rem;
    }

    /* 트리 컨테이너 */
    .tree-container {
        min-height: 100%;
        position: relative;
        transition: transform 0.3s ease;
        transform-origin: top center;
    }

    /* 노드 스타일 */
    .org-node {
        position: absolute;
        background: rgba(26, 31, 46, 0.9);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 0.75rem;
        padding: 1rem;
        min-width: 200px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .org-node:hover {
        border-color: #00d4ff;
        box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
        transform: translateY(-2px);
    }

    .org-node.focused {
        border-color: #00d4ff;
        box-shadow: 0 0 40px rgba(0, 212, 255, 0.5);
        background: rgba(0, 212, 255, 0.05);
    }

    .org-node.collapsed .node-children-info {
        display: block;
    }

    /* 노드 헤더 */
    .node-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0.5rem;
    }

    .node-type-badge {
        display: inline-block;
        padding: 0.125rem 0.5rem;
        background: rgba(0, 212, 255, 0.2);
        color: #00d4ff;
        border-radius: 0.25rem;
        font-size: 0.688rem;
        font-weight: 500;
        text-transform: uppercase;
    }

    .node-type-badge.company {
        background: rgba(168, 85, 247, 0.2);
        color: #a855f7;
    }

    .node-type-badge.division {
        background: rgba(236, 72, 153, 0.2);
        color: #ec4899;
    }

    .node-type-badge.department {
        background: rgba(34, 197, 94, 0.2);
        color: #22c55e;
    }

    .node-type-badge.team {
        background: rgba(251, 146, 60, 0.2);
        color: #fb923c;
    }

    /* 노드 콘텐츠 */
    .node-content {
        color: white;
    }

    .node-name {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.25rem;
    }

    .node-title {
        font-size: 0.813rem;
        color: #94a3b8;
        margin-bottom: 0.5rem;
    }

    .node-stats {
        display: flex;
        gap: 1rem;
        font-size: 0.75rem;
        color: #64748b;
    }

    .node-stat {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    .node-stat-icon {
        color: #00d4ff;
    }

    /* 접기/펼치기 버튼 */
    .node-toggle {
        position: absolute;
        bottom: -12px;
        left: 50%;
        transform: translateX(-50%);
        width: 24px;
        height: 24px;
        background: rgba(26, 31, 46, 0.95);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: #00d4ff;
        transition: all 0.2s ease;
    }

    .node-toggle:hover {
        background: rgba(0, 212, 255, 0.2);
        border-color: #00d4ff;
    }

    /* 하위 노드 정보 (접힌 상태) */
    .node-children-info {
        display: none;
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid rgba(0, 212, 255, 0.1);
        font-size: 0.813rem;
        color: #00d4ff;
    }

    /* 오버플로우 클러스터 */
    .overflow-cluster {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        padding: 0.75rem;
        margin-top: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
    }

    .overflow-cluster:hover {
        background: rgba(0, 212, 255, 0.1);
        border-color: #00d4ff;
    }

    .overflow-cluster-text {
        color: #00d4ff;
        font-size: 0.875rem;
    }

    /* 연결선 */
    .org-edge {
        position: absolute;
        background: linear-gradient(to bottom, rgba(0, 212, 255, 0.3), transparent);
        width: 2px;
        transition: all 0.3s ease;
        pointer-events: none;
    }

    .org-edge.horizontal {
        height: 2px;
        width: auto;
        background: linear-gradient(to right, transparent, rgba(0, 212, 255, 0.3), transparent);
    }

    /* 미니맵 */
    .minimap {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 200px;
        height: 120px;
        background: rgba(26, 31, 46, 0.95);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 0.5rem;
        padding: 0.5rem;
        z-index: 900;
    }

    .minimap-viewport {
        position: absolute;
        background: rgba(0, 212, 255, 0.2);
        border: 1px solid #00d4ff;
        pointer-events: none;
    }

    /* 브레드크럼 */
    .breadcrumb-nav {
        background: rgba(10, 15, 27, 0.6);
        padding: 0.75rem 1rem;
        border-bottom: 1px solid rgba(0, 212, 255, 0.1);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        overflow-x: auto;
    }

    .breadcrumb-item {
        color: #64748b;
        font-size: 0.875rem;
        white-space: nowrap;
        cursor: pointer;
        transition: color 0.2s ease;
    }

    .breadcrumb-item:hover {
        color: #00d4ff;
    }

    .breadcrumb-separator {
        color: #475569;
    }

    .breadcrumb-item.active {
        color: white;
        font-weight: 500;
    }

    /* 로딩 상태 */
    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(10, 15, 27, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(0, 212, 255, 0.2);
        border-top-color: #00d4ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    /* 반응형 디자인 */
    @media (max-width: 768px) {
        .toolbar-inner {
            flex-direction: column;
            gap: 1rem;
        }

        .org-search-box {
            max-width: 100%;
        }

        .minimap {
            width: 150px;
            height: 90px;
        }
    }

    /* 시맨틱 줌 레벨 */
    .tree-container.zoom-small .node-title,
    .tree-container.zoom-small .node-stats {
        display: none;
    }

    .tree-container.zoom-small .org-node {
        padding: 0.5rem;
        min-width: 150px;
    }

    .tree-container.zoom-large .org-node {
        padding: 1.25rem;
        min-width: 250px;
    }

    /* 키보드 내비게이션 포커스 */
    .org-node:focus {
        outline: 2px solid #00d4ff;
        outline-offset: 2px;
    }

    /* 접근성 */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }
</style>
{% endblock %}

{% block content %}
<div class="org-chart-container">
    <!-- 툴바 -->
    <div class="org-toolbar">
        <div class="toolbar-inner">
            <!-- 뷰 모드 선택 -->
            <div class="view-modes">
                <button class="view-mode-btn active" data-mode="vertical">
                    <i class="fas fa-sitemap"></i>
                    <span>세로형</span>
                </button>
                <button class="view-mode-btn" data-mode="grid">
                    <i class="fas fa-th"></i>
                    <span>그리드</span>
                </button>
                <button class="view-mode-btn" data-mode="radial">
                    <i class="fas fa-circle-notch"></i>
                    <span>방사형</span>
                </button>
                <button class="view-mode-btn" data-mode="compact">
                    <i class="fas fa-list"></i>
                    <span>컴팩트</span>
                </button>
            </div>

            <!-- 레벨 필터 -->
            <div class="level-filters">
                <span style="color: #94a3b8; font-size: 0.875rem;">레벨:</span>
                <button class="level-filter-btn active" data-level="all">전체</button>
                <button class="level-filter-btn" data-level="executive">임원</button>
                <button class="level-filter-btn" data-level="division">본부</button>
                <button class="level-filter-btn" data-level="department">부서</button>
                <button class="level-filter-btn" data-level="team">팀</button>
            </div>

            <!-- 검색 -->
            <div class="org-search-box">
                <i class="fas fa-search org-search-icon"></i>
                <input type="text" class="org-search-input" placeholder="이름, 부서, 직급으로 검색..." id="orgSearch">
                <div class="search-autocomplete" id="searchAutocomplete"></div>
            </div>

            <!-- 줌 컨트롤 -->
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">
                    <i class="fas fa-minus"></i>
                </button>
                <span class="zoom-level" id="zoomLevel">100%</span>
                <button class="zoom-btn" id="zoomIn">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="zoom-btn" id="zoomReset">
                    <i class="fas fa-expand"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- 브레드크럼 네비게이션 -->
    <div class="breadcrumb-nav" id="breadcrumbNav">
        <span class="breadcrumb-item active">전체 조직</span>
    </div>

    <!-- 메인 차트 영역 -->
    <div class="chart-viewport" id="chartViewport">
        <div class="tree-container" id="treeContainer">
            <!-- 동적으로 생성될 조직도 노드들 -->
        </div>

        <!-- 로딩 오버레이 -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- 미니맵 -->
    <div class="minimap" id="minimap">
        <div class="minimap-viewport"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// 전역 상태 관리
const OrgChartState = {
    currentView: 'vertical',
    currentLevel: 'all',
    zoomLevel: 100,
    focusedNode: null,
    expandedNodes: new Set(['OK금융그룹']), // 루트 노드만 초기 펼침
    searchQuery: '',
    nodes: new Map(),
    edges: [],
    clusteredSiblings: new Map(), // 오버플로우 클러스터링 상태
};

// 상수 정의
const CONFIG = {
    MAX_VISIBLE_SIBLINGS: 12, // 최대 표시 형제 노드 수
    NODE_WIDTH: 200,
    NODE_HEIGHT: 120,
    LEVEL_SPACING: 150,
    SIBLING_SPACING: 20,
    ZOOM_MIN: 50,
    ZOOM_MAX: 200,
    ZOOM_STEP: 10,
    SEARCH_DELAY: 300,
    ANIMATION_DURATION: 300,
};

// 초기화
document.addEventListener('DOMContentLoaded', function() {
    console.log('Advanced Org Chart: DOM loaded, initializing...');
    
    try {
        initializeChart();
        setupEventListeners();
        setupKeyboardNavigation();
        
        // API 데이터 로드를 시도하고, 실패하면 샘플 데이터 사용
        loadInitialData().catch((error) => {
            console.log('API failed, using sample data...', error);
            useSampleData();
        });
    } catch (error) {
        console.error('Initialization error:', error);
        // 초기화 실패 시 샘플 데이터로 백업
        useSampleData();
    }
});

// 차트 초기화
function initializeChart() {
    // 초기 뷰 설정
    updateViewMode('vertical');
    updateZoom(100);
}

// 이벤트 리스너 설정
function setupEventListeners() {
    console.log('Setting up event listeners...');
    
    // 뷰 모드 변경
    const viewModeBtns = document.querySelectorAll('.view-mode-btn');
    console.log(`Found ${viewModeBtns.length} view mode buttons`);
    viewModeBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            console.log('View mode clicked:', this.dataset.mode);
            const mode = this.dataset.mode;
            updateViewMode(mode);
        });
    });

    // 레벨 필터
    const levelFilterBtns = document.querySelectorAll('.level-filter-btn');
    console.log(`Found ${levelFilterBtns.length} level filter buttons`);
    levelFilterBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            console.log('Level filter clicked:', this.dataset.level);
            const level = this.dataset.level;
            updateLevelFilter(level);
        });
    });

    // 검색
    const searchInput = document.getElementById('orgSearch');
    let searchTimeout;
    searchInput.addEventListener('input', function(e) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            performSearch(e.target.value);
        }, CONFIG.SEARCH_DELAY);
    });

    // 줌 컨트롤
    document.getElementById('zoomIn').addEventListener('click', () => {
        updateZoom(Math.min(OrgChartState.zoomLevel + CONFIG.ZOOM_STEP, CONFIG.ZOOM_MAX));
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
        updateZoom(Math.max(OrgChartState.zoomLevel - CONFIG.ZOOM_STEP, CONFIG.ZOOM_MIN));
    });

    document.getElementById('zoomReset').addEventListener('click', () => {
        updateZoom(100);
    });

    // 마우스 휠 줌
    document.getElementById('chartViewport').addEventListener('wheel', function(e) {
        if (e.ctrlKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -CONFIG.ZOOM_STEP : CONFIG.ZOOM_STEP;
            updateZoom(Math.max(CONFIG.ZOOM_MIN, Math.min(CONFIG.ZOOM_MAX, OrgChartState.zoomLevel + delta)));
        }
    });
}

// 키보드 내비게이션 설정
function setupKeyboardNavigation() {
    document.addEventListener('keydown', function(e) {
        if (OrgChartState.focusedNode) {
            const node = OrgChartState.nodes.get(OrgChartState.focusedNode);
            if (!node) return;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    navigateToSibling(node, -1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    navigateToSibling(node, 1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (node.hasChildren && !OrgChartState.expandedNodes.has(node.id)) {
                        toggleNode(node.id);
                    } else if (node.children && node.children.length > 0) {
                        focusNode(node.children[0]);
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (OrgChartState.expandedNodes.has(node.id)) {
                        toggleNode(node.id);
                    } else if (node.parentId) {
                        focusNode(node.parentId);
                    }
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (node.hasChildren) {
                        toggleNode(node.id);
                    }
                    break;
                case '/':
                    e.preventDefault();
                    document.getElementById('orgSearch').focus();
                    break;
            }
        }
    });
}

// 초기 데이터 로드
async function loadInitialData() {
    showLoading(true);
    
    try {
        // API에서 초기 2레벨 데이터 로드
        const response = await fetch('/employees/api/org/root?depth=5');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        console.log('Loaded org data:', data); // 디버깅용
        
        // 노드 생성 및 렌더링
        processOrgData(data);
        renderChart();
        
    } catch (error) {
        console.error('Failed to load organization data:', error);
        showError('조직 데이터를 불러오는데 실패했습니다.');
    } finally {
        showLoading(false);
    }
}

// 조직 데이터 처리
function processOrgData(data) {
    // 재귀적으로 노드 처리
    function processNode(node, parentId = null, level = 0) {
        const processedNode = {
            ...node,
            parentId,
            level,
            x: 0,
            y: level * CONFIG.LEVEL_SPACING,
        };
        
        OrgChartState.nodes.set(node.id, processedNode);
        
        if (node.children && node.children.length > 0) {
            // 오버플로우 클러스터링 적용
            if (node.children.length > CONFIG.MAX_VISIBLE_SIBLINGS) {
                const visibleChildren = node.children.slice(0, CONFIG.MAX_VISIBLE_SIBLINGS);
                const hiddenCount = node.children.length - CONFIG.MAX_VISIBLE_SIBLINGS;
                
                // 클러스터 노드 추가
                const clusterId = `${node.id}-cluster`;
                OrgChartState.clusteredSiblings.set(clusterId, node.children.slice(CONFIG.MAX_VISIBLE_SIBLINGS));
                
                visibleChildren.forEach(child => processNode(child, node.id, level + 1));
                
                // 클러스터 표시 노드 추가
                const clusterNode = {
                    id: clusterId,
                    name: `+${hiddenCount}개 더보기`,
                    type: 'cluster',
                    parentId: node.id,
                    level: level + 1,
                    isCluster: true,
                };
                OrgChartState.nodes.set(clusterId, clusterNode);
            } else {
                node.children.forEach(child => processNode(child, node.id, level + 1));
            }
        }
    }
    
    processNode(data);
    
    // 레이아웃 계산
    calculateLayout();
}

// 레이아웃 계산 (Vertical Tree)
function calculateLayout() {
    const levels = new Map();
    
    // 레벨별로 노드 그룹화
    OrgChartState.nodes.forEach(node => {
        if (!levels.has(node.level)) {
            levels.set(node.level, []);
        }
        levels.get(node.level).push(node);
    });
    
    // 각 레벨의 노드 위치 계산
    levels.forEach((nodes, level) => {
        const totalWidth = nodes.length * (CONFIG.NODE_WIDTH + CONFIG.SIBLING_SPACING);
        const startX = -totalWidth / 2;
        
        nodes.forEach((node, index) => {
            node.x = startX + index * (CONFIG.NODE_WIDTH + CONFIG.SIBLING_SPACING) + CONFIG.NODE_WIDTH / 2;
            node.y = level * CONFIG.LEVEL_SPACING;
        });
    });
    
    // 엣지 생성
    OrgChartState.edges = [];
    OrgChartState.nodes.forEach(node => {
        if (node.parentId) {
            const parent = OrgChartState.nodes.get(node.parentId);
            if (parent) {
                OrgChartState.edges.push({
                    source: parent,
                    target: node,
                });
            }
        }
    });
}

// 차트 렌더링
function renderChart() {
    console.log('Rendering chart. Current view:', OrgChartState.currentView, 'Current level:', OrgChartState.currentLevel);
    
    const container = document.getElementById('treeContainer');
    if (!container) {
        console.error('Tree container not found!');
        return;
    }
    
    container.innerHTML = '';
    
    // 렌더링할 노드 수 확인
    const visibleNodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    console.log(`Rendering ${visibleNodes.length} visible nodes out of ${OrgChartState.nodes.size} total nodes`);
    
    // 뷰 모드에 따른 특화된 렌더링
    if (OrgChartState.currentView === 'grid') {
        renderGridView();
    } else if (OrgChartState.currentView === 'radial') {
        renderRadialView();
    } else if (OrgChartState.currentView === 'compact') {
        renderCompactView();
    } else {
        // 기본 세로형 뷰
        renderVerticalView();
    }
}

// 세로형 뷰 렌더링
function renderVerticalView() {
    const container = document.getElementById('treeContainer');
    const viewportWidth = document.getElementById('chartViewport').offsetWidth;
    const centerX = viewportWidth / 2;
    
    // 노드 렌더링
    OrgChartState.nodes.forEach(node => {
        if (shouldRenderNode(node)) {
            const nodeElement = createNodeElement(node);
            nodeElement.style.left = `${centerX + node.x - CONFIG.NODE_WIDTH / 2}px`;
            nodeElement.style.top = `${node.y}px`;
            container.appendChild(nodeElement);
        }
    });
    
    // 엣지 렌더링
    OrgChartState.edges.forEach(edge => {
        if (shouldRenderEdge(edge)) {
            const edgeElement = createEdgeElement(edge, centerX);
            container.appendChild(edgeElement);
        }
    });
}

// 그리드 뷰 렌더링
function renderGridView() {
    const container = document.getElementById('treeContainer');
    const nodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    const cols = 4;
    
    nodes.forEach((node, index) => {
        const row = Math.floor(index / cols);
        const col = index % cols;
        const nodeElement = createGridNodeElement(node);
        nodeElement.style.left = `${col * 250 + 50}px`;
        nodeElement.style.top = `${row * 180 + 50}px`;
        container.appendChild(nodeElement);
    });
}

// 방사형 뷰 렌더링
function renderRadialView() {
    const container = document.getElementById('treeContainer');
    const viewportWidth = document.getElementById('chartViewport').offsetWidth;
    const viewportHeight = document.getElementById('chartViewport').offsetHeight;
    const centerX = viewportWidth / 2;
    const centerY = viewportHeight / 2;
    
    // 중앙에 루트 노드
    const rootNode = OrgChartState.nodes.get('root');
    if (rootNode && shouldRenderNode(rootNode)) {
        const rootElement = createNodeElement(rootNode);
        rootElement.style.left = `${centerX - CONFIG.NODE_WIDTH / 2}px`;
        rootElement.style.top = `${centerY - CONFIG.NODE_HEIGHT / 2}px`;
        container.appendChild(rootElement);
        
        // 자식 노드들을 원형으로 배치
        const children = Array.from(OrgChartState.nodes.values())
            .filter(n => n.parentId === 'root' && shouldRenderNode(n));
        
        const angleStep = (2 * Math.PI) / children.length;
        const radius = 250;
        
        children.forEach((child, index) => {
            const angle = index * angleStep - Math.PI / 2;
            const x = centerX + radius * Math.cos(angle) - CONFIG.NODE_WIDTH / 2;
            const y = centerY + radius * Math.sin(angle) - CONFIG.NODE_HEIGHT / 2;
            
            const childElement = createNodeElement(child);
            childElement.style.left = `${x}px`;
            childElement.style.top = `${y}px`;
            container.appendChild(childElement);
        });
    }
}

// 컴팩트 뷰 렌더링
function renderCompactView() {
    const container = document.getElementById('treeContainer');
    const nodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    
    let y = 20;
    nodes.forEach(node => {
        const nodeElement = createCompactNodeElement(node);
        nodeElement.style.left = `20px`;
        nodeElement.style.top = `${y}px`;
        nodeElement.style.width = 'calc(100% - 40px)';
        container.appendChild(nodeElement);
        y += 50;
    });
}

// 노드 렌더링 여부 확인
function shouldRenderNode(node) {
    // 레벨 필터가 활성화된 경우 먼저 확인
    if (OrgChartState.currentLevel !== 'all') {
        console.log(`Filtering node ${node.name} (type: ${node.type}) with filter: ${OrgChartState.currentLevel}`);
        
        let shouldShow = false;
        switch(OrgChartState.currentLevel) {
            case 'executive':
                // 임원급만 표시 (회사, 본부)
                shouldShow = node.type === 'company' || node.type === 'division';
                break;
            case 'division':
                // 본부급까지만 표시
                shouldShow = node.type === 'company' || node.type === 'division';
                break;
            case 'department':
                // 부서급까지 표시
                shouldShow = node.type === 'company' || node.type === 'division' || node.type === 'department';
                break;
            case 'team':
                // 팀급까지 표시 (개인 제외)
                shouldShow = node.type !== 'person';
                break;
            default:
                shouldShow = true;
        }
        
        console.log(`Node ${node.name} - Level Filter Show: ${shouldShow}`);
        
        // 레벨 필터에서 보여야 하는 노드면 부모 체인도 자동 확장
        if (shouldShow) {
            ensureParentChainExpanded(node);
            return true;
        } else {
            return false;
        }
    }
    
    // Progressive Disclosure: 펼쳐진 부모의 자식만 표시 (레벨 필터가 없을 때만)
    if (node.parentId) {
        const parent = OrgChartState.nodes.get(node.parentId);
        if (!parent || !OrgChartState.expandedNodes.has(node.parentId)) {
            return false;
        }
    }
    
    return true;
}

// 부모 체인을 자동으로 확장
function ensureParentChainExpanded(node) {
    let currentNode = node;
    const nodesToExpand = [];
    
    // 루트까지 부모 체인을 추적
    while (currentNode.parentId) {
        const parent = OrgChartState.nodes.get(currentNode.parentId);
        if (parent) {
            nodesToExpand.push(parent.id);
            currentNode = parent;
        } else {
            break;
        }
    }
    
    // 모든 부모 노드를 확장된 상태로 설정
    nodesToExpand.forEach(nodeId => {
        OrgChartState.expandedNodes.add(nodeId);
        console.log(`Auto-expanded parent node: ${nodeId}`);
    });
}

// 엣지 렌더링 여부 확인
function shouldRenderEdge(edge) {
    return shouldRenderNode(edge.source) && shouldRenderNode(edge.target);
}

// 그리드 뷰용 노드 엘리먼트
function createGridNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node grid-node';
    div.id = `node-grid-${node.id}`;
    
    const badgeClass = `node-type-badge ${node.type}`;
    div.innerHTML = `
        <div class="node-header">
            <span class="${badgeClass}">${getNodeTypeLabel(node.type)}</span>
        </div>
        <div class="node-content">
            <div class="node-name">${node.name}</div>
            <div class="node-stats">
                <div class="node-stat">
                    <i class="fas fa-users node-stat-icon"></i>
                    <span>${node.headcount || 0}명</span>
                </div>
            </div>
        </div>
    `;
    
    div.addEventListener('click', () => focusNode(node.id));
    return div;
}

// 컴팩트 뷰용 노드 엘리먼트
function createCompactNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node compact-node';
    div.id = `node-compact-${node.id}`;
    div.style.cssText = 'display: flex; align-items: center; padding: 0.5rem 1rem; min-width: auto;';
    
    div.innerHTML = `
        <span class="node-type-badge ${node.type}" style="margin-right: 1rem;">${getNodeTypeLabel(node.type)}</span>
        <span style="flex: 1; color: white; font-weight: 500;">${node.name}</span>
        <span style="color: #94a3b8; font-size: 0.875rem;">${node.headcount || 0}명</span>
    `;
    
    div.addEventListener('click', () => focusNode(node.id));
    return div;
}

// 노드 엘리먼트 생성
function createNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node';
    div.id = `node-${node.id}`;
    div.setAttribute('role', 'treeitem');
    div.setAttribute('aria-expanded', OrgChartState.expandedNodes.has(node.id));
    div.setAttribute('aria-level', node.level);
    div.tabIndex = 0;
    
    if (node.id === OrgChartState.focusedNode) {
        div.classList.add('focused');
    }
    
    if (!OrgChartState.expandedNodes.has(node.id) && node.hasChildren) {
        div.classList.add('collapsed');
    }
    
    // 클러스터 노드 특별 처리
    if (node.isCluster) {
        div.innerHTML = `
            <div class="overflow-cluster">
                <div class="overflow-cluster-text">${node.name}</div>
            </div>
        `;
        div.addEventListener('click', () => expandCluster(node.id));
    } else {
        // 일반 노드 콘텐츠
        const badgeClass = `node-type-badge ${node.type}`;
        div.innerHTML = `
            <div class="node-header">
                <span class="${badgeClass}">${getNodeTypeLabel(node.type)}</span>
            </div>
            <div class="node-content">
                <div class="node-name">${node.name}</div>
                ${node.title ? `<div class="node-title">${node.title}</div>` : ''}
                <div class="node-stats">
                    ${node.headcount ? `
                        <div class="node-stat">
                            <i class="fas fa-users node-stat-icon"></i>
                            <span>${node.headcount}명</span>
                        </div>
                    ` : ''}
                    ${node.childrenCount ? `
                        <div class="node-stat">
                            <i class="fas fa-sitemap node-stat-icon"></i>
                            <span>${node.childrenCount}개</span>
                        </div>
                    ` : ''}
                </div>
                ${!OrgChartState.expandedNodes.has(node.id) && node.hasChildren ? `
                    <div class="node-children-info">
                        <i class="fas fa-chevron-down"></i> ${node.childrenCount}개 하위 조직
                    </div>
                ` : ''}
            </div>
            ${node.hasChildren ? `
                <button class="node-toggle" aria-label="${OrgChartState.expandedNodes.has(node.id) ? '접기' : '펼치기'}">
                    <i class="fas fa-chevron-${OrgChartState.expandedNodes.has(node.id) ? 'up' : 'down'}"></i>
                </button>
            ` : ''}
        `;
        
        // 이벤트 리스너
        div.addEventListener('click', () => focusNode(node.id));
        
        const toggleBtn = div.querySelector('.node-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleNode(node.id);
            });
        }
    }
    
    return div;
}

// 엣지 엘리먼트 생성
function createEdgeElement(edge, centerX) {
    const div = document.createElement('div');
    div.className = 'org-edge';
    
    const sourceX = centerX + edge.source.x;
    const sourceY = edge.source.y + CONFIG.NODE_HEIGHT;
    const targetX = centerX + edge.target.x;
    const targetY = edge.target.y;
    
    // 수직선
    div.style.left = `${sourceX - 1}px`;
    div.style.top = `${sourceY}px`;
    div.style.height = `${targetY - sourceY}px`;
    
    return div;
}

// 노드 타입 레이블
function getNodeTypeLabel(type) {
    const labels = {
        'company': '회사',
        'division': '본부',
        'department': '부서',
        'team': '팀',
        'person': '직원',
    };
    return labels[type] || type;
}

// 노드 토글
async function toggleNode(nodeId) {
    const node = OrgChartState.nodes.get(nodeId);
    if (!node || !node.hasChildren) return;
    
    if (OrgChartState.expandedNodes.has(nodeId)) {
        // 접기
        OrgChartState.expandedNodes.delete(nodeId);
    } else {
        // 펼치기
        OrgChartState.expandedNodes.add(nodeId);
        
        // Lazy Load: 자식이 없으면 서버에서 로드
        if (!node.children || node.children.length === 0) {
            await loadNodeChildren(nodeId);
        }
    }
    
    renderChart();
}

// 노드 자식 로드 (Lazy Loading)
async function loadNodeChildren(nodeId) {
    try {
        const response = await fetch(`/employees/api/org/node/${nodeId}?depth=1`);
        
        // 응답 상태 확인
        if (!response.ok) {
            console.error(`HTTP Error: ${response.status} ${response.statusText}`);
            return;
        }
        
        const data = await response.json();
        
        // 에러 응답 확인
        if (data.error) {
            console.error('API Error:', data.error);
            return;
        }
        
        const node = OrgChartState.nodes.get(nodeId);
        if (node && data.children) {
            node.children = data.children;
            processOrgData({ ...node, children: data.children });
            calculateLayout();
            console.log(`Successfully loaded ${data.children.length} children for node ${nodeId}`);
        } else {
            console.log(`No children found for node ${nodeId}`);
        }
    } catch (error) {
        console.error('Failed to load node children:', error);
        console.error('Node ID:', nodeId);
        
        // 사용자에게 알림 (선택적)
        // alert(`자식 노드를 로드하는데 실패했습니다: ${error.message}`);
    }
}

// 노드 포커스
function focusNode(nodeId) {
    OrgChartState.focusedNode = nodeId;
    
    // 모든 노드에서 포커스 클래스 제거
    document.querySelectorAll('.org-node').forEach(el => {
        el.classList.remove('focused');
    });
    
    // 새 노드에 포커스 클래스 추가
    const nodeElement = document.getElementById(`node-${nodeId}`);
    if (nodeElement) {
        nodeElement.classList.add('focused');
        nodeElement.focus();
        
        // 브레드크럼 업데이트
        updateBreadcrumb(nodeId);
        
        // 포커스 경로 펼치기
        expandPath(nodeId);
        
        // 스크롤 조정
        nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

// 경로 펼치기 (포커스된 노드까지)
function expandPath(nodeId) {
    const node = OrgChartState.nodes.get(nodeId);
    if (!node) return;
    
    const path = [];
    let current = node;
    while (current) {
        path.unshift(current.id);
        current = current.parentId ? OrgChartState.nodes.get(current.parentId) : null;
    }
    
    // 경로상의 모든 노드 펼치기
    path.forEach(id => {
        if (!OrgChartState.expandedNodes.has(id)) {
            const n = OrgChartState.nodes.get(id);
            if (n && n.hasChildren) {
                OrgChartState.expandedNodes.add(id);
            }
        }
    });
    
    renderChart();
}

// 브레드크럼 업데이트
function updateBreadcrumb(nodeId) {
    const breadcrumb = document.getElementById('breadcrumbNav');
    const node = OrgChartState.nodes.get(nodeId);
    if (!node) return;
    
    const path = [];
    let current = node;
    while (current) {
        path.unshift(current);
        current = current.parentId ? OrgChartState.nodes.get(current.parentId) : null;
    }
    
    breadcrumb.innerHTML = path.map((n, index) => `
        <span class="breadcrumb-item ${index === path.length - 1 ? 'active' : ''}" 
              onclick="focusNode('${n.id}')">
            ${n.name}
        </span>
        ${index < path.length - 1 ? '<span class="breadcrumb-separator">›</span>' : ''}
    `).join('');
}

// 형제 노드 탐색
function navigateToSibling(node, direction) {
    if (!node.parentId) return;
    
    const parent = OrgChartState.nodes.get(node.parentId);
    if (!parent || !parent.children) return;
    
    const currentIndex = parent.children.findIndex(c => c.id === node.id);
    if (currentIndex === -1) return;
    
    const newIndex = currentIndex + direction;
    if (newIndex >= 0 && newIndex < parent.children.length) {
        focusNode(parent.children[newIndex].id);
    }
}

// 검색 수행
async function performSearch(query) {
    OrgChartState.searchQuery = query;
    
    if (!query || query.length < 2) {
        document.getElementById('searchAutocomplete').classList.remove('active');
        return;
    }
    
    try {
        const response = await fetch(`/employees/api/org/search?q=${encodeURIComponent(query)}`);
        const results = await response.json();
        
        showSearchResults(results);
    } catch (error) {
        console.error('Search failed:', error);
    }
}

// 검색 결과 표시
function showSearchResults(data) {
    const autocomplete = document.getElementById('searchAutocomplete');
    
    // API 응답에서 results 배열 추출
    const results = data.results || data;
    
    if (!results || results.length === 0) {
        autocomplete.classList.remove('active');
        return;
    }
    
    autocomplete.innerHTML = results.slice(0, 10).map(result => `
        <div class="autocomplete-item" onclick="selectSearchResult('${result.id}')">
            <div class="autocomplete-item-name">${result.name}</div>
            <div class="autocomplete-item-path">${result.path.join(' › ')}</div>
        </div>
    `).join('');
    
    autocomplete.classList.add('active');
}

// 검색 결과 선택
function selectSearchResult(nodeId) {
    document.getElementById('searchAutocomplete').classList.remove('active');
    document.getElementById('orgSearch').value = '';
    
    // 경로 펼치고 포커스
    expandPath(nodeId);
    focusNode(nodeId);
}

// 뷰 모드 변경
function updateViewMode(mode) {
    console.log('Updating view mode to:', mode);
    OrgChartState.currentView = mode;
    
    // 버튼 상태 업데이트
    document.querySelectorAll('.view-mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    
    // 뷰에 따른 레이아웃 재계산
    if (mode === 'vertical') {
        calculateLayout();
    } else if (mode === 'radial') {
        calculateRadialLayout();
    } else if (mode === 'grid') {
        calculateGridLayout();
    } else if (mode === 'compact') {
        calculateCompactLayout();
    }
    
    console.log('Rendering chart with view mode:', mode);
    renderChart();
}

// 레벨 필터 업데이트
function updateLevelFilter(level) {
    console.log('Updating level filter to:', level);
    OrgChartState.currentLevel = level;
    
    // 버튼 상태 업데이트
    document.querySelectorAll('.level-filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.level === level);
    });
    
    // 레벨 필터 변경 시 expandedNodes 초기화하고 필요한 노드들만 확장
    if (level !== 'all') {
        OrgChartState.expandedNodes.clear();
        console.log('Cleared expandedNodes for level filtering');
        
        // 필터에 맞는 모든 노드들의 부모 체인을 미리 확장
        OrgChartState.nodes.forEach(node => {
            let shouldShow = false;
            switch(level) {
                case 'executive':
                    shouldShow = node.type === 'company' || node.type === 'division';
                    break;
                case 'division':
                    shouldShow = node.type === 'company' || node.type === 'division';
                    break;
                case 'department':
                    shouldShow = node.type === 'company' || node.type === 'division' || node.type === 'department';
                    break;
                case 'team':
                    shouldShow = node.type !== 'person';
                    break;
            }
            
            if (shouldShow) {
                ensureParentChainExpanded(node);
            }
        });
    } else {
        // 'all' 레벨인 경우 루트 노드만 확장된 상태로 초기화
        OrgChartState.expandedNodes.clear();
        OrgChartState.expandedNodes.add('OK금융그룹');
        console.log('Reset to default Progressive Disclosure mode');
    }
    
    console.log('Current state after level filter update:', OrgChartState.currentLevel);
    console.log('Expanded nodes:', Array.from(OrgChartState.expandedNodes));
    renderChart();
}

// 줌 업데이트
function updateZoom(level) {
    OrgChartState.zoomLevel = level;
    document.getElementById('zoomLevel').textContent = `${level}%`;
    
    const container = document.getElementById('treeContainer');
    container.style.transform = `scale(${level / 100})`;
    
    // 시맨틱 줌 클래스 적용
    container.classList.remove('zoom-small', 'zoom-large');
    if (level < 80) {
        container.classList.add('zoom-small');
    } else if (level > 120) {
        container.classList.add('zoom-large');
    }
}

// 클러스터 확장
function expandCluster(clusterId) {
    const clusteredNodes = OrgChartState.clusteredSiblings.get(clusterId);
    if (!clusteredNodes) return;
    
    // 클러스터 노드를 실제 노드로 교체
    const clusterNode = OrgChartState.nodes.get(clusterId);
    if (clusterNode) {
        const parentId = clusterNode.parentId;
        const level = clusterNode.level;
        
        // 클러스터 노드 제거
        OrgChartState.nodes.delete(clusterId);
        
        // 숨겨진 노드들 추가
        clusteredNodes.forEach(node => {
            processOrgData({ ...node, parentId, level });
        });
        
        // 클러스터 상태 제거
        OrgChartState.clusteredSiblings.delete(clusterId);
        
        // 레이아웃 재계산 및 렌더링
        calculateLayout();
        renderChart();
    }
}

// 로딩 표시
function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    overlay.style.display = show ? 'flex' : 'none';
}

// 에러 표시
function showError(message) {
    console.error(message);
    // 에러 메시지를 화면에 표시
    const viewport = document.getElementById('chartViewport');
    if (viewport && !document.getElementById('errorMessage')) {
        const errorDiv = document.createElement('div');
        errorDiv.id = 'errorMessage';
        errorDiv.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 0, 0, 0.1); color: #ff6b6b; padding: 1rem 2rem; border-radius: 0.5rem; border: 1px solid #ff6b6b;';
        errorDiv.textContent = message;
        viewport.appendChild(errorDiv);
        
        // 3초 후 에러 메시지 제거
        setTimeout(() => {
            errorDiv.remove();
        }, 3000);
    }
}

// 샘플 데이터 사용 (API 실패 시 백업)
function useSampleData() {
    const sampleData = {
        id: 'OK금융그룹',
        name: 'OK금융그룹',
        type: 'company',
        title: 'CEO',
        headcount: 1700,
        childrenCount: 5,
        hasChildren: true,
        parentId: null,
        path: ['OK금융그룹'],
        children: [
            {
                id: 'division-1',
                name: '경영지원본부',
                type: 'division',
                headcount: 320,
                childrenCount: 8,
                hasChildren: true,
                parentId: 'root',
                path: ['OK금융그룹', '경영지원본부'],
                children: [
                    {
                        id: 'dept-1-1',
                        name: '인사부',
                        type: 'department',
                        headcount: 45,
                        childrenCount: 2,
                        hasChildren: true,
                        parentId: 'division-1',
                        path: ['OK금융그룹', '경영지원본부', '인사부'],
                        children: [
                            {
                                id: 'team-1-1-1',
                                name: '채용팀',
                                type: 'team',
                                headcount: 12,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-1',
                                path: ['OK금융그룹', '경영지원본부', '인사부', '채용팀']
                            },
                            {
                                id: 'team-1-1-2',
                                name: '교육팀',
                                type: 'team',
                                headcount: 8,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-1',
                                path: ['OK금융그룹', '경영지원본부', '인사부', '교육팀']
                            }
                        ]
                    },
                    {
                        id: 'dept-1-2',
                        name: '재무부',
                        type: 'department',
                        headcount: 38,
                        childrenCount: 1,
                        hasChildren: true,
                        parentId: 'division-1',
                        path: ['OK금융그룹', '경영지원본부', '재무부'],
                        children: [
                            {
                                id: 'team-1-2-1',
                                name: '회계팀',
                                type: 'team',
                                headcount: 15,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-2',
                                path: ['OK금융그룹', '경영지원본부', '재무부', '회계팀']
                            }
                        ]
                    }
                ]
            },
            {
                id: 'division-2',
                name: 'IT본부',
                type: 'division',
                headcount: 450,
                childrenCount: 10,
                hasChildren: true,
                parentId: 'root',
                path: ['OK금융그룹', 'IT본부'],
                children: [
                    {
                        id: 'dept-2-1',
                        name: '개발부',
                        type: 'department',
                        headcount: 62,
                        childrenCount: 2,
                        hasChildren: true,
                        parentId: 'division-2',
                        path: ['OK금융그룹', 'IT본부', '개발부'],
                        children: [
                            {
                                id: 'team-2-1-1',
                                name: '프론트엔드팀',
                                type: 'team',
                                headcount: 18,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-1',
                                path: ['OK금융그룹', 'IT본부', '개발부', '프론트엔드팀']
                            },
                            {
                                id: 'team-2-1-2',
                                name: '백엔드팀',
                                type: 'team',
                                headcount: 25,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-1',
                                path: ['OK금융그룹', 'IT본부', '개발부', '백엔드팀']
                            }
                        ]
                    },
                    {
                        id: 'dept-2-2',
                        name: '인프라부',
                        type: 'department',
                        headcount: 35,
                        childrenCount: 1,
                        hasChildren: true,
                        parentId: 'division-2',
                        path: ['OK금융그룹', 'IT본부', '인프라부'],
                        children: [
                            {
                                id: 'team-2-2-1',
                                name: '클라우드팀',
                                type: 'team',
                                headcount: 12,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-2',
                                path: ['OK금융그룹', 'IT본부', '인프라부', '클라우드팀']
                            }
                        ]
                    }
                ]
            },
            {
                id: 'division-3',
                name: '영업본부',
                type: 'division',
                headcount: 580,
                childrenCount: 15,
                hasChildren: true,
                parentId: 'root',
                path: ['OK금융그룹', '영업본부'],
                children: []
            }
        ]
    };
    
    showLoading(false);
    processOrgData(sampleData);
    renderChart();
}

// 기타 레이아웃 계산 함수들 (간단한 구현)
function calculateRadialLayout() {
    console.log('Calculating radial layout...');
    // 방사형 레이아웃 계산 로직
    // 임시로 기본 레이아웃 사용
    calculateLayout();
}

function calculateGridLayout() {
    console.log('Calculating grid layout...');
    // 그리드 레이아웃 계산 로직
    const nodes = Array.from(OrgChartState.nodes.values());
    const cols = 4;
    let row = 0, col = 0;
    
    nodes.forEach((node, index) => {
        node.x = col * (CONFIG.NODE_WIDTH + CONFIG.SIBLING_SPACING) - (cols * CONFIG.NODE_WIDTH) / 2;
        node.y = row * (CONFIG.NODE_HEIGHT + 40);
        
        col++;
        if (col >= cols) {
            col = 0;
            row++;
        }
    });
}

function calculateCompactLayout() {
    console.log('Calculating compact layout...');
    // 컴팩트 레이아웃 계산 로직
    // 임시로 기본 레이아웃 사용
    calculateLayout();
}
</script>
{% endblock %}