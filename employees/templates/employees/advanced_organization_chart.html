{% extends "base_revolutionary.html" %}
{% load static %}

{% block title %}ì°¨ì„¸ëŒ€ ì¡°ì§ë„ | AI HRM{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/advanced-org-chart.css' %}?v=1757044832">
<style>
    /* ê¸°ë³¸ ë ˆì´ì•„ì›ƒ - ê°€ë¡œ ìŠ¤í¬ë¡¤ ì°¨ë‹¨ */
    .org-chart-container {
        background: linear-gradient(180deg, #0b1324, #0a0f1e);
        min-height: calc(100vh - 70px);
        position: relative;
        display: flex;
        flex-direction: column;
        overflow-x: hidden; /* ê°€ë¡œ ìŠ¤í¬ë¡¤ ì°¨ë‹¨ */
    }

    /* íˆ´ë°” ìŠ¤íƒ€ì¼ */
    .org-toolbar {
        background: rgba(26, 31, 46, 0.95);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        padding: 1rem;
        position: sticky;
        top: 0;
        z-index: 1000;
    }

    .toolbar-inner {
        display: flex;
        align-items: center;
        gap: 1.5rem;
        max-width: 1600px;
        margin: 0 auto;
    }

    /* ë·° ëª¨ë“œ ì„ íƒ */
    .view-modes {
        display: flex;
        gap: 0.5rem;
        background: rgba(10, 15, 27, 0.6);
        padding: 0.25rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(0, 212, 255, 0.2);
    }

    .view-mode-btn {
        padding: 0.5rem 1rem;
        background: transparent;
        color: #94a3b8;
        border: none;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .view-mode-btn.active {
        background: linear-gradient(135deg, #00d4ff, #0099cc);
        color: white;
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
    }

    .view-mode-btn:hover:not(.active) {
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
    }

    /* ë ˆë²¨ í•„í„° */
    .level-filters {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    .level-filter-btn {
        padding: 0.375rem 0.75rem;
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.813rem;
    }

    .level-filter-btn.active {
        background: rgba(0, 212, 255, 0.2);
        border-color: #00d4ff;
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.2);
    }

    /* ê²€ìƒ‰ ë°•ìŠ¤ */
    .org-search-box {
        position: relative;
        flex: 1;
        max-width: 400px;
    }

    .org-search-input {
        width: 100%;
        padding: 0.625rem 1rem 0.625rem 2.5rem;
        background: rgba(10, 15, 27, 0.6);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        color: white;
        font-size: 0.875rem;
        transition: all 0.3s ease;
    }

    .org-search-input:focus {
        border-color: #00d4ff;
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        outline: none;
    }

    .org-search-icon {
        position: absolute;
        left: 0.875rem;
        top: 50%;
        transform: translateY(-50%);
        color: #94a3b8;
    }

    /* ìë™ì™„ì„± ë“œë¡­ë‹¤ìš´ */
    .search-autocomplete {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        margin-top: 0.5rem;
        background: rgba(26, 31, 46, 0.98);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        z-index: 1001;
    }

    .search-autocomplete.active {
        display: block;
    }

    .autocomplete-item {
        padding: 0.75rem 1rem;
        color: #cbd5e1;
        cursor: pointer;
        transition: all 0.2s ease;
        border-bottom: 1px solid rgba(0, 212, 255, 0.1);
    }

    .autocomplete-item:hover {
        background: rgba(0, 212, 255, 0.1);
        color: white;
    }

    .autocomplete-item-name {
        font-weight: 500;
        color: white;
    }

    .autocomplete-item-path {
        font-size: 0.75rem;
        color: #64748b;
        margin-top: 0.25rem;
    }

    /* ì¤Œ ì»¨íŠ¸ë¡¤ */
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background: rgba(10, 15, 27, 0.6);
        padding: 0.25rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(0, 212, 255, 0.2);
    }

    .zoom-btn {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        color: #94a3b8;
        border: none;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .zoom-btn:hover {
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
    }

    .zoom-level {
        color: #00d4ff;
        font-size: 0.813rem;
        min-width: 50px;
        text-align: center;
    }

    /* ë©”ì¸ ì°¨íŠ¸ ì˜ì—­ */
    .chart-viewport {
        flex: 1;
        position: relative;
        overflow: auto; /* ê°€ë¡œ/ì„¸ë¡œ ìŠ¤í¬ë¡¤ ëª¨ë‘ í—ˆìš© */
        padding: 1rem;
        background: linear-gradient(to bottom, 
            rgba(10, 15, 27, 0.9),
            rgba(26, 31, 46, 0.95));
    }

    /* íŠ¸ë¦¬ ì»¨í…Œì´ë„ˆ - í™•ëŒ€ ê¸°ì¤€ ìƒë‹¨ ì¢Œì¸¡ */
    .tree-container {
        min-height: 100%;
        position: relative;
        transition: transform 0.3s ease;
        transform-origin: top left; /* í™•ëŒ€ ê¸°ì¤€ì ì„ ì¢Œì¸¡ìœ¼ë¡œ ë³€ê²½ */
    }

    /* ê¸°ë³¸ ë…¸ë“œ ìŠ¤íƒ€ì¼ - PDF ìŠ¤íƒ€ì¼ë¡œ í†µì¼ */
    .org-node {
        position: absolute;
        width: 30px !important;
        height: 40px !important;
        min-height: unset !important;
        max-height: unset !important;
        padding: 1px !important;
        background: white !important;
        border: 1px solid #000 !important;
        border-radius: 0 !important;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 9px !important;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }
    
    /* ë…¸ë“œ ì™¼ìª½ ì„¸ë¡œ spine (íƒ€ì… í‘œì‹œ) */
    .node-spine {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 24px; /* w-6 */
        opacity: 0.7;
        border-radius: 1rem 0 0 1rem;
    }
    
    .node-spine.company {
        background: linear-gradient(to bottom, #06b6d4, transparent); /* cyan-500 */
    }
    
    .node-spine.division {
        background: linear-gradient(to bottom, #d946ef, transparent); /* fuchsia-500 */
    }
    
    .node-spine.department {
        background: linear-gradient(to bottom, #14b8a6, transparent); /* teal-500 */
    }
    
    .node-spine.team {
        background: linear-gradient(to bottom, #64748b, transparent); /* slate-500 */
    }
    
    .node-spine.person {
        background: linear-gradient(to bottom, #f59e0b, transparent); /* amber-500 */
    }

    .org-node:hover {
        border-color: #00d4ff !important;
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.3) !important;
    }

    .org-node.focused {
        border-color: #00d4ff;
        box-shadow: 0 0 40px rgba(0, 212, 255, 0.5);
        background: rgba(0, 212, 255, 0.05);
    }

    .org-node.collapsed .node-children-info {
        display: block;
    }

    /* ë…¸ë“œ í—¤ë” */
    .node-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0.5rem;
    }

    .node-type-badge {
        display: inline-block;
        padding: 0.25rem 0.625rem;
        background: rgba(0, 212, 255, 0.25);
        color: #00d4ff;
        border-radius: 0.375rem;
        font-size: 0.75rem; /* 12pxë¡œ ì¦ê°€ */
        font-weight: 500;
        text-transform: uppercase;
    }

    .node-type-badge.company {
        background: rgba(168, 85, 247, 0.2);
        color: #a855f7;
    }

    .node-type-badge.division {
        background: rgba(236, 72, 153, 0.2);
        color: #ec4899;
    }

    .node-type-badge.department {
        background: rgba(34, 197, 94, 0.2);
        color: #22c55e;
    }

    .node-type-badge.team {
        background: rgba(251, 146, 60, 0.2);
        color: #fb923c;
    }

    /* ë…¸ë“œ ì½˜í…ì¸  - TallNode ë ˆì´ì•„ì›ƒ */
    .node-content {
        color: white;
        padding: 0.5rem 0.375rem;
        padding-left: 1.25rem; /* spine ê³µê°„ í™•ë³´ */
        display: flex;
        flex-direction: column;
        gap: 0.375rem;
        flex: 1;
    }

    .node-name {
        font-size: 0.875rem; /* 14pxë¡œ ì¦ê°€ */
        font-weight: 700;
        line-height: 1.3;
        color: rgba(255, 255, 255, 0.95);
        /* 3ì¤„ í´ë¨í”„ */
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .node-title {
        font-size: 0.75rem; /* 12pxë¡œ ì¦ê°€ */
        color: rgba(255, 255, 255, 0.7);
        line-height: 1.4;
        /* 2ì¤„ í´ë¨í”„ */
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* ë…¸ë“œ í†µê³„ ê·¸ë¦¬ë“œ */
    .node-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.25rem;
        margin-top: 0.25rem;
    }

    .node-stat {
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.8);
        padding: 0.25rem 0.375rem;
        border-radius: 0.375rem;
        font-size: 0.75rem; /* 12pxë¡œ ì¦ê°€ */
        text-align: center;
    }

    /* ë…¸ë“œ ë°°ì§€ */
    .node-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        margin-top: 0.25rem;
    }
    
    .node-badge {
        padding: 0.125rem 0.375rem;
        background: rgba(16, 185, 129, 0.1); /* emerald-400/10 */
        color: #10b981; /* emerald-300 */
        border-radius: 0.25rem;
        font-size: 0.625rem; /* text-[10px] */
    }

    /* ì ‘ê¸°/í¼ì¹˜ê¸° ë²„íŠ¼ */
    .node-toggle {
        position: absolute;
        bottom: -12px;
        left: 50%;
        transform: translateX(-50%);
        width: 24px;
        height: 24px;
        background: rgba(26, 31, 46, 0.95);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: #00d4ff;
        transition: all 0.2s ease;
    }

    .node-toggle:hover {
        background: rgba(0, 212, 255, 0.2);
        border-color: #00d4ff;
    }

    /* í•˜ìœ„ ë…¸ë“œ ì •ë³´ (ì ‘íŒ ìƒíƒœ) */
    .node-children-info {
        display: none;
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid rgba(0, 212, 255, 0.1);
        font-size: 0.813rem;
        color: #00d4ff;
    }

    /* ì˜¤ë²„í”Œë¡œìš° í´ëŸ¬ìŠ¤í„° */
    .overflow-cluster {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        padding: 0.75rem;
        margin-top: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
    }

    .overflow-cluster:hover {
        background: rgba(0, 212, 255, 0.1);
        border-color: #00d4ff;
    }

    .overflow-cluster-text {
        color: #00d4ff;
        font-size: 0.875rem;
    }

    /* ì—°ê²°ì„  - ê°€ë…ì„± ìš°ì„  */
    .org-edge {
        position: absolute;
        background: rgba(56, 189, 248, 0.35); /* ë‹¨ìˆœí•œ ì„  */
        width: 2px;
        transition: all 0.3s ease;
        pointer-events: none;
    }

    .org-edge.horizontal {
        height: 2px;
        width: auto;
        background: rgba(56, 189, 248, 0.35);
    }

    /* ë¯¸ë‹ˆë§µ */
    .minimap {
        position: fixed;
        bottom: 20px;
        left: 20px;  /* ì™¼ìª½ í•˜ë‹¨ìœ¼ë¡œ ì´ë™ */
        width: 166px;  /* íŒ¨ë”© í¬í•¨í•˜ì—¬ ì¡°ì • */
        height: 136px;
        background: rgba(26, 31, 46, 0.95);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 0.5rem;
        padding: 8px;
        z-index: 900;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    #minimapCanvas {
        display: block;
        width: 150px;
        height: 120px;
        cursor: pointer;
        border-radius: 4px;
    }

    .minimap-viewport {
        position: absolute;
        background: rgba(0, 212, 255, 0.2);
        border: 1px solid #00d4ff;
        pointer-events: none;
    }

    /* ë¸Œë ˆë“œí¬ëŸ¼ */
    .breadcrumb-nav {
        background: rgba(10, 15, 27, 0.6);
        padding: 0.75rem 1rem;
        border-bottom: 1px solid rgba(0, 212, 255, 0.1);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        overflow-x: auto;
    }

    .breadcrumb-item {
        color: #64748b;
        font-size: 0.875rem;
        white-space: nowrap;
        cursor: pointer;
        transition: color 0.2s ease;
    }

    .breadcrumb-item:hover {
        color: #00d4ff;
    }

    .breadcrumb-separator {
        color: #475569;
    }

    .breadcrumb-item.active {
        color: white;
        font-weight: 500;
    }

    /* ë¡œë”© ìƒíƒœ */
    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(10, 15, 27, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(0, 212, 255, 0.2);
        border-top-color: #00d4ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    /* ë°˜ì‘í˜• ë””ìì¸ */
    @media (max-width: 768px) {
        .toolbar-inner {
            flex-direction: column;
            gap: 1rem;
        }

        .org-search-box {
            max-width: 100%;
        }

        .minimap {
            width: 150px;
            height: 90px;
        }
    }

    /* ì‹œë§¨í‹± ì¤Œ ë ˆë²¨ */
    .tree-container.zoom-small .node-title,
    .tree-container.zoom-small .node-stats {
        display: none;
    }

    .tree-container.zoom-small .org-node {
        padding: 0.375rem;
        min-width: 120px;
    }

    .tree-container.zoom-large .org-node {
        padding: 0.75rem;
        min-width: 180px;
    }

    /* í‚¤ë³´ë“œ ë‚´ë¹„ê²Œì´ì…˜ í¬ì»¤ìŠ¤ */
    .org-node:focus {
        outline: 2px solid #00d4ff;
        outline-offset: 2px;
    }

    /* ì ‘ê·¼ì„± */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }
    
    /* ì„¸ë¡œ ê¸€ì ìœ í‹¸ë¦¬í‹° (DenseTallNodeìš©) - CJK ìµœì í™” - ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘ */
    .vertical-cjk {
        writing-mode: vertical-rl !important;
        text-orientation: upright !important; /* CJK ë¬¸ì ì§ë¦½ */
    }
    
    .vertical-mixed {
        writing-mode: vertical-rl !important;
        text-orientation: mixed !important; /* ì˜ë¬¸/ìˆ«ì ì„ì¼ ë•Œ */
    }
    
    .v-chip {
        writing-mode: vertical-rl !important;
        text-orientation: mixed !important;
        font-size: 10px !important;
        line-height: 1 !important;
    }
    
    /* Dense ëª¨ë“œ (30px x 40px) - PDF ìŠ¤íƒ€ì¼ */
    .dense-node {
        width: 30px !important;
        height: 40px !important;
        min-height: unset !important;
        padding: 1px !important;
        background: white !important;
        border: 1px solid #000 !important;
        border-radius: 0 !important;
        color: black !important;
    }
    
    /* Ultra ëª¨ë“œ (25px x 40px) - PDF ìŠ¤íƒ€ì¼ */
    .ultra-node {
        width: 25px !important;
        height: 40px !important;
        min-height: unset !important;
        padding: 1px !important;
        background: white !important;
        border: 1px solid #000 !important;
        border-radius: 0 !important;
    }
    
    .dense-node .node-content {
        padding: 0.25rem !important;
        margin-left: 3px !important;
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        gap: 0.75rem !important;
        height: 100% !important;
    }
    
    /* Dense ë…¸ë“œ ì´ë¦„ - ì„¸ë¡œì“°ê¸° ê°•ì œ ì ìš© */
    .dense-node .node-name,
    .dense-node .vertical-cjk {
        writing-mode: vertical-rl !important;
        text-orientation: upright !important; /* ì‘ì—…ì§€ì‹œì„œ: CJK upright */
        max-height: 220px !important;
        overflow: hidden !important;
        flex: 1 !important;
        display: flex !important;
        align-items: center !important;
    }
    
    .dense-node .node-stats {
        display: flex !important;
        flex-direction: column !important;
        gap: 0.25rem !important;
    }
    
    /* Dense ë…¸ë“œ í†µê³„ ì¹© - ì„¸ë¡œì“°ê¸° ê°•ì œ ì ìš© */
    .dense-node .node-stat,
    .dense-node .v-chip {
        writing-mode: vertical-rl !important;
        text-orientation: mixed !important;
        font-size: 8px !important;
        padding: 0.25rem !important;
        background: rgba(255, 255, 255, 0.05) !important;
        color: rgba(255, 255, 255, 0.7) !important;
        border-radius: 0.25rem !important;
    }
    
    /* ============================================== */
    /* ğŸ¨ ìŠˆí¼í´ë¡œë“œ ì‘ì—…ì§€ì‹œì„œ - ê°€ë…ì„± ìš°ì„  ë””ìì¸ */
    /* ============================================== */
    
    /* ğŸ“Š ì°¨íŠ¸ ì»¨í…Œì´ë„ˆ - ì ˆì œëœ ë‹¤í¬ ë°°ê²½ */
    .org-chart-container {
        background: linear-gradient(180deg, #0b1324 0%, #0a0f1e 100%) !important;
    }
    
    /* ì¤‘ë³µ ìŠ¤íƒ€ì¼ ì œê±° - ìœ„ì—ì„œ ì •ì˜ë¨ */
    
    /* ì¤‘ë³µ hover íš¨ê³¼ ì œê±° */
    
    /* ğŸŒˆ ê³„ì¸µë³„ Spine ìƒ‰ìƒ - ë„¤ì˜¨ ê·¸ë¼ë°ì´ì…˜ */
    .node-spine {
        width: 32px !important;
        opacity: 0.9 !important;
        backdrop-filter: blur(8px) !important;
        border-radius: 24px 0 0 24px !important;
    }
    
    .node-spine.company, .node-spine.group, .node-spine.subsidiary {
        background: linear-gradient(180deg, 
            #00ffff 0%, 
            #00ccff 30%, 
            #0099ff 60%, 
            transparent 100%) !important;
        box-shadow: 
            inset 0 0 20px rgba(0, 255, 255, 0.5),
            0 0 30px rgba(0, 255, 255, 0.4) !important;
    }
    
    .node-spine.division {
        background: linear-gradient(180deg, 
            #ff00ff 0%, 
            #cc00ff 30%, 
            #9933ff 60%, 
            transparent 100%) !important;
        box-shadow: 
            inset 0 0 20px rgba(255, 0, 255, 0.5),
            0 0 30px rgba(255, 0, 255, 0.4) !important;
    }
    
    .node-spine.department {
        background: linear-gradient(180deg, 
            #00ff88 0%, 
            #00dd66 30%, 
            #00aa44 60%, 
            transparent 100%) !important;
        box-shadow: 
            inset 0 0 20px rgba(0, 255, 136, 0.5),
            0 0 30px rgba(0, 255, 136, 0.4) !important;
    }
    
    .node-spine.team {
        background: linear-gradient(180deg, 
            #88ccff 0%, 
            #6699ff 30%, 
            #4466cc 60%, 
            transparent 100%) !important;
        box-shadow: 
            inset 0 0 20px rgba(136, 204, 255, 0.5),
            0 0 30px rgba(136, 204, 255, 0.4) !important;
    }
    
    /* ğŸ’ ë…¸ë“œ í—¤ë” - í”„ë¦¬ë¯¸ì—„ ìŠ¤íƒ€ì¼ */
    .node-header {
        background: linear-gradient(90deg, 
            rgba(0, 212, 255, 0.1) 0%, 
            rgba(0, 150, 255, 0.05) 50%, 
            transparent 100%) !important;
        border-bottom: 1px solid rgba(0, 212, 255, 0.2) !important;
        padding: 0.875rem !important;
    }
    
    /* ğŸ·ï¸ íƒ€ì… ë°°ì§€ - ë„¤ì˜¨ íš¨ê³¼ */
    .node-type-badge {
        background: linear-gradient(135deg, 
            rgba(0, 255, 255, 0.25), 
            rgba(0, 180, 255, 0.15)) !important;
        color: #00ffff !important;
        border: 1px solid rgba(0, 255, 255, 0.4) !important;
        padding: 0.375rem 0.625rem !important;
        border-radius: 10px !important;
        font-weight: 700 !important;
        text-transform: uppercase !important;
        letter-spacing: 1px !important;
        text-shadow: 0 0 15px rgba(0, 255, 255, 0.8) !important;
        box-shadow: 
            0 0 20px rgba(0, 255, 255, 0.3),
            inset 0 0 10px rgba(255, 255, 255, 0.1) !important;
    }
    
    /* âœ¨ ë…¸ë“œ ì´ë¦„ - í–¥ìƒëœ ê°€ë…ì„± */
    .node-name {
        font-size: 1.125rem !important;
        font-weight: 800 !important;
        color: #ffffff !important;
        text-shadow: 
            0 2px 8px rgba(0, 0, 0, 0.5),
            0 0 20px rgba(0, 212, 255, 0.3) !important;
        letter-spacing: -0.3px !important;
        line-height: 1.4 !important;
        margin-bottom: 0.625rem !important;
    }
    
    /* ğŸ“ ë…¸ë“œ ì§ì±… - ë¶€ë“œëŸ¬ìš´ ìŠ¤íƒ€ì¼ */
    .node-title {
        font-size: 0.875rem !important;
        color: rgba(180, 220, 255, 0.9) !important;
        font-weight: 500 !important;
        line-height: 1.5 !important;
        margin-bottom: 0.875rem !important;
    }
    
    /* ğŸ“ˆ í†µê³„ ì¹´ë“œ - ê¸€ë¼ìŠ¤ íš¨ê³¼ */
    .node-stat {
        background: linear-gradient(135deg, 
            rgba(0, 212, 255, 0.15), 
            rgba(0, 150, 200, 0.08)) !important;
        border: 1px solid rgba(0, 212, 255, 0.3) !important;
        border-radius: 12px !important;
        padding: 0.5rem 0.625rem !important;
        font-size: 0.875rem !important;
        font-weight: 600 !important;
        backdrop-filter: blur(8px) !important;
        transition: all 0.3s ease !important;
    }
    
    .node-stat:hover {
        background: linear-gradient(135deg, 
            rgba(0, 212, 255, 0.25), 
            rgba(0, 150, 200, 0.15)) !important;
        border-color: rgba(0, 212, 255, 0.5) !important;
        transform: translateY(-2px) !important;
        box-shadow: 0 5px 15px rgba(0, 212, 255, 0.2) !important;
    }
    
    .stat-label {
        color: rgba(150, 200, 255, 0.9) !important;
        font-size: 0.75rem !important;
        text-transform: uppercase !important;
        letter-spacing: 0.5px !important;
        margin-bottom: 0.125rem !important;
    }
    
    .stat-value {
        color: #00ffff !important;
        font-size: 1.125rem !important;
        font-weight: 700 !important;
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.5) !important;
    }
    
    /* ğŸ”— ì—°ê²°ì„  - ì• ë‹ˆë©”ì´ì…˜ ë„¤ì˜¨ íš¨ê³¼ */
    .org-edge {
        background: linear-gradient(180deg, 
            rgba(0, 255, 255, 0.8) 0%, 
            rgba(0, 212, 255, 0.5) 30%, 
            rgba(0, 150, 255, 0.3) 60%, 
            rgba(0, 100, 200, 0.1) 100%) !important;
        width: 4px !important;
        border-radius: 3px !important;
        box-shadow: 
            0 0 15px rgba(0, 255, 255, 0.4),
            0 0 30px rgba(0, 212, 255, 0.3),
            inset 0 0 10px rgba(255, 255, 255, 0.3) !important;
        animation: pulse-neon 2s ease-in-out infinite !important;
    }
    
    @keyframes pulse-neon {
        0%, 100% { 
            opacity: 0.7;
            filter: brightness(1);
        }
        50% { 
            opacity: 1;
            filter: brightness(1.3);
        }
    }
    
    /* ğŸ”½ í† ê¸€ ë²„íŠ¼ - í”„ë¦¬ë¯¸ì—„ ìŠ¤íƒ€ì¼ */
    .node-toggle {
        background: linear-gradient(135deg, 
            rgba(0, 212, 255, 0.9), 
            rgba(0, 150, 255, 0.8)) !important;
        border: 2px solid rgba(255, 255, 255, 0.3) !important;
        box-shadow: 
            0 0 20px rgba(0, 212, 255, 0.5),
            0 5px 15px rgba(0, 0, 0, 0.3) !important;
        width: 32px !important;
        height: 32px !important;
        font-size: 1rem !important;
        transition: all 0.3s ease !important;
    }
    
    .node-toggle:hover {
        background: linear-gradient(135deg, 
            rgba(0, 255, 255, 0.9), 
            rgba(0, 180, 255, 0.8)) !important;
        transform: scale(1.2) !important;
        box-shadow: 
            0 0 30px rgba(0, 255, 255, 0.7),
            0 8px 20px rgba(0, 0, 0, 0.4) !important;
    }
    
    /* ğŸ›ï¸ íˆ´ë°” - í”„ë¦¬ë¯¸ì—„ ê¸€ë¼ìŠ¤ íš¨ê³¼ */
    .org-toolbar {
        background: linear-gradient(135deg, 
            rgba(20, 25, 40, 0.98) 0%, 
            rgba(15, 20, 35, 0.95) 100%) !important;
        backdrop-filter: blur(30px) saturate(200%) !important;
        border-bottom: 1px solid rgba(0, 255, 255, 0.2) !important;
        box-shadow: 
            0 8px 40px rgba(0, 0, 0, 0.6),
            0 0 80px rgba(0, 212, 255, 0.1) !important;
    }
    
    /* ğŸ” ê²€ìƒ‰ ë°•ìŠ¤ - ë„¤ì˜¨ í¬ì»¤ìŠ¤ */
    .org-search input {
        background: rgba(10, 15, 25, 0.8) !important;
        border: 1px solid rgba(0, 212, 255, 0.3) !important;
        color: #ffffff !important;
        transition: all 0.3s ease !important;
    }
    
    .org-search input:focus {
        background: rgba(15, 20, 30, 0.9) !important;
        border-color: rgba(0, 255, 255, 0.6) !important;
        box-shadow: 
            0 0 30px rgba(0, 255, 255, 0.3),
            inset 0 0 20px rgba(0, 212, 255, 0.1) !important;
    }
    
    /* ğŸ“ ë¯¸ë‹ˆë§µ - í–¥ìƒëœ ìŠ¤íƒ€ì¼ */
    .minimap {
        background: linear-gradient(135deg, 
            rgba(20, 25, 40, 0.95), 
            rgba(10, 15, 25, 0.9)) !important;
        border: 1px solid rgba(0, 255, 255, 0.3) !important;
        box-shadow: 
            0 10px 40px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(0, 212, 255, 0.15) !important;
    }
    
    /* ğŸŒŸ í¬ì»¤ìŠ¤ íš¨ê³¼ */
    .org-node:focus {
        outline: 3px solid rgba(0, 255, 255, 0.8) !important;
        outline-offset: 4px !important;
        box-shadow: 
            0 0 60px rgba(0, 255, 255, 0.4),
            0 35px 70px rgba(0, 0, 0, 0.6) !important;
    }
    
    /* ğŸ“± Dense ëª¨ë“œ ê°œì„  */
    .dense-node {
        background: linear-gradient(145deg, 
            rgba(20, 30, 48, 0.95), 
            rgba(12, 18, 32, 0.92)) !important;
        border: 1px solid rgba(0, 255, 255, 0.2) !important;
        box-shadow: 
            0 15px 30px rgba(0, 0, 0, 0.4),
            0 0 40px rgba(0, 212, 255, 0.08) !important;
    }
    
    .dense-node:hover {
        transform: translateY(-3px) scale(1.05) !important;
        border-color: rgba(0, 255, 255, 0.4) !important;
        box-shadow: 
            0 20px 40px rgba(0, 0, 0, 0.5),
            0 0 60px rgba(0, 212, 255, 0.15) !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="org-chart-container">
    <!-- íˆ´ë°” -->
    <div class="org-toolbar">
        <div class="toolbar-inner">
            <!-- ë·° ëª¨ë“œ ì„ íƒ -->
            <div class="view-modes">
                <button class="view-mode-btn active" data-mode="vertical">
                    <i class="fas fa-sitemap"></i>
                    <span>ì„¸ë¡œí˜•</span>
                </button>
                <button class="view-mode-btn" data-mode="grid">
                    <i class="fas fa-th"></i>
                    <span>ê·¸ë¦¬ë“œ</span>
                </button>
                <button class="view-mode-btn" data-mode="radial">
                    <i class="fas fa-circle-notch"></i>
                    <span>ë°©ì‚¬í˜•</span>
                </button>
                <button class="view-mode-btn" data-mode="compact">
                    <i class="fas fa-list"></i>
                    <span>ì»´íŒ©íŠ¸</span>
                </button>
            </div>

            <!-- ë ˆë²¨ í•„í„° -->
            <div class="level-filters">
                <span style="color: #94a3b8; font-size: 0.875rem;">ë ˆë²¨:</span>
                <button class="level-filter-btn active" data-level="all">ì „ì²´</button>
                <button class="level-filter-btn" data-level="executive">ì„ì›</button>
                <button class="level-filter-btn" data-level="division">ë³¸ë¶€</button>
                <button class="level-filter-btn" data-level="department">ë¶€ì„œ</button>
                <button class="level-filter-btn" data-level="team">íŒ€</button>
            </div>

            <!-- ê²€ìƒ‰ -->
            <div class="org-search-box">
                <i class="fas fa-search org-search-icon"></i>
                <input type="text" class="org-search-input" placeholder="ì´ë¦„, ë¶€ì„œ, ì§ê¸‰ìœ¼ë¡œ ê²€ìƒ‰..." id="orgSearch">
                <div class="search-autocomplete" id="searchAutocomplete"></div>
            </div>

            <!-- ì¤Œ ì»¨íŠ¸ë¡¤ -->
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">
                    <i class="fas fa-minus"></i>
                </button>
                <span class="zoom-level" id="zoomLevel">92%</span>
                <button class="zoom-btn" id="zoomIn">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="zoom-btn" id="zoomReset">
                    <i class="fas fa-expand"></i>
                </button>
            </div>
            
            <!-- ê¹Šì´ í™•ì¥ ë²„íŠ¼ -->
            <div class="depth-controls" style="display: flex; gap: 0.5rem;">
                <button class="level-filter-btn" onclick="expandToDepth('OKê¸ˆìœµê·¸ë£¹', 2)" title="ë ˆë²¨ 2ê¹Œì§€ í¼ì¹¨">
                    <i class="fas fa-layer-group"></i> L2
                </button>
                <button class="level-filter-btn" onclick="expandToDepth('OKê¸ˆìœµê·¸ë£¹', 3)" title="ë ˆë²¨ 3ê¹Œì§€ í¼ì¹¨">
                    <i class="fas fa-layer-group"></i> L3
                </button>
                <button class="level-filter-btn" onclick="expandToDepth('OKê¸ˆìœµê·¸ë£¹', 4)" title="ë ˆë²¨ 4ê¹Œì§€ í¼ì¹¨">
                    <i class="fas fa-layer-group"></i> L4
                </button>
            </div>
        </div>
    </div>

    <!-- ë¸Œë ˆë“œí¬ëŸ¼ ë„¤ë¹„ê²Œì´ì…˜ -->
    <div class="breadcrumb-nav" id="breadcrumbNav">
        <span class="breadcrumb-item active">ì „ì²´ ì¡°ì§</span>
    </div>

    <!-- ë©”ì¸ ì°¨íŠ¸ ì˜ì—­ -->
    <div class="chart-viewport" id="chartViewport">
        <div class="tree-container" id="treeContainer">
            <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë  ì¡°ì§ë„ ë…¸ë“œë“¤ -->
        </div>

        <!-- ë¡œë”© ì˜¤ë²„ë ˆì´ -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- ë¯¸ë‹ˆë§µ -->
    <div class="minimap" id="minimap">
        <canvas id="minimapCanvas" width="150" height="120"></canvas>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{% static 'js/advanced-org-chart.js' %}?v=1757044832"></script>
<script>
// ì „ì—­ ìƒíƒœ ê´€ë¦¬
console.log(`ğŸ”„ ì°¨ì„¸ëŒ€ ì¡°ì§ë„ v2.1 loaded at ${new Date().toISOString()} - Boundary fix applied`);

// OrgChartStateê°€ ì´ë¯¸ external JSì—ì„œ ì •ì˜ë˜ì—ˆëŠ”ì§€ í™•ì¸
// ì „ì—­ ë³€ìˆ˜ë¡œ ì„ ì–¸í•˜ì§€ ì•Šê³  ì§ì ‘ windowì— í• ë‹¹
if (typeof window.OrgChartState !== 'undefined' && window.OrgChartState.constructor) {
    // external JSì—ì„œ í´ë˜ìŠ¤ë¡œ ì •ì˜ëœ ê²½ìš°, ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    window.OrgChartState = new window.OrgChartState();
    // ì¶”ê°€ ì†ì„± ì„¤ì •
    window.OrgChartState.currentView = 'vertical';
    window.OrgChartState.currentLevel = 'all';
    window.OrgChartState.expandedNodes.add('OKê¸ˆìœµê·¸ë£¹');
    window.OrgChartState.clusteredSiblings = new Map();
} else {
    // fallback: external JSê°€ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš°
    window.OrgChartState = {
        currentView: 'vertical',
        currentLevel: 'all',
        zoomLevel: 100,
        focusedNode: null,
        expandedNodes: new Set(['OKê¸ˆìœµê·¸ë£¹']), // ë£¨íŠ¸ ë…¸ë“œë§Œ ì´ˆê¸° í¼ì¹¨
        searchQuery: '',
        nodes: new Map(),
        edges: [],
        clusteredSiblings: new Map(), // ì˜¤ë²„í”Œë¡œìš° í´ëŸ¬ìŠ¤í„°ë§ ìƒíƒœ
    };
}
// í¸ì˜ë¥¼ ìœ„í•œ ë¡œì»¬ ì°¸ì¡° (ì¬ì„ ì–¸ ì•„ë‹˜)
const OrgChartState = window.OrgChartState;

// ELK ìŠ¤íƒ€ì¼ ì„¸ë¡œ ë ˆì´ì•„ì›ƒ ì„¤ì • (ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘)
const ELK_CONFIG = {
    algorithm: "layered",
    direction: "DOWN", // ì„¸ë¡œ ë ˆì´ì•„ì›ƒ ê³ ì •
    nodeNodeSpacing: 24, // Dense ëª¨ë“œ ê°„ê²©
    layerSpacing: 140, // ë ˆì´ì–´ ê°„ ê°„ê²©
    nodePlacement: "BRANDES_KOEPF", // ë…¸ë“œ ë°°ì¹˜ ì „ëµ
    portConstraints: "FIXED_SIDE",
    edgeRouting: "ORTHOGONAL",
    padding: 48
};

// ìƒìˆ˜ ì •ì˜ - ìŠˆí¼í´ë¡œë“œ ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘ ì ìš©
const CONFIG = {
    MAX_VISIBLE_SIBLINGS: 12, // ìµœëŒ€ í‘œì‹œ í˜•ì œ ë…¸ë“œ ìˆ˜ (ì´ˆê³¼ì‹œ ë²„í‚· ê·¸ë£¹í™”)
    
    // ì¹´ë“œ í­ ìŠ¬ë¦¼í™” - PDF ìŠ¤íƒ€ì¼ ì ìš©
    NODE_WIDTH: 180,           // Normal ëª¨ë“œ (ê°€ë¡œ í…ìŠ¤íŠ¸)
    NODE_WIDTH_DENSE: 30,       // Dense ëª¨ë“œ (ì„¸ë¡œ í…ìŠ¤íŠ¸ - PDF ìŠ¤íƒ€ì¼ ê·¹ì„¸)
    NODE_WIDTH_ULTRA: 25,       // Ultra ëª¨ë“œ (ì´ˆìŠ¬ë¦¼ ì„¸ë¡œ)
    
    NODE_HEIGHT: 100,          // ë…¸ë“œ ë†’ì´ (Normal)
    NODE_HEIGHT_DENSE: 40,     // Dense ëª¨ë“œ ë†’ì´ (PDF ìŠ¤íƒ€ì¼)
    NODE_HEIGHT_ULTRA: 40,     // Ultra ëª¨ë“œ ë†’ì´
    
    // ë ˆë²¨ ê°„ê²© - ê³„ì¸µ êµ¬ì¡° ëª…í™•íˆ
    LEVEL_SPACING: 150,
    LEVEL_SPACING_DENSE: 60,  // ë…¸ë“œ ë†’ì´ 40pxë³´ë‹¤ ì•½ê°„ í¼
    LEVEL_SPACING_ULTRA: 60,
    
    // í˜•ì œ ê°„ê²© - PDF ìŠ¤íƒ€ì¼ ìµœì†Œí™”
    SIBLING_SPACING: 30,        // Normal ëª¨ë“œ
    SIBLING_SPACING_DENSE: 8,   // Dense ëª¨ë“œ (PDF ìŠ¤íƒ€ì¼ - ìµœì†Œ ê°„ê²©)
    SIBLING_SPACING_ULTRA: 5,   // Ultra ëª¨ë“œ (ì´ˆìµœì†Œ ê°„ê²©)
    // í´ëŸ¬ìŠ¤í„° ê°„ê²© ì„¤ì • - ë¶€ì„œ ë‹¨ìœ„ êµ¬ë¶„ ê°•í™”
    GROUP_SPACING_MULTIPLIER: {
        SAME_PARENT: 1.0,      // ê°™ì€ ë¶€ì„œ ë‚´ íŒ€ (ì´˜ì´˜í•˜ê²Œ)
        SAME_GRANDPARENT: 5.0, // ë‹¤ë¥¸ ë¶€ì„œ (í¬ê²Œ ë„ì›€)
        DIFFERENT_ROOT: 10.0   // ë‹¤ë¥¸ ë³¸ë¶€ (ë” í¬ê²Œ)
    },
    
    // ì¤Œ ì„¤ì • - ì‹œë§¨í‹± ì „í™˜
    ZOOM_MIN: 30,
    ZOOM_MAX: 200,
    ZOOM_STEP: 10,
    ZOOM_ULTRA_THRESHOLD: 80,   // <80%: Ultra ëª¨ë“œ (72px)
    ZOOM_DENSE_THRESHOLD: 95,   // <95%: Dense ëª¨ë“œ (92px)
                                 // â‰¥95%: Normal ëª¨ë“œ (180px)
    SEARCH_DELAY: 300,
    ANIMATION_DURATION: 300,
    MAX_WIDTH_PER_LEVEL: 2400, // ë ˆë²¨ë‹¹ ìµœëŒ€ ë„ˆë¹„ ì¦ê°€
    MIN_SPACING_RATIO: 0.6, // ìµœì†Œ ê°„ê²© ë¹„ìœ¨ (ìì‹ì´ ë§ì„ ë•Œ)
    COLLISION_PADDING: 20, // ì¶©ëŒ ê°ì§€ ì—¬ë°±
    BUCKET_THRESHOLD: 12, // ë²„í‚· ê·¸ë£¹í™” ì„ê³„ê°’ (>12 í˜•ì œ)
    PADDING: 48, // íŒ¨ë”© - ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘
};

// í˜„ì¬ ë·° ëª¨ë“œ íŒë³„ - í•­ìƒ Dense ëª¨ë“œ ìœ ì§€
function getCurrentViewMode() {
    // ì¤Œ ë ˆë²¨ê³¼ ìƒê´€ì—†ì´ í•­ìƒ Dense ëª¨ë“œ (30px Ã— 100px)
    return 'dense';
}

// ëª¨ë“œë³„ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
function getModeConfig(mode) {
    switch(mode) {
        case 'ultra':
            return {
                width: CONFIG.NODE_WIDTH_ULTRA,
                height: CONFIG.NODE_HEIGHT_ULTRA,
                spacing: CONFIG.SIBLING_SPACING_ULTRA,
                levelSpacing: CONFIG.LEVEL_SPACING_ULTRA,
                isVertical: true
            };
        case 'dense':
            return {
                width: CONFIG.NODE_WIDTH_DENSE,
                height: CONFIG.NODE_HEIGHT_DENSE,
                spacing: CONFIG.SIBLING_SPACING_DENSE,
                levelSpacing: CONFIG.LEVEL_SPACING_DENSE,
                isVertical: true
            };
        default:
            return {
                width: CONFIG.NODE_WIDTH,
                height: CONFIG.NODE_HEIGHT,
                spacing: CONFIG.SIBLING_SPACING,
                levelSpacing: CONFIG.LEVEL_SPACING,
                isVertical: false
            };
    }
}

// ELK ìŠ¤íƒ€ì¼ ì„¸ë¡œ ë ˆì´ì•„ì›ƒ ê³„ì‚°ê¸° (ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘)
function computeVerticalLayout(graph, mode = "normal") {
    console.log(`ğŸ¯ Computing ELK-style vertical layout in ${mode} mode`);
    
    const config = getModeConfig(mode);
    const nodeWidth = config.width;
    const nodeHeight = config.height;
    const spacingX = config.spacing;
    
    // ELK ìŠ¤íƒ€ì¼ ë ˆì´ì•„ì›ƒ ì˜µì…˜ ì ìš©
    const layoutOptions = {
        algorithm: ELK_CONFIG.algorithm,
        direction: ELK_CONFIG.direction,
        nodeNodeSpacing: spacingX,
        layerSpacing: ELK_CONFIG.layerSpacing,
        nodePlacement: ELK_CONFIG.nodePlacement,
        padding: ELK_CONFIG.padding
    };
    
    console.log(`ELK Layout options:`, layoutOptions);
    console.log(`Node dimensions: ${nodeWidth}x${nodeHeight}, spacing: ${spacingX}px`);
    
    // í˜„ì¬ calculateLayout í•¨ìˆ˜ë¥¼ ELK ìŠ¤íƒ€ì¼ë¡œ í˜¸ì¶œ
    calculateLayout();
    
    return {
        nodes: Array.from(OrgChartState.nodes.values()).map(n => ({
            id: n.id,
            position: { x: n.x || 0, y: n.y || 0 },
            data: n,
            type: mode === "dense" ? "dense" : "tall"
        })),
        edges: OrgChartState.edges.map(e => ({
            id: `${e.source.id}-${e.target.id}`,
            source: e.source.id,
            target: e.target.id
        }))
    };
}

// ì¡°ì§ ë°ì´í„°ì—ì„œ ê·¸ë˜í”„ ìƒì„± (ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘)
function buildGraph(rows) {
    console.log('ğŸ—ï¸ Building organization graph from rows:', rows.length);
    
    const nodes = rows.map(r => ({
        id: r.id,
        type: "tall", // ê¸°ë³¸ ë…¸ë“œ íƒ€ì…
        data: {
            name: r.name,
            type: r.type || "company", // company|division|department|team|person
            headcount: r.headcount || 0,
            childrenCount: r.childrenCount || 0
        }
    }));
    
    const edges = rows
        .filter(r => r.parentId) // ë¶€ëª¨ê°€ ìˆëŠ” ë…¸ë“œë§Œ
        .map(r => ({
            id: `${r.parentId}-${r.id}`,
            source: r.parentId,
            target: r.id
        }));
    
    console.log(`Built graph: ${nodes.length} nodes, ${edges.length} edges`);
    return { nodes, edges };
}

// ê·¸ë˜í”„ ê²€ì¦ ìœ í‹¸ë¦¬í‹° - ì²´ì¸(ì§ë ¬) ì—£ì§€ ê²€ì¶œ (ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘)
function validateGraph(edges) {
    console.log('ğŸ” Validating graph structure...');
    
    const childCount = new Map();
    
    // ê° ë¶€ëª¨ì˜ ìì‹ ìˆ˜ ê³„ì‚°
    edges.forEach(e => {
        const sourceId = e.source && typeof e.source === 'object' ? e.source.id : e.source;
        const targetId = e.target && typeof e.target === 'object' ? e.target.id : e.target;
        
        if (sourceId) {
            childCount.set(sourceId, (childCount.get(sourceId) || 0) + 1);
        }
    });
    
    // ë¶€ëª¨ê°€ ê³„ì† 1ëª… ìì‹ë§Œ ê°€ì§€ëŠ” êµ¬ê°„ì€ ì²´ì¸ ì˜ì‹¬ (ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘)
    const singleChildParents = [...childCount.entries()]
        .filter(([parentId, count]) => count === 1)
        .map(([parentId]) => parentId);
    
    // ì²´ì¸ ê¸¸ì´ ë° ê±´ê°•ë„ í‰ê°€
    const chainLength = singleChildParents.length;
    const totalParents = childCount.size;
    const chainRatio = totalParents > 0 ? chainLength / totalParents : 0;
    
    // ê²½ê³  ì„ê³„ê°’ (ì‘ì—…ì§€ì‹œì„œ: ë£¨íŠ¸~ë³¸ë¶€ êµ¬ê°„ì—ì„œ ê¸¸ê²Œ ì´ì–´ì§€ì§€ ì•ŠìŒ)
    const hasLongChain = chainLength > 5; // 5ê°œ ì´ìƒ ì—°ì† ì²´ì¸ì€ êµ¬ì¡°ì  ë¬¸ì œ
    const hasHighChainRatio = chainRatio > 0.7; // 70% ì´ìƒì´ ë‹¨ì¼ ìì‹ì´ë©´ ë¬¸ì œ
    
    const isValid = !hasLongChain && !hasHighChainRatio;
    
    if (!isValid) {
        console.warn(`âš ï¸ Graph structure warning:`, {
            chainLength,
            chainRatio: (chainRatio * 100).toFixed(1) + '%',
            singleChildParents
        });
    } else {
        console.log(`âœ… Graph structure healthy: ${chainLength} single-child parents out of ${totalParents}`);
    }
    
    return { 
        singleChildParents,
        chainLength,
        chainRatio,
        hasLongChain,
        hasHighChainRatio,
        isValid,
        totalParents
    };
}

// ì´ˆê¸°í™”
document.addEventListener('DOMContentLoaded', function() {
    console.log('Advanced Org Chart: DOM loaded, initializing...');
    
    try {
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì™€ í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ë¨¼ì € ì„¤ì •
        setupEventListeners();
        setupKeyboardNavigation();
        
        // API ë°ì´í„° ë¡œë“œë¥¼ ì‹œë„í•˜ê³ , ì‹¤íŒ¨í•˜ë©´ ìƒ˜í”Œ ë°ì´í„° ì‚¬ìš©
        // ë°ì´í„° ë¡œë“œ í›„ ì°¨íŠ¸ ì´ˆê¸°í™”
        loadInitialData().then(() => {
            // ë°ì´í„° ë¡œë“œ ì„±ê³µ í›„ ì°¨íŠ¸ ì´ˆê¸°í™”
            initializeChart();
        }).catch((error) => {
            console.log('API failed, using sample data...', error);
            useSampleData();
            // ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ í›„ ì°¨íŠ¸ ì´ˆê¸°í™”
            initializeChart();
        });
    } catch (error) {
        console.error('Initialization error:', error);
        // ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ìƒ˜í”Œ ë°ì´í„°ë¡œ ë°±ì—…
        useSampleData();
        initializeChart();
    }
});

// ì°¨íŠ¸ ì´ˆê¸°í™”
function initializeChart() {
    // ì´ˆê¸° ë·° ì„¤ì • (vertical ëª¨ë“œë¡œ ë Œë”ë§)
    updateViewMode('vertical');
    
    // ë Œë”ë§ ì™„ë£Œ í›„ ì¤Œ ì ìš© (ë¹„ë™ê¸°)
    // ì´ˆê¸° ì¤Œì„ 30%ë¡œ ì„¤ì •í•˜ì—¬ Dense ëª¨ë“œ ê°•ì œ í™œì„±í™”
    console.log('ğŸ” ì¤Œ ì ìš© ì „ ìƒíƒœ í™•ì¸:', OrgChartState.zoomLevel);
    
    // Dense ëª¨ë“œë¡œ ì‹œì‘ (92% ì¤Œ - Dense ëª¨ë“œì˜ ìµœëŒ€ê°’)
    OrgChartState.zoomLevel = 92;
    document.getElementById('zoomLevel').textContent = '92%';
    
    // ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚° (Dense ëª¨ë“œ ì ìš©)
    calculateLayout();
    renderChart();
    
    // CSS ë³€í™˜ ì ìš© (ì‹œê°ì  ì¤Œ)
    const container = document.getElementById('treeContainer');
    container.style.transform = 'scale(0.3)';
    container.classList.add('dense-mode');
    
    console.log('ğŸ” ì¤Œ ì ìš© í›„ ìƒíƒœ í™•ì¸:', OrgChartState.zoomLevel);
    console.log('ğŸ¯ Dense ëª¨ë“œ ê°•ì œ í™œì„±í™”: 92px ì´ˆìŠ¬ë¦¼ ì¹´ë“œ');
    console.log('ğŸ’¡ ê³ ê¸‰ ì¡°ì§ë„ ì´ˆê¸°í™” ì™„ë£Œ - Dense ëª¨ë“œë¡œ ì‹œì‘'); // ì‹œê°„ì„ 500msë¡œ ì¦ê°€
}

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
function setupEventListeners() {
    console.log('Setting up event listeners...');
    
    // ë·° ëª¨ë“œ ë³€ê²½
    const viewModeBtns = document.querySelectorAll('.view-mode-btn');
    console.log(`Found ${viewModeBtns.length} view mode buttons`);
    viewModeBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            console.log('View mode clicked:', this.dataset.mode);
            const mode = this.dataset.mode;
            updateViewMode(mode);
        });
    });

    // ë ˆë²¨ í•„í„°
    const levelFilterBtns = document.querySelectorAll('.level-filter-btn');
    console.log(`Found ${levelFilterBtns.length} level filter buttons`);
    levelFilterBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            console.log('Level filter clicked:', this.dataset.level);
            const level = this.dataset.level;
            updateLevelFilter(level);
        });
    });

    // ê²€ìƒ‰
    const searchInput = document.getElementById('orgSearch');
    let searchTimeout;
    searchInput.addEventListener('input', function(e) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            performSearch(e.target.value);
        }, CONFIG.SEARCH_DELAY);
    });

    // ì¤Œ ì»¨íŠ¸ë¡¤
    document.getElementById('zoomIn').addEventListener('click', () => {
        updateZoom(Math.min(OrgChartState.zoomLevel + CONFIG.ZOOM_STEP, CONFIG.ZOOM_MAX));
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
        updateZoom(Math.max(OrgChartState.zoomLevel - CONFIG.ZOOM_STEP, CONFIG.ZOOM_MIN));
    });

    document.getElementById('zoomReset').addEventListener('click', () => {
        updateZoom(100);
    });

    // ë§ˆìš°ìŠ¤ íœ  ì¤Œ - ë¶€ë“œëŸ¬ìš´ ì „í™˜
    const chartViewport = document.getElementById('chartViewport');
    chartViewport.addEventListener('wheel', function(e) {
        if (e.ctrlKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -CONFIG.ZOOM_STEP : CONFIG.ZOOM_STEP;
            const newZoom = Math.max(CONFIG.ZOOM_MIN, Math.min(CONFIG.ZOOM_MAX, OrgChartState.zoomLevel + delta));
            
            // Dense ëª¨ë“œ ì „í™˜ ì„ê³„ê°’ ê·¼ì²˜ì—ì„œ ë¶€ë“œëŸ¬ìš´ ì „í™˜
            const wasInDenseMode = OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD;
            const willBeInDenseMode = newZoom < CONFIG.ZOOM_DENSE_THRESHOLD;
            
            if (wasInDenseMode !== willBeInDenseMode) {
                console.log(`Switching node mode: ${willBeInDenseMode ? 'Dense' : 'Normal'} at zoom ${newZoom}%`);
            }
            
            updateZoom(newZoom);
        }
    });
    
    // ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ - ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸
    chartViewport.addEventListener('scroll', function() {
        updateMinimap();
    });
    
    // ë¯¸ë‹ˆë§µ í´ë¦­ ì´ë²¤íŠ¸ - í´ë¦­í•œ ìœ„ì¹˜ë¡œ ì´ë™
    const minimapCanvas = document.getElementById('minimapCanvas');
    if (minimapCanvas) {
        minimapCanvas.addEventListener('click', function(e) {
            const rect = minimapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ë¯¸ë‹ˆë§µ ì¢Œí‘œë¥¼ ì‹¤ì œ ìŠ¤í¬ë¡¤ ìœ„ì¹˜ë¡œ ë³€í™˜
            const scale = Math.min(
                minimapCanvas.width / chartViewport.scrollWidth,
                minimapCanvas.height / chartViewport.scrollHeight
            );
            
            const scrollX = (x / scale) - (chartViewport.clientWidth / 2);
            const scrollY = (y / scale) - (chartViewport.clientHeight / 2);
            
            // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ì„¤ì •
            chartViewport.scrollLeft = Math.max(0, scrollX);
            chartViewport.scrollTop = Math.max(0, scrollY);
            
            // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸
            updateMinimap();
        });
        
        // ë¯¸ë‹ˆë§µ í˜¸ë²„ íš¨ê³¼
        minimapCanvas.style.cursor = 'pointer';
    }
}

// í‚¤ë³´ë“œ ë‚´ë¹„ê²Œì´ì…˜ ì„¤ì •
function setupKeyboardNavigation() {
    document.addEventListener('keydown', function(e) {
        if (OrgChartState.focusedNode) {
            const node = OrgChartState.nodes.get(OrgChartState.focusedNode);
            if (!node) return;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    navigateToSibling(node, -1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    navigateToSibling(node, 1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (node.hasChildren && !OrgChartState.expandedNodes.has(node.id)) {
                        toggleNode(node.id);
                    } else if (node.children && node.children.length > 0) {
                        focusNode(node.children[0]);
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (OrgChartState.expandedNodes.has(node.id)) {
                        toggleNode(node.id);
                    } else if (node.parentId) {
                        focusNode(node.parentId);
                    }
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (node.hasChildren) {
                        toggleNode(node.id);
                    }
                    break;
                case '/':
                    e.preventDefault();
                    document.getElementById('orgSearch').focus();
                    break;
            }
        }
    });
}

// ì´ˆê¸° ë°ì´í„° ë¡œë“œ
async function loadInitialData() {
    showLoading(true);
    
    try {
        // APIì—ì„œ ì´ˆê¸° ì „ì²´ ë°ì´í„° ë¡œë“œ (depth=20ìœ¼ë¡œ ëŠ˜ë ¤ì„œ ëª¨ë“  ì¡°ì§ ë¡œë“œ)
        const response = await fetch('/employees/api/org/root?depth=20');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        console.log('Loaded org data:', data); // ë””ë²„ê¹…ìš©
        
        // API ë°ì´í„° êµ¬ì¡° ë””ë²„ê¹…
        if (data) {
            const countNodes = (node) => {
                let count = 1;
                if (node.children && Array.isArray(node.children)) {
                    node.children.forEach(child => {
                        count += countNodes(child);
                    });
                }
                return count;
            };
            const totalNodes = countNodes(data);
            console.log(`ğŸ“Š Total nodes in API response: ${totalNodes}`);
        }
        
        // ë…¸ë“œ ìƒì„± ë° ë Œë”ë§ (ì´ˆê¸° ë¡œë“œ ì‹œ ë²„í‚· í´ëŸ¬ìŠ¤í„°ë§ ë¹„í™œì„±í™”)
        processOrgData(data, true);
        
        // ì´ˆê¸° ë¡œë“œ ì‹œ ëª¨ë“  ë…¸ë“œ ìë™ í™•ì¥ (ì „ì²´ ì¡°ì§ë„ í‘œì‹œ)
        console.log('Auto-expanding ALL nodes for API data...');
        console.log(`Total nodes loaded from API: ${OrgChartState.nodes.size}`);
        
        OrgChartState.nodes.forEach(node => {
            if (node.hasChildren) {  // ëª¨ë“  ìì‹ì´ ìˆëŠ” ë…¸ë“œë¥¼ í™•ì¥
                OrgChartState.expandedNodes.add(node.id);
                console.log(`Auto-expanded: ${node.name} (level ${node.level}, id: ${node.id})`);
            }
        });
        
        console.log(`Total expanded nodes: ${OrgChartState.expandedNodes.size}`);
        
        // ë ˆì´ì•„ì›ƒê³¼ ë Œë”ë§ì€ initializeChart()ì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ìƒëµ
        // calculateLayout();  
        // renderChart();
        
    } catch (error) {
        console.error('Failed to load organization data:', error);
        showError('ì¡°ì§ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    } finally {
        showLoading(false);
    }
}

// ì¡°ì§ ë°ì´í„° ì²˜ë¦¬ (ë²„í‚· í´ëŸ¬ìŠ¤í„°ë§ ì ìš©)
function processOrgData(data, skipBucketing = false) {
    // í˜•ì œ ë…¸ë“œ ë²„í‚· ì²˜ë¦¬ í•¨ìˆ˜
    function bucketSiblings(children, parentId, level) {
        if (!children || children.length === 0) return [];
        
        // ì´ˆê¸° ë¡œë“œ ì‹œì—ëŠ” ë²„í‚· í´ëŸ¬ìŠ¤í„°ë§ ë¹„í™œì„±í™”
        if (skipBucketing) {
            return children;
        }
        
        // BUCKET_THRESHOLDë¥¼ ì´ˆê³¼í•˜ë©´ ë²„í‚· ê·¸ë£¹í™”
        if (children.length > CONFIG.BUCKET_THRESHOLD) {
            const visibleChildren = children.slice(0, CONFIG.BUCKET_THRESHOLD);
            const hiddenChildren = children.slice(CONFIG.BUCKET_THRESHOLD);
            const hiddenCount = hiddenChildren.length;
            
            // í´ëŸ¬ìŠ¤í„° ID ìƒì„±
            const clusterId = `${parentId}-bucket-${Date.now()}`;
            
            // ìˆ¨ê²¨ì§„ ë…¸ë“œë“¤ ì €ì¥
            OrgChartState.clusteredSiblings.set(clusterId, hiddenChildren);
            
            // ë²„í‚· ë…¸ë“œ ìƒì„±
            const bucketNode = {
                id: clusterId,
                name: `+${hiddenCount} ë”ë³´ê¸°`,
                type: 'bucket',
                parentId: parentId,
                level: level,
                isCluster: true,
                hiddenChildren: hiddenChildren,
                hasChildren: false,
            };
            
            return [...visibleChildren, bucketNode];
        }
        
        return children;
    }
    
    // ì¬ê·€ì ìœ¼ë¡œ ë…¸ë“œ ì²˜ë¦¬
    function processNode(node, parentId = null, level = 0) {
        const processedNode = {
            ...node,
            parentId,
            level,
            // x, y ì¢Œí‘œëŠ” calculateLayoutì—ì„œ ê³„ì‚°ë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ
        };
        
        OrgChartState.nodes.set(node.id, processedNode);
        
        if (node.children && node.children.length > 0) {
            // ë²„í‚· í´ëŸ¬ìŠ¤í„°ë§ ì ìš©
            const bucketedChildren = bucketSiblings(node.children, node.id, level + 1);
            
            bucketedChildren.forEach(child => {
                if (child.isCluster) {
                    // ë²„í‚· ë…¸ë“œ ì²˜ë¦¬
                    OrgChartState.nodes.set(child.id, child);
                } else {
                    // ì¼ë°˜ ë…¸ë“œ ì²˜ë¦¬
                    processNode(child, node.id, level + 1);
                }
            });
        }
    }
    
    processNode(data);
    // calculateLayout()ì€ í˜¸ì¶œí•˜ëŠ” ê³³ì—ì„œ ì²˜ë¦¬
}

// íŠ¸ë¦¬ êµ¬ì¡° ê¸°ë°˜ ì¬ê·€ì  ë ˆì´ì•„ì›ƒ ê³„ì‚° (ë¶€ëª¨-ìì‹ ê´€ê³„ ìš°ì„ )
function calculateLayout() {
    console.log(`ğŸ“ calculateLayout() called. Total nodes: ${OrgChartState.nodes.size}`);
    
    // Dense ëª¨ë“œ íŒë³„
    const isDenseMode = OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD || 
                       OrgChartState.currentView === 'compact';
    
    console.log(`ğŸ“ Layout mode: ${isDenseMode ? 'Dense' : 'Normal'} (zoom: ${OrgChartState.zoomLevel}%)`);
    
    const nodeWidth = isDenseMode ? CONFIG.NODE_WIDTH_DENSE : CONFIG.NODE_WIDTH;
    const nodeHeight = isDenseMode ? CONFIG.NODE_HEIGHT_DENSE : CONFIG.NODE_HEIGHT;  
    const siblingSpacing = isDenseMode ? CONFIG.SIBLING_SPACING_DENSE : CONFIG.SIBLING_SPACING;
    
    // ëª¨ë“  ë…¸ë“œì˜ x, y ì¢Œí‘œ ì´ˆê¸°í™”
    OrgChartState.nodes.forEach(node => {
        node.x = undefined;
        node.y = undefined;
        node.width = nodeWidth;
        node.height = nodeHeight;
    });
    
    console.log('ğŸŒ² Starting tree-based recursive layout calculation');
    
    // íŠ¸ë¦¬ êµ¬ì¡° ë¹Œë“œ - ë¶€ëª¨-ìì‹ ê´€ê³„ ë§¤í•‘
    const childrenMap = new Map();
    const visibleNodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    
    visibleNodes.forEach(node => {
        if (node.parentId) {
            if (!childrenMap.has(node.parentId)) {
                childrenMap.set(node.parentId, []);
            }
            childrenMap.get(node.parentId).push(node);
        }
    });
    
    // ê° ë¶€ëª¨ì˜ ìì‹ë“¤ì„ ì´ë¦„ìˆœìœ¼ë¡œ ì •ë ¬
    childrenMap.forEach(children => {
        children.sort((a, b) => a.name.localeCompare(b.name));
    });
    
    // ì¬ê·€ì ìœ¼ë¡œ ì„œë¸ŒíŠ¸ë¦¬ í¬ê¸° ê³„ì‚° (bottom-up)
    function calculateSubtreeWidth(node) {
        const children = childrenMap.get(node.id) || [];
        
        if (children.length === 0) {
            // ë¦¬í”„ ë…¸ë“œ
            node.subtreeWidth = nodeWidth;
            return nodeWidth;
        }
        
        // ìì‹ë“¤ì˜ ì„œë¸ŒíŠ¸ë¦¬ ë„ˆë¹„ í•©ì‚°
        let totalChildrenWidth = 0;
        children.forEach((child, index) => {
            const childWidth = calculateSubtreeWidth(child);
            totalChildrenWidth += childWidth;
            if (index < children.length - 1) {
                totalChildrenWidth += siblingSpacing;
            }
        });
        
        // ë…¸ë“œ ìì²´ ë„ˆë¹„ì™€ ìì‹ë“¤ ë„ˆë¹„ ì¤‘ í° ê°’ ì„ íƒ
        node.subtreeWidth = Math.max(nodeWidth, totalChildrenWidth);
        return node.subtreeWidth;
    }
    
    // ì¬ê·€ì ìœ¼ë¡œ ìœ„ì¹˜ í• ë‹¹ (top-down) - ê³„ì¸µ ê¸°ë°˜ ì ì‘í˜• ê°„ê²© ì ìš©
    function assignPositions(node, x, y, parentNode = null, grandparentNode = null) {
        // ë…¸ë“œ ìœ„ì¹˜ ì„¤ì •
        node.x = x;
        node.y = y;
        
        const children = childrenMap.get(node.id) || [];
        if (children.length === 0) return;
        
        // ìì‹ë“¤ì„ ìœ„í•œ Y ìœ„ì¹˜
        const childY = y + nodeHeight + CONFIG.LEVEL_SPACING;
        
        if (children.length === 1) {
            // ìì‹ì´ í•˜ë‚˜ë©´ ë¶€ëª¨ ë°”ë¡œ ì•„ë˜ ì¤‘ì•™ì—
            assignPositions(children[0], x, childY, node, parentNode);
        } else {
            // ì—¬ëŸ¬ ìì‹ì„ ë¶€ëª¨ ì¤‘ì‹¬ìœ¼ë¡œ ë°°ì¹˜
            let currentX = x - node.subtreeWidth / 2;
            
            children.forEach((child, index) => {
                // ê³„ì¸µ ê¸°ë°˜ ê°„ê²© ê³„ì‚°
                let spacing = siblingSpacing;
                
                if (index > 0) {
                    const prevChild = children[index - 1];
                    
                    // ë…¸ë“œ íƒ€ì…ì— ë”°ë¥¸ ê°„ê²© ì¡°ì •
                    // type: 'division' (ë³¸ë¶€), 'department' (ë¶€ì„œ), 'team' (íŒ€)
                    
                    // Case 1: ë³¸ë¶€ ë ˆë²¨ì—ì„œ ë‹¤ë¥¸ ë³¸ë¶€ë“¤ ê°„ì˜ ê°„ê²©
                    if (node.type === 'company' && child.type === 'division') {
                        // ë³¸ë¶€ë“¤ ê°„ì˜ ê°„ê²©ì„ ë„“ê²Œ
                        spacing = siblingSpacing * CONFIG.GROUP_SPACING_MULTIPLIER.DIFFERENT_ROOT;
                    }
                    // Case 2: ê°™ì€ ë³¸ë¶€ ë‚´ì—ì„œ ë¶€ì„œë“¤ ê°„ì˜ ê°„ê²©
                    else if (node.type === 'division' && child.type === 'department') {
                        // ê°™ì€ ë³¸ë¶€ ë‚´ ë¶€ì„œë“¤ì€ ê¸°ë³¸ ê°„ê²©
                        spacing = siblingSpacing * CONFIG.GROUP_SPACING_MULTIPLIER.SAME_PARENT;
                    }
                    // Case 3: ë¶€ì„œ ë ˆë²¨ì—ì„œ ë‹¤ë¥¸ ë³¸ë¶€ì˜ ë¶€ì„œë“¤ê³¼ êµ¬ë¶„
                    else if (parentNode && parentNode.type === 'division') {
                        // í˜•ì œ ë…¸ë“œë“¤ì˜ ë¶€ëª¨(ë³¸ë¶€)ê°€ ë‹¤ë¥¸ì§€ í™•ì¸
                        const prevChildChildren = childrenMap.get(prevChild.id) || [];
                        const currentChildChildren = childrenMap.get(child.id) || [];
                        
                        // ë¶€ì„œ ê·¸ë£¹ ê°„ êµ¬ë¶„ì„ ìœ„í•´ ê°„ê²© ì¦ê°€
                        if (prevChildChildren.length > 0 || currentChildChildren.length > 0) {
                            spacing = siblingSpacing * CONFIG.GROUP_SPACING_MULTIPLIER.SAME_GRANDPARENT;
                        }
                    }
                    // Case 4: íŒ€ ë ˆë²¨ì—ì„œì˜ ê°„ê²©
                    else if (node.type === 'department' && child.type === 'team') {
                        // ê°™ì€ ë¶€ì„œ ë‚´ íŒ€ë“¤ì€ ì¢ì€ ê°„ê²©
                        spacing = siblingSpacing * CONFIG.GROUP_SPACING_MULTIPLIER.SAME_PARENT;
                    }
                    
                    // ì¶”ê°€: í•˜ìœ„ ë…¸ë“œê°€ ë§ì€ ê²½ìš° ê°„ê²© ìë™ ì¡°ì •
                    const prevChildCount = (childrenMap.get(prevChild.id) || []).length;
                    const currentChildCount = (childrenMap.get(child.id) || []).length;
                    
                    // ìì‹ì´ ë§ì€ ë…¸ë“œë“¤ ì‚¬ì´ëŠ” ê°„ê²© ì¦ê°€
                    if (prevChildCount > 3 || currentChildCount > 3) {
                        spacing *= 1.2;
                    }
                }
                
                // ìì‹ì˜ ì„œë¸ŒíŠ¸ë¦¬ ì¤‘ì‹¬ì— ìì‹ ë…¸ë“œ ë°°ì¹˜
                const childCenterX = currentX + child.subtreeWidth / 2;
                assignPositions(child, childCenterX, childY, node, parentNode);
                
                // ë‹¤ìŒ ìì‹ì„ ìœ„í•œ X ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                currentX += child.subtreeWidth;
                if (index < children.length - 1) {
                    currentX += spacing;
                }
            });
        }
    }
    
    // í—¬í¼ í•¨ìˆ˜: íŠ¹ì • ê¹Šì´ê¹Œì§€ì˜ ëª¨ë“  ìì† ë…¸ë“œ ê°€ì ¸ì˜¤ê¸°
    function getAllDescendants(node, maxDepth, currentDepth = 0) {
        if (currentDepth >= maxDepth) return [];
        
        const children = childrenMap.get(node.id) || [];
        let descendants = [...children];
        
        children.forEach(child => {
            descendants = descendants.concat(getAllDescendants(child, maxDepth, currentDepth + 1));
        });
        
        return descendants;
    }
    
    // ë£¨íŠ¸ ë…¸ë“œë“¤ ì°¾ê¸°
    const rootNodes = visibleNodes.filter(n => !n.parentId);
    
    if (rootNodes.length === 0) {
        console.warn('No root nodes found');
        return;
    }
    
    // ê° ë£¨íŠ¸ ë…¸ë“œì— ëŒ€í•´ ë ˆì´ì•„ì›ƒ ê³„ì‚°
    let currentRootX = 0;
    rootNodes.forEach((root, index) => {
        // ì„œë¸ŒíŠ¸ë¦¬ ë„ˆë¹„ ê³„ì‚°
        calculateSubtreeWidth(root);
        
        // ìœ„ì¹˜ í• ë‹¹
        const rootX = currentRootX + root.subtreeWidth / 2;
        assignPositions(root, rootX, 50);
        
        // ë‹¤ìŒ ë£¨íŠ¸ë¥¼ ìœ„í•œ X ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        currentRootX += root.subtreeWidth + siblingSpacing * 2;
        
        console.log(`âœ… Root ${root.name}: positioned at (${rootX}, 50), subtree width: ${root.subtreeWidth}`);
    });
    
    // ë¶€ëª¨ ìœ„ì¹˜ ì¬ì¡°ì • - ìì‹ë“¤ì˜ ì¤‘ì•™ì— ì˜¤ë„ë¡
    function adjustParentPosition(node) {
        const children = childrenMap.get(node.id) || [];
        
        if (children.length > 1) {
            // ìì‹ë“¤ì˜ í‰ê·  X ìœ„ì¹˜ ê³„ì‚°
            let sumX = 0;
            children.forEach(child => {
                adjustParentPosition(child); // ë¨¼ì € ìì‹ë“¤ ì¡°ì •
                sumX += child.x;
            });
            
            // ë¶€ëª¨ë¥¼ ìì‹ë“¤ì˜ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
            const avgX = sumX / children.length;
            node.x = avgX;
            console.log(`ğŸ“ Adjusted ${node.name} to center of children at x=${avgX}`);
        } else if (children.length === 1) {
            // ìì‹ì´ í•˜ë‚˜ë©´ ì¬ê·€ í˜¸ì¶œë§Œ
            adjustParentPosition(children[0]);
        }
    }
    
    // ë£¨íŠ¸ë¶€í„° ë¶€ëª¨ ìœ„ì¹˜ ì¬ì¡°ì •
    rootNodes.forEach(root => {
        adjustParentPosition(root);
    });
    
    // ë””ë²„ê¹… ì •ë³´ ì¶œë ¥
    console.log('ğŸ¯ Layout calculation complete. Node positions:');
    visibleNodes.forEach(node => {
        const children = childrenMap.get(node.id) || [];
        console.log(`  ${node.name}: (${node.x?.toFixed(0)}, ${node.y}) - ${children.length} children`);
    });
    
    // ì—£ì§€ ìƒì„±
    OrgChartState.edges = [];
    visibleNodes.forEach(node => {
        if (node.parentId) {
            const parent = OrgChartState.nodes.get(node.parentId);
            if (parent && shouldRenderNode(parent)) {
                OrgChartState.edges.push({
                    source: parent,
                    target: node,
                    type: node.x === parent.x ? 'straight' : 'orthogonal'
                });
            }
        }
    });
    
    console.log(`ğŸ“Š Created ${OrgChartState.edges.length} edges`);
}

// ì°¨íŠ¸ ë Œë”ë§
function renderChart() {
    console.log('Rendering chart. Current view:', OrgChartState.currentView, 'Current level:', OrgChartState.currentLevel);
    
    const container = document.getElementById('treeContainer');
    if (!container) {
        console.error('Tree container not found!');
        return;
    }
    
    container.innerHTML = '';
    
    // ë Œë”ë§í•  ë…¸ë“œ ìˆ˜ í™•ì¸
    const visibleNodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    console.log(`Rendering ${visibleNodes.length} visible nodes out of ${OrgChartState.nodes.size} total nodes`);
    
    // ë””ë²„ê¹…: ë³´ì´ì§€ ì•ŠëŠ” ë…¸ë“œ í™•ì¸
    if (visibleNodes.length < OrgChartState.nodes.size) {
        const hiddenNodes = Array.from(OrgChartState.nodes.values()).filter(n => !shouldRenderNode(n));
        console.log('Hidden nodes:', hiddenNodes.map(n => `${n.name} (parent: ${n.parentId})`));
    }
    
    // ë·° ëª¨ë“œì— ë”°ë¥¸ íŠ¹í™”ëœ ë Œë”ë§
    if (OrgChartState.currentView === 'grid') {
        renderGridView();
    } else if (OrgChartState.currentView === 'radial') {
        renderRadialView();
    } else if (OrgChartState.currentView === 'compact') {
        renderCompactView();
    } else {
        // ê¸°ë³¸ ì„¸ë¡œí˜• ë·°
        renderVerticalView();
    }
    
    // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸ (ë Œë”ë§ ì™„ë£Œ í›„)
    setTimeout(() => {
        updateMinimap();
    }, 100);
}

// ì„¸ë¡œí˜• ë·° ë Œë”ë§
function renderVerticalView() {
    const container = document.getElementById('treeContainer');
    const viewport = document.getElementById('chartViewport');
    const viewportWidth = viewport.offsetWidth;
    
    console.log(`renderVerticalView - Viewport width: ${viewportWidth}, Container found: ${!!container}`);
    
    // ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ í™•ì¸
    if (container) {
        console.log('Container styles:', {
            position: window.getComputedStyle(container).position,
            display: window.getComputedStyle(container).display,
            visibility: window.getComputedStyle(container).visibility,
            opacity: window.getComputedStyle(container).opacity,
            overflow: window.getComputedStyle(container).overflow,
            zIndex: window.getComputedStyle(container).zIndex
        });
    }
    
    // í˜„ì¬ ëª¨ë“œ - í•­ìƒ Dense
    const currentMode = 'dense';  // í•­ìƒ Dense ëª¨ë“œ
    const modeConfig = getModeConfig('dense');
    const nodeWidth = CONFIG.NODE_WIDTH_DENSE;
    const nodeHeight = CONFIG.NODE_HEIGHT_DENSE;
    const isDenseMode = true;
    const isUltraMode = false;
    
    console.log(`Current mode: ${currentMode}, Zoom: ${OrgChartState.zoomLevel}%, Node width: ${nodeWidth}`);
    
    // ì»¨í…Œì´ë„ˆ ìµœì†Œ í¬ê¸° ì„¤ì •
    let minX = 0, maxX = 0, maxY = 0;
    
    // ë…¸ë“œ ìœ„ì¹˜ ë²”ìœ„ ê³„ì‚°
    OrgChartState.nodes.forEach(node => {
        if (shouldRenderNode(node)) {
            minX = Math.min(minX, node.x);
            maxX = Math.max(maxX, node.x);
            maxY = Math.max(maxY, node.y);
        }
    });
    
    // ì»¨í…Œì´ë„ˆ í¬ê¸° ì„¤ì •
    const containerWidth = Math.max(viewportWidth, (maxX - minX) + nodeWidth + 400);
    const containerHeight = maxY + nodeHeight + 200;
    
    container.style.width = `${containerWidth}px`;
    container.style.height = `${containerHeight}px`;
    
    console.log(`Container size set to: ${containerWidth} x ${containerHeight}px`);
    console.log(`Node position range: X(${minX} to ${maxX}), Y(0 to ${maxY})`);
    
    // ì™¼ìª½ ì—¬ë°±ì„ ê³ ë ¤í•œ ì˜¤í”„ì…‹ (ì¤‘ì•™ì´ ì•„ë‹Œ ì™¼ìª½ ê¸°ì¤€)
    const offsetX = Math.abs(minX) + 200; // minXê°€ ìŒìˆ˜ì¼ ë•Œë¥¼ ê³ ë ¤
    
    // ë…¸ë“œ ë Œë”ë§ (ëª¨ë“œë³„ ë¶„ê¸°)
    let renderedCount = 0;
    OrgChartState.nodes.forEach(node => {
        if (shouldRenderNode(node)) {
            // í•­ìƒ Dense ëª¨ë“œ ë…¸ë“œ ìƒì„±
            console.log(`Rendering node ${node.name}, Creating Dense mode node`);
            let nodeElement = createDenseNodeElement(node);
            
            const leftPos = offsetX + node.x - nodeWidth / 2;
            const topPos = node.y + 50;
            
            nodeElement.style.left = `${leftPos}px`;
            nodeElement.style.top = `${topPos}px`; // ìƒë‹¨ ì—¬ë°±
            
            // ë””ë²„ê¹…: ë…¸ë“œ ìŠ¤íƒ€ì¼ í™•ì¸
            if (renderedCount === 0) {
                console.log('First node element styles:', {
                    position: nodeElement.style.position,
                    left: nodeElement.style.left,
                    top: nodeElement.style.top,
                    width: nodeElement.style.width || nodeElement.offsetWidth,
                    height: nodeElement.style.height || nodeElement.offsetHeight,
                    className: nodeElement.className,
                    id: nodeElement.id,
                    innerHTML: nodeElement.innerHTML.substring(0, 100) + '...'
                });
                
                // ì‹¤ì œ ê³„ì‚°ëœ ìŠ¤íƒ€ì¼ë„ í™•ì¸
                setTimeout(() => {
                    const elem = document.getElementById(nodeElement.id);
                    if (elem) {
                        const computed = window.getComputedStyle(elem);
                        const rect = elem.getBoundingClientRect();
                        console.log('First node computed styles:', {
                            display: computed.display,
                            visibility: computed.visibility,
                            opacity: computed.opacity,
                            position: computed.position,
                            zIndex: computed.zIndex,
                            width: computed.width,
                            height: computed.height,
                            backgroundColor: computed.backgroundColor,
                            border: computed.border
                        });
                        console.log('First node bounding rect:', rect);
                        console.log('Is visible in viewport?', rect.width > 0 && rect.height > 0);
                    }
                }, 100);
            }
            
            container.appendChild(nodeElement);
            
            // ì‹¤ì œ ë Œë”ë§ëœ í¬ê¸° í™•ì¸
            setTimeout(() => {
                const elem = document.getElementById(nodeElement.id);
                if (elem && renderedCount <= 3) {
                    const rect = elem.getBoundingClientRect();
                    const style = window.getComputedStyle(elem);
                    console.log(`Node ${node.name} actual size:`, {
                        width: rect.width,
                        height: rect.height,
                        computedWidth: style.width,
                        computedHeight: style.height,
                        className: elem.className
                    });
                }
            }, 10);
            
            renderedCount++;
            if (renderedCount <= 5) { // ì²˜ìŒ 5ê°œ ë…¸ë“œë§Œ ë¡œê·¸
                console.log(`Rendered node ${node.name} at (${leftPos}, ${topPos}), isDense: ${isDenseMode}, element exists: ${!!document.getElementById(nodeElement.id)}`);
            }
        }
    });
    console.log(`Total nodes rendered to DOM: ${renderedCount}`);
    console.log(`Container children count: ${container.children.length}`);
    console.log(`Container dimensions: ${container.style.width} x ${container.style.height}`);
    
    // ì—£ì§€ ë Œë”ë§
    OrgChartState.edges.forEach(edge => {
        if (shouldRenderEdge(edge)) {
            const edgeElement = createEdgeElement(edge, offsetX);
            container.appendChild(edgeElement);
        }
    });
    
    // ì´ˆê¸° ì¤Œ ì„¤ì • - íŒ€ ë ˆë²¨ì¼ ë•Œ ìë™ ì¶•ì†Œ
    if (OrgChartState.currentLevel === 'team') {
        updateZoom(50); // 50% ë¡œ ìë™ ì¶•ì†Œ
    }
}

// ê·¸ë¦¬ë“œ ë·° ë Œë”ë§
function renderGridView() {
    const container = document.getElementById('treeContainer');
    const nodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    const cols = 4;
    
    nodes.forEach((node, index) => {
        const row = Math.floor(index / cols);
        const col = index % cols;
        const nodeElement = createGridNodeElement(node);
        nodeElement.style.left = `${col * 250 + 50}px`;
        nodeElement.style.top = `${row * 180 + 50}px`;
        container.appendChild(nodeElement);
    });
}

// ë°©ì‚¬í˜• ë·° ë Œë”ë§
function renderRadialView() {
    const container = document.getElementById('treeContainer');
    const viewportWidth = document.getElementById('chartViewport').offsetWidth;
    const viewportHeight = document.getElementById('chartViewport').offsetHeight;
    const centerX = viewportWidth / 2;
    const centerY = viewportHeight / 2;
    
    // ì¤‘ì•™ì— ë£¨íŠ¸ ë…¸ë“œ
    const rootNode = OrgChartState.nodes.get('root');
    if (rootNode && shouldRenderNode(rootNode)) {
        const rootElement = createDenseNodeElement(rootNode);  // í•­ìƒ Dense
        rootElement.style.left = `${centerX - CONFIG.NODE_WIDTH / 2}px`;
        rootElement.style.top = `${centerY - CONFIG.NODE_HEIGHT / 2}px`;
        container.appendChild(rootElement);
        
        // ìì‹ ë…¸ë“œë“¤ì„ ì›í˜•ìœ¼ë¡œ ë°°ì¹˜
        const children = Array.from(OrgChartState.nodes.values())
            .filter(n => n.parentId === 'root' && shouldRenderNode(n));
        
        const angleStep = (2 * Math.PI) / children.length;
        const radius = 250;
        
        children.forEach((child, index) => {
            const angle = index * angleStep - Math.PI / 2;
            const x = centerX + radius * Math.cos(angle) - CONFIG.NODE_WIDTH / 2;
            const y = centerY + radius * Math.sin(angle) - CONFIG.NODE_HEIGHT / 2;
            
            const childElement = createDenseNodeElement(child);  // í•­ìƒ Dense
            childElement.style.left = `${x}px`;
            childElement.style.top = `${y}px`;
            container.appendChild(childElement);
        });
    }
}

// ì»´íŒ©íŠ¸ ë·° ë Œë”ë§
function renderCompactView() {
    const container = document.getElementById('treeContainer');
    const nodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    
    let y = 20;
    nodes.forEach(node => {
        const nodeElement = createCompactNodeElement(node);
        nodeElement.style.left = `20px`;
        nodeElement.style.top = `${y}px`;
        nodeElement.style.width = 'calc(100% - 40px)';
        container.appendChild(nodeElement);
        y += 50;
    });
}

// ë…¸ë“œ ë Œë”ë§ ì—¬ë¶€ í™•ì¸
function shouldRenderNode(node) {
    // ë””ë²„ê¹…: ë…¸ë“œ ì •ë³´ ì¶œë ¥
    if (!node) {
        console.error('shouldRenderNode: node is undefined');
        return false;
    }
    
    // ë ˆë²¨ í•„í„°ê°€ í™œì„±í™”ëœ ê²½ìš° ë¨¼ì € í™•ì¸
    if (OrgChartState.currentLevel !== 'all') {
        
        let shouldShow = false;
        switch(OrgChartState.currentLevel) {
            case 'executive':
                // ì„ì›ê¸‰ë§Œ í‘œì‹œ (íšŒì‚¬, ë³¸ë¶€)
                shouldShow = node.type === 'company' || node.type === 'division';
                break;
            case 'division':
                // ë³¸ë¶€ê¸‰ê¹Œì§€ë§Œ í‘œì‹œ
                shouldShow = node.type === 'company' || node.type === 'division';
                break;
            case 'department':
                // ë¶€ì„œê¸‰ê¹Œì§€ í‘œì‹œ
                shouldShow = node.type === 'company' || node.type === 'division' || node.type === 'department';
                break;
            case 'team':
                // íŒ€ê¸‰ê¹Œì§€ í‘œì‹œ - ëª¨ë“  ìƒìœ„ ì¡°ì§ í¬í•¨
                shouldShow = true; // ëª¨ë“  ë…¸ë“œë¥¼ í‘œì‹œ
                break;
            default:
                shouldShow = true;
        }
        
        // console.log(`Node ${node.name} - Level Filter Show: ${shouldShow}`);
        
        // ë ˆë²¨ í•„í„°ì—ì„œ ë³´ì—¬ì•¼ í•˜ëŠ” ë…¸ë“œë©´ ë¶€ëª¨ ì²´ì¸ë„ ìë™ í™•ì¥
        if (shouldShow) {
            ensureParentChainExpanded(node);
            return true;
        } else {
            return false;
        }
    }
    
    // Progressive Disclosure: í¼ì³ì§„ ë¶€ëª¨ì˜ ìì‹ë§Œ í‘œì‹œ
    // ì´ˆê¸° ë¡œë“œ ì‹œì—ëŠ” ëª¨ë“  ë…¸ë“œê°€ í™•ì¥ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ëª¨ë“  ë…¸ë“œë¥¼ í‘œì‹œ
    if (node.parentId) {
        const parent = OrgChartState.nodes.get(node.parentId);
        if (!parent) {
            console.log(`Node ${node.name} hidden - parent ${node.parentId} not found`);
            return false;
        }
        
        // ìƒìœ„ ë…¸ë“œê°€ í™•ì¥ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ìˆ¨ê¹€
        // ì´ˆê¸° ë¡œë“œ ì‹œ ëª¨ë“  ë…¸ë“œê°€ í™•ì¥ë˜ë¯€ë¡œ ì´ ì¡°ê±´ì€ ëŒ€ë¶€ë¶„ í†µê³¼í•¨
        if (!OrgChartState.expandedNodes.has(node.parentId)) {
            // console.log(`Node ${node.name} hidden - parent ${node.parentId} not expanded`);
            return false;
        }
    }
    
    // ë·°í¬íŠ¸ ê¸°ë°˜ ë™ì  ê²½ê³„ ì²´í¬ (ì¤Œ ë ˆë²¨ê³¼ ë·°í¬íŠ¸ í¬ê¸° ê³ ë ¤)
    if (node.x !== undefined && node.y !== undefined) {
        const viewport = document.getElementById('chartViewport');
        if (viewport) {
            const viewportWidth = viewport.clientWidth || 1200;
            const isDenseMode = OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD;
            
            // ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ íš¨ê³¼ì ì¸ ë·°í¬íŠ¸ í¬ê¸° ê³„ì‚°
            const zoomFactor = OrgChartState.zoomLevel / 100;
            const effectiveViewportWidth = viewportWidth / zoomFactor;
            
            // Dense ëª¨ë“œì—ì„œëŠ” ë” ë§ì€ ë…¸ë“œë¥¼ í‘œì‹œí•˜ê¸° ìœ„í•´ ë§¤ìš° ê´€ëŒ€í•œ ê²½ê³„ ì ìš©
            if (isDenseMode) {
                // Dense ëª¨ë“œ: ëª¨ë“  84ê°œ ë…¸ë“œë¥¼ ìˆ˜ìš©í•  ìˆ˜ ìˆë„ë¡ ì¶©ë¶„íˆ í° ê²½ê³„ ì„¤ì •
                // 92px ì¹´ë“œë¡œ 100ê°œê¹Œì§€ í—ˆìš© (ì•½ 11600px)
                const maxAllowableX = 100 * (CONFIG.NODE_WIDTH_DENSE + 24); // ~11600px
                
                if (Math.abs(node.x) > maxAllowableX) {
                    console.log(`Dense mode: Node ${node.name} filtered out - x=${node.x} exceeds ${maxAllowableX}`);
                    return false;
                }
            } else {
                // Normal ëª¨ë“œ: ë§¤ìš° ê´€ëŒ€í•œ ê²½ê³„ ì ìš© (10ë°° ë·°í¬íŠ¸ ë„ˆë¹„)
                const maxNormalX = Math.max(effectiveViewportWidth * 10, 15000); // 10x viewport width or 15000px minimum
                if (Math.abs(node.x) > maxNormalX || node.y > 10000) {
                    console.log(`Normal mode: Node ${node.name} filtered out - x=${node.x}, y=${node.y} (max: ${maxNormalX})`);
                    return false;
                }
            }
        }
    }
    
    return true;
}

// ë¶€ëª¨ ì²´ì¸ì„ ìë™ìœ¼ë¡œ í™•ì¥
function ensureParentChainExpanded(node) {
    let currentNode = node;
    const nodesToExpand = [];
    
    // ë£¨íŠ¸ê¹Œì§€ ë¶€ëª¨ ì²´ì¸ì„ ì¶”ì 
    while (currentNode.parentId) {
        const parent = OrgChartState.nodes.get(currentNode.parentId);
        if (parent) {
            nodesToExpand.push(parent.id);
            currentNode = parent;
        } else {
            break;
        }
    }
    
    // ëª¨ë“  ë¶€ëª¨ ë…¸ë“œë¥¼ í™•ì¥ëœ ìƒíƒœë¡œ ì„¤ì •
    nodesToExpand.forEach(nodeId => {
        OrgChartState.expandedNodes.add(nodeId);
        console.log(`Auto-expanded parent node: ${nodeId}`);
    });
}

// ì—£ì§€ ë Œë”ë§ ì—¬ë¶€ í™•ì¸
function shouldRenderEdge(edge) {
    return shouldRenderNode(edge.source) && shouldRenderNode(edge.target);
}

// ê·¸ë¦¬ë“œ ë·°ìš© ë…¸ë“œ ì—˜ë¦¬ë¨¼íŠ¸
function createGridNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node grid-node';
    div.id = `node-grid-${node.id}`;
    
    const badgeClass = `node-type-badge ${node.type}`;
    div.innerHTML = `
        <div class="node-header">
            <span class="${badgeClass}">${getNodeTypeLabel(node.type)}</span>
        </div>
        <div class="node-content">
            <div class="node-name">${node.name}</div>
            <div class="node-stats">
                <div class="node-stat">
                    <i class="fas fa-users node-stat-icon"></i>
                    <span>${node.headcount || 0}ëª…</span>
                </div>
            </div>
        </div>
    `;
    
    div.addEventListener('click', () => focusNode(node.id));
    return div;
}

// ì»´íŒ©íŠ¸ ë·°ìš© ë…¸ë“œ ì—˜ë¦¬ë¨¼íŠ¸
function createCompactNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node compact-node';
    div.id = `node-compact-${node.id}`;
    div.style.cssText = 'display: flex; align-items: center; padding: 0.5rem 1rem; min-width: auto;';
    
    div.innerHTML = `
        <span class="node-type-badge ${node.type}" style="margin-right: 1rem;">${getNodeTypeLabel(node.type)}</span>
        <span style="flex: 1; color: white; font-weight: 500;">${node.name}</span>
        <span style="color: #94a3b8; font-size: 0.875rem;">${node.headcount || 0}ëª…</span>
    `;
    
    div.addEventListener('click', () => focusNode(node.id));
    return div;
}

// DenseTallNode ì—˜ë¦¬ë¨¼íŠ¸ ìƒì„± (ì´ˆìŠ¬ë¦¼ ì„¸ë¡œ ì¹´ë“œ)
// Ultra ëª¨ë“œ ë…¸ë“œ ìƒì„± - 72px ì´ˆìŠ¬ë¦¼ (ì‘ì—…ì§€ì‹œì„œ ì‚¬ì–‘)
function createUltraNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node ultra-node';
    div.id = `node-${node.id}`;
    div.setAttribute('role', 'treeitem');
    div.setAttribute('aria-expanded', OrgChartState.expandedNodes.has(node.id));
    div.setAttribute('aria-level', node.level);
    div.tabIndex = 0;
    
    if (node.id === OrgChartState.focusedNode) {
        div.classList.add('focused');
    }
    
    // Ultra ëª¨ë“œ - 25px ì´ˆìŠ¬ë¦¼ ì¹´ë“œ (PDF ìŠ¤íƒ€ì¼)
    div.style.cssText = `
        position: absolute;
        width: ${CONFIG.NODE_WIDTH_ULTRA}px !important;
        height: ${CONFIG.NODE_HEIGHT_ULTRA}px !important;
        padding: 1px !important;
        background: white !important;
        border: 1px solid #000 !important;
        border-radius: 0px !important;
        cursor: pointer;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box !important;
    `;
    
    // Ultra ëª¨ë“œ ì½˜í…ì¸  - ê·¹ë„ë¡œ ê°„ì†Œí™”
    const headcount = node.headcount || 0;
    const childrenCount = node.childrenCount || 0;
    
    // PDF ìŠ¤íƒ€ì¼ - ì‹¬í”Œí•œ ì„¸ë¡œì“°ê¸°
    div.innerHTML = `
        <div style="
            writing-mode: vertical-rl !important;
            text-orientation: upright !important;
            font-size: 8px !important;
            font-weight: 600 !important;
            color: black !important;
            line-height: 1 !important;
            text-align: center !important;
            white-space: nowrap !important;
            background: transparent !important;
        ">${node.name}</div>`;
    
    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    div.addEventListener('click', () => focusNode(node.id));
    
    const toggleBtn = div.querySelector('.node-toggle');
    if (toggleBtn) {
        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleNode(node.id);
        });
    }
    
    return div;
}

// Dense ëª¨ë“œ ë…¸ë“œ ìƒì„± - 30px Ã— 60px ìŠ¬ë¦¼
function createDenseNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node dense-node';
    div.id = `node-${node.id}`;
    div.setAttribute('role', 'treeitem');
    div.setAttribute('aria-expanded', OrgChartState.expandedNodes.has(node.id));
    div.setAttribute('aria-level', node.level);
    div.tabIndex = 0;
    
    if (node.id === OrgChartState.focusedNode) {
        div.classList.add('focused');
    }
    
    if (!OrgChartState.expandedNodes.has(node.id) && node.hasChildren) {
        div.classList.add('collapsed');
    }
    
    // Dense ëª¨ë“œì—ì„œëŠ” 30px x 40px ì¹´ë“œë¡œ ê³ ì • (PDF ìŠ¤íƒ€ì¼)
    const nodeWidth = 30;
    const nodeHeight = 40;
    console.log(`Creating dense node: ${node.name}, size: ${nodeWidth}x${nodeHeight}`);
    
    div.style.cssText = `
        position: absolute;
        width: ${nodeWidth}px !important;
        height: ${nodeHeight}px !important;
        padding: 1px !important;
        background: white !important;
        color: black !important;
        border: 1px solid #000 !important;
        border-radius: 0px !important;
        cursor: pointer;
        z-index: ${node.type === 'company' ? '100' : '10'};
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box !important;
    `;
    
    // ë²„í‚· ë…¸ë“œ íŠ¹ë³„ ì²˜ë¦¬
    if (node.isCluster || node.type === 'bucket') {
        // í´ëŸ¬ìŠ¤í„°ëŠ” PDF ìŠ¤íƒ€ì¼ ì‘ì€ í¬ê¸°
        div.style.width = '35px';
        div.style.height = '35px';
        div.style.background = '#ddd';
        div.innerHTML = `
            <div style="
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: #666;
                font-size: 9px;
                cursor: pointer;
                writing-mode: vertical-rl;
                text-orientation: mixed;
            ">${node.name}</div>
        `;
        div.addEventListener('click', () => expandCluster(node.id));
    } else {
        // DenseTallNode ì½˜í…ì¸  (ì„¸ë¡œ ê¸€ì)
        const headcount = node.headcount || 0;
        const childrenCount = node.childrenCount || 0;
        const typeColor = {
            'company': 'from-cyan-500',
            'division': 'from-fuchsia-500',
            'department': 'from-teal-500',
            'team': 'from-slate-500',
            'person': 'from-amber-500'
        }[node.type] || 'from-cyan-500';
        
        // PDF ìŠ¤íƒ€ì¼ - ì‹¬í”Œí•œ ì„¸ë¡œì“°ê¸° í…ìŠ¤íŠ¸ë§Œ í‘œì‹œ
        div.innerHTML = `
            <div style="
                writing-mode: vertical-rl !important;
                text-orientation: upright !important;
                font-size: 9px !important;
                font-weight: 600 !important;
                color: black !important;
                line-height: 1 !important;
                text-align: center !important;
                width: 100% !important;
                height: 100% !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                white-space: nowrap !important;
                background: transparent !important;
            ">${node.name}</div>
        `;
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        div.addEventListener('click', () => focusNode(node.id));
        
        const toggleBtn = div.querySelector('.node-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleNode(node.id);
            });
        }
    }
    
    return div;
}

// TallNode ì—˜ë¦¬ë¨¼íŠ¸ ìƒì„± - í•­ìƒ Dense ëª¨ë“œë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
function createNodeElement(node) {
    // í•­ìƒ Dense ë…¸ë“œë¥¼ ë°˜í™˜
    return createDenseNodeElement(node);
}

// ì•„ë˜ëŠ” ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì½”ë“œ (ì£¼ì„ ì²˜ë¦¬)
/*
function createNodeElement_old(node) {
    if (node.id === OrgChartState.focusedNode) {
        div.classList.add('focused');
    }
    
    if (!OrgChartState.expandedNodes.has(node.id) && node.hasChildren) {
        div.classList.add('collapsed');
    }
    
    // ë²„í‚· ë…¸ë“œ íŠ¹ë³„ ì²˜ë¦¬
    if (node.isCluster || node.type === 'bucket') {
        div.style.cssText = 'position: absolute; width: 120px; height: 80px; min-height: 80px;';
        div.innerHTML = `
            <div style="
                width: 100%;
                height: 100%;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(0, 212, 255, 0.4);
                border-radius: 0.75rem;
                display: flex;
                align-items: center;
                justify-content: center;
                color: #00d4ff;
                font-size: 0.875rem;
                cursor: pointer;
                transition: all 0.3s ease;
            " onmouseover="this.style.borderColor='#00d4ff'; this.style.background='rgba(0, 212, 255, 0.1)'"
               onmouseout="this.style.borderColor='rgba(0, 212, 255, 0.4)'; this.style.background='rgba(255, 255, 255, 0.05)'">
                ${node.name}
            </div>
        `;
        div.addEventListener('click', () => expandCluster(node.id));
    } else {
        // TallNode ì½˜í…ì¸  (ì¼ë°˜ ê°€ë¡œ ê¸€ì ë…¸ë“œ) - 180px í­
        const headcount = node.headcount || 0;
        const childrenCount = node.childrenCount || 0;
        const badges = node.badges || [];
        
        // position: absoluteë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •
        div.style.position = 'absolute';
        
        div.innerHTML = `
            <!-- ì™¼ìª½ ì„¸ë¡œ spine (íƒ€ì… í‘œì‹œ) -->
            <div class="node-spine ${node.type}"></div>
            
            <!-- ë…¸ë“œ ì½˜í…ì¸  (ê°€ë¡œ ê¸€ì) -->
            <div class="node-content">
                <!-- í—¤ë” ì„¹ì…˜ -->
                <div class="node-header">
                    <span class="node-type-badge">
                        <i class="fas ${getNodeIcon(node.type)}"></i>
                        ${getNodeTypeLabel(node.type)}
                    </span>
                </div>
                
                <!-- ì´ë¦„ (3ì¤„ í´ë¨í”„) -->
                <div class="node-name">${node.name}</div>
                
                <!-- ì§ê¸‰/íƒ€ì´í‹€ (2ì¤„ í´ë¨í”„) -->
                ${node.title ? `<div class="node-title">${node.title}</div>` : ''}
                
                <!-- í†µê³„ ê·¸ë¦¬ë“œ - í–¥ìƒëœ ë””ìì¸ -->
                <div class="node-stats">
                    <div class="node-stat">
                        <div class="stat-label">ì¸ì›</div>
                        <div class="stat-value">${headcount.toLocaleString()}</div>
                    </div>
                    <div class="node-stat">
                        <div class="stat-label">í•˜ìœ„</div>
                        <div class="stat-value">${childrenCount.toLocaleString()}</div>
                    </div>
                </div>
                
                <!-- ë°°ì§€ (ìµœëŒ€ 3ê°œ í‘œì‹œ) -->
                ${badges.length > 0 ? `
                    <div class="node-badges">
                        ${badges.slice(0, 3).map(badge => 
                            `<span class="node-badge">${badge}</span>`
                        ).join('')}
                        ${badges.length > 3 ? 
                            `<span class="node-badge">+${badges.length - 3}</span>` : ''
                        }
                    </div>
                ` : ''}
                
                <!-- ì ‘íŒ ìƒíƒœì—ì„œ í•˜ìœ„ ì¡°ì§ ì •ë³´ -->
                ${!OrgChartState.expandedNodes.has(node.id) && node.hasChildren ? `
                    <div class="node-children-info" style="
                        margin-top: 0.5rem;
                        padding-top: 0.5rem;
                        border-top: 1px solid rgba(0, 212, 255, 0.1);
                        font-size: 0.813rem;
                        color: #00d4ff;
                    ">
                        <i class="fas fa-chevron-down"></i> ${childrenCount}ê°œ í•˜ìœ„ ì¡°ì§
                    </div>
                ` : ''}
            </div>
            
            <!-- ì ‘ê¸°/í¼ì¹˜ê¸° ë²„íŠ¼ -->
            ${node.hasChildren ? `
                <button class="node-toggle" aria-label="${OrgChartState.expandedNodes.has(node.id) ? 'ì ‘ê¸°' : 'í¼ì¹˜ê¸°'}">
                    <i class="fas fa-chevron-${OrgChartState.expandedNodes.has(node.id) ? 'up' : 'down'}"></i>
                </button>
            ` : ''}
        `;
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        div.addEventListener('click', () => focusNode(node.id));
        
        const toggleBtn = div.querySelector('.node-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleNode(node.id);
            });
        }
    }
    
    return div;
}
*/

// ì—£ì§€ ì—˜ë¦¬ë¨¼íŠ¸ ìƒì„± (ì§ê° ì—°ê²°ì„  ì§€ì›)
function createEdgeElement(edge, offsetX) {
    const container = document.createElement('div');
    container.className = 'edge-container';
    container.style.position = 'absolute';
    container.style.pointerEvents = 'none';
    
    // Dense ëª¨ë“œ íŒë³„
    const isDenseMode = OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD || 
                        OrgChartState.currentView === 'compact';
    const nodeHeight = isDenseMode ? CONFIG.NODE_HEIGHT_DENSE : CONFIG.NODE_HEIGHT;
    const nodeWidth = isDenseMode ? CONFIG.NODE_WIDTH_DENSE : CONFIG.NODE_WIDTH;
    
    // ë…¸ë“œ ì¤‘ì•™ì—ì„œ ì—°ê²°ë˜ë„ë¡ ìˆ˜ì • (offsetX ì ìš©)
    const sourceX = offsetX + edge.source.x;
    const sourceY = edge.source.y + nodeHeight; // ë…¸ë“œ í•˜ë‹¨
    const targetX = offsetX + edge.target.x;
    const targetY = edge.target.y; // ë…¸ë“œ ìƒë‹¨
    
    if (edge.type === 'orthogonal' && sourceX !== targetX) {
        // ì§ê° ì—°ê²°ì„  (ã„±ì í˜•íƒœ)
        const midY = sourceY + (targetY - sourceY) / 2;
        
        // ìˆ˜ì§ì„  1 (ë¶€ëª¨ì—ì„œ ì•„ë˜ë¡œ)
        const vLine1 = document.createElement('div');
        vLine1.className = 'org-edge';
        vLine1.style.left = `${sourceX - 1}px`;
        vLine1.style.top = `${sourceY}px`;
        vLine1.style.height = `${midY - sourceY}px`;
        vLine1.style.width = '2px';
        container.appendChild(vLine1);
        
        // ìˆ˜í‰ì„  (ì¢Œìš° ì—°ê²°)
        const hLine = document.createElement('div');
        hLine.className = 'org-edge horizontal';
        hLine.style.left = `${Math.min(sourceX, targetX)}px`;
        hLine.style.top = `${midY - 1}px`;
        hLine.style.width = `${Math.abs(targetX - sourceX)}px`;
        hLine.style.height = '2px';
        container.appendChild(hLine);
        
        // ìˆ˜ì§ì„  2 (ìì‹ìœ¼ë¡œ ì—°ê²°)
        const vLine2 = document.createElement('div');
        vLine2.className = 'org-edge';
        vLine2.style.left = `${targetX - 1}px`;
        vLine2.style.top = `${midY}px`;
        vLine2.style.height = `${targetY - midY}px`;
        vLine2.style.width = '2px';
        container.appendChild(vLine2);
    } else {
        // ì¼ì§ì„  ì—°ê²° (ë¶€ëª¨ì™€ ìì‹ì´ ê°™ì€ X ìœ„ì¹˜)
        const vLine = document.createElement('div');
        vLine.className = 'org-edge';
        vLine.style.left = `${sourceX - 1}px`;
        vLine.style.top = `${sourceY}px`;
        vLine.style.height = `${targetY - sourceY}px`;
        vLine.style.width = '2px';
        container.appendChild(vLine);
    }
    
    return container;
}

// ë…¸ë“œ íƒ€ì… ë ˆì´ë¸”
function getNodeTypeLabel(type) {
    const labels = {
        'company': 'ê·¸ë£¹',
        'group': 'ê·¸ë£¹',
        'subsidiary': 'ê³„ì—´ì‚¬',
        'division': 'ë³¸ë¶€',
        'department': 'ë¶€ì„œ',
        'team': 'íŒ€',
        'person': 'ì§ì›',
    };
    return labels[type] || type;
}

// ë…¸ë“œ íƒ€ì…ë³„ ì•„ì´ì½˜ ê°€ì ¸ì˜¤ê¸°
function getNodeIcon(type) {
    const icons = {
        'company': 'fa-building',
        'group': 'fa-sitemap',
        'subsidiary': 'fa-city',
        'division': 'fa-landmark',
        'department': 'fa-briefcase',
        'team': 'fa-users',
        'person': 'fa-user',
        'bucket': 'fa-layer-group'
    };
    return icons[type] || 'fa-folder';
}

// ë…¸ë“œ í† ê¸€
async function toggleNode(nodeId) {
    const node = OrgChartState.nodes.get(nodeId);
    if (!node || !node.hasChildren) return;
    
    if (OrgChartState.expandedNodes.has(nodeId)) {
        // ì ‘ê¸°
        OrgChartState.expandedNodes.delete(nodeId);
        console.log(`Collapsed node: ${nodeId}`);
    } else {
        // í¼ì¹˜ê¸°
        OrgChartState.expandedNodes.add(nodeId);
        console.log(`Expanded node: ${nodeId}`);
        
        // Lazy Load: ìì‹ì´ ì—†ìœ¼ë©´ ì„œë²„ì—ì„œ ë¡œë“œ
        if (!node.children || node.children.length === 0) {
            await loadNodeChildren(nodeId);
        }
    }
    
    // ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚° í•„ìˆ˜ (íŠ¹íˆ íŒ€ ë ˆë²¨)
    calculateLayout();
    renderChart();
}

// ë…¸ë“œ ìì‹ ë¡œë“œ (Lazy Loading)
async function loadNodeChildren(nodeId, depth = 1) {
    try {
        const response = await fetch(`/employees/api/org/node/${nodeId}?depth=${depth}`);
        
        // ì‘ë‹µ ìƒíƒœ í™•ì¸
        if (!response.ok) {
            console.error(`HTTP Error: ${response.status} ${response.statusText}`);
            return;
        }
        
        const data = await response.json();
        
        // ì—ëŸ¬ ì‘ë‹µ í™•ì¸
        if (data.error) {
            console.error('API Error:', data.error);
            return;
        }
        
        const node = OrgChartState.nodes.get(nodeId);
        if (node && data.children) {
            node.children = data.children;
            
            // ìì‹ ë…¸ë“œë§Œ ì²˜ë¦¬ (ë¶€ëª¨ ë…¸ë“œëŠ” ì´ë¯¸ ì¡´ì¬í•˜ë¯€ë¡œ ë‹¤ì‹œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ)
            data.children.forEach(child => {
                const childNode = {
                    ...child,
                    parentId: nodeId,  // ë¶€ëª¨ IDë¥¼ ëª…í™•íˆ ì„¤ì •
                    level: node.level + 1,
                    // x, y ì¢Œí‘œëŠ” calculateLayoutì—ì„œ ê³„ì‚°
                };
                OrgChartState.nodes.set(child.id, childNode);
                
                // ìì‹ì˜ ìì‹ë“¤ë„ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬
                if (child.children && child.children.length > 0) {
                    function processChildrenRecursive(children, parentId, level) {
                        children.forEach(c => {
                            const processedChild = {
                                ...c,
                                parentId: parentId,
                                level: level,
                            };
                            OrgChartState.nodes.set(c.id, processedChild);
                            
                            if (c.children) {
                                processChildrenRecursive(c.children, c.id, level + 1);
                            }
                        });
                    }
                    processChildrenRecursive(child.children, child.id, node.level + 2);
                }
            });
            
            calculateLayout();
            renderChart();
            console.log(`Successfully loaded ${data.children.length} children for node ${nodeId} with depth ${depth}`);
        } else {
            console.log(`No children found for node ${nodeId}`);
        }
    } catch (error) {
        console.error('Failed to load node children:', error);
        console.error('Node ID:', nodeId);
    }
}

// íŠ¹ì • ê¹Šì´ê¹Œì§€ ë…¸ë“œ í™•ì¥ (expandToDepth) - í ê¸°ë°˜ BFS ìµœì í™”
async function expandToDepth(rootId, targetDepth = 3) {
    console.log(`ğŸ”„ Expanding node ${rootId} to depth ${targetDepth} - Dense mode test`);
    
    showLoading(true);
    
    // BFS í ë°©ì‹ìœ¼ë¡œ ìµœì í™”
    const queue = [{ id: rootId, depth: 0 }];
    const seen = new Set([rootId]);
    const pagesToLoad = [];
    
    while (queue.length > 0) {
        const { id, depth } = queue.shift();
        
        if (depth >= targetDepth) continue;
        
        const node = OrgChartState.nodes.get(id);
        if (!node) continue;
        
        // ë…¸ë“œ í™•ì¥ ìƒíƒœ ì„¤ì •
        if (node.hasChildren) {
            OrgChartState.expandedNodes.add(id);
        }
        
        // ìì‹ì´ ì—†ìœ¼ë©´ ë¡œë“œ ì˜ˆì•½
        if (node.hasChildren && (!node.children || node.children.length === 0)) {
            pagesToLoad.push({ id, depth });
        }
        
        // ì´ë¯¸ ë¡œë“œëœ ìì‹ë“¤ì„ íì— ì¶”ê°€
        OrgChartState.nodes.forEach(childNode => {
            if (childNode.parentId === id && !seen.has(childNode.id)) {
                seen.add(childNode.id);
                queue.push({ id: childNode.id, depth: depth + 1 });
            }
        });
    }
    
    // ë³‘ë ¬ë¡œ í•„ìš”í•œ ë…¸ë“œë“¤ ë¡œë“œ
    if (pagesToLoad.length > 0) {
        const loadPromises = pagesToLoad.map(({ id }) => loadNodeChildren(id, 1));
        await Promise.all(loadPromises);
        
        // ë¡œë“œëœ ë…¸ë“œë“¤ë„ í™•ì¥ ìƒíƒœë¡œ ì„¤ì •
        pagesToLoad.forEach(({ id, depth }) => {
            if (depth < targetDepth - 1) {
                const node = OrgChartState.nodes.get(id);
                if (node && node.children) {
                    // ìƒˆë¡œ ë¡œë“œëœ ìì‹ë“¤ë„ í™•ì¥
                    OrgChartState.nodes.forEach(childNode => {
                        if (childNode.parentId === id && childNode.hasChildren) {
                            OrgChartState.expandedNodes.add(childNode.id);
                        }
                    });
                }
            }
        });
    }
    
    showLoading(false);
    
    // í™•ì¥ í›„ ìƒíƒœ ì²´í¬
    console.log(`ğŸ“Š Current zoom: ${OrgChartState.zoomLevel}% (Dense mode: ${OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD})`);
    
    // í™•ì¥ í›„ Dense ëª¨ë“œ ê°•ì œ í™•ì¸ (ì´ˆìŠ¬ë¦¼ ì¹´ë“œ í…ŒìŠ¤íŠ¸ìš©)
    if (OrgChartState.zoomLevel >= CONFIG.ZOOM_DENSE_THRESHOLD) {
        console.log('ğŸ”¥ Forcing Dense mode for ultra-slim cards verification');
        updateZoom(80); // Dense ëª¨ë“œ ê°•ì œ í™œì„±í™”
        return; // updateZoomì—ì„œ ì´ë¯¸ ë Œë”ë§ë¨
    }
    
    // ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚° ë° ë Œë”ë§
    calculateLayout();
    
    // ê·¸ë˜í”„ ê²€ì¦
    const validation = validateGraph(OrgChartState.edges);
    if (!validation.isValid) {
        console.warn('Graph validation issues detected:', validation);
    }
    
    renderChart();
}

// ë…¸ë“œ í¬ì»¤ìŠ¤
function focusNode(nodeId) {
    OrgChartState.focusedNode = nodeId;
    
    // ëª¨ë“  ë…¸ë“œì—ì„œ í¬ì»¤ìŠ¤ í´ë˜ìŠ¤ ì œê±°
    document.querySelectorAll('.org-node').forEach(el => {
        el.classList.remove('focused');
    });
    
    // ìƒˆ ë…¸ë“œì— í¬ì»¤ìŠ¤ í´ë˜ìŠ¤ ì¶”ê°€
    const nodeElement = document.getElementById(`node-${nodeId}`);
    if (nodeElement) {
        nodeElement.classList.add('focused');
        nodeElement.focus();
        
        // ë¸Œë ˆë“œí¬ëŸ¼ ì—…ë°ì´íŠ¸
        updateBreadcrumb(nodeId);
        
        // í¬ì»¤ìŠ¤ ê²½ë¡œ í¼ì¹˜ê¸°
        expandPath(nodeId);
        
        // ìŠ¤í¬ë¡¤ ì¡°ì •
        nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

// ê²½ë¡œ í¼ì¹˜ê¸° (í¬ì»¤ìŠ¤ëœ ë…¸ë“œê¹Œì§€)
function expandPath(nodeId) {
    const node = OrgChartState.nodes.get(nodeId);
    if (!node) return;
    
    const path = [];
    let current = node;
    while (current) {
        path.unshift(current.id);
        current = current.parentId ? OrgChartState.nodes.get(current.parentId) : null;
    }
    
    // ê²½ë¡œìƒì˜ ëª¨ë“  ë…¸ë“œ í¼ì¹˜ê¸°
    path.forEach(id => {
        if (!OrgChartState.expandedNodes.has(id)) {
            const n = OrgChartState.nodes.get(id);
            if (n && n.hasChildren) {
                OrgChartState.expandedNodes.add(id);
            }
        }
    });
    
    renderChart();
}

// ë¸Œë ˆë“œí¬ëŸ¼ ì—…ë°ì´íŠ¸
function updateBreadcrumb(nodeId) {
    const breadcrumb = document.getElementById('breadcrumbNav');
    const node = OrgChartState.nodes.get(nodeId);
    if (!node) return;
    
    const path = [];
    let current = node;
    while (current) {
        path.unshift(current);
        current = current.parentId ? OrgChartState.nodes.get(current.parentId) : null;
    }
    
    breadcrumb.innerHTML = path.map((n, index) => `
        <span class="breadcrumb-item ${index === path.length - 1 ? 'active' : ''}" 
              onclick="focusNode('${n.id}')">
            ${n.name}
        </span>
        ${index < path.length - 1 ? '<span class="breadcrumb-separator">â€º</span>' : ''}
    `).join('');
}

// í˜•ì œ ë…¸ë“œ íƒìƒ‰
function navigateToSibling(node, direction) {
    if (!node.parentId) return;
    
    const parent = OrgChartState.nodes.get(node.parentId);
    if (!parent || !parent.children) return;
    
    const currentIndex = parent.children.findIndex(c => c.id === node.id);
    if (currentIndex === -1) return;
    
    const newIndex = currentIndex + direction;
    if (newIndex >= 0 && newIndex < parent.children.length) {
        focusNode(parent.children[newIndex].id);
    }
}

// ê²€ìƒ‰ ìˆ˜í–‰
async function performSearch(query) {
    OrgChartState.searchQuery = query;
    
    if (!query || query.length < 2) {
        document.getElementById('searchAutocomplete').classList.remove('active');
        return;
    }
    
    try {
        const response = await fetch(`/employees/api/org/search?q=${encodeURIComponent(query)}`);
        const results = await response.json();
        
        showSearchResults(results);
    } catch (error) {
        console.error('Search failed:', error);
    }
}

// ê²€ìƒ‰ ê²°ê³¼ í‘œì‹œ
function showSearchResults(data) {
    const autocomplete = document.getElementById('searchAutocomplete');
    
    // API ì‘ë‹µì—ì„œ results ë°°ì—´ ì¶”ì¶œ
    const results = data.results || data;
    
    if (!results || results.length === 0) {
        autocomplete.classList.remove('active');
        return;
    }
    
    autocomplete.innerHTML = results.slice(0, 10).map(result => `
        <div class="autocomplete-item" onclick="selectSearchResult('${result.id}')">
            <div class="autocomplete-item-name">${result.name}</div>
            <div class="autocomplete-item-path">${result.path.join(' â€º ')}</div>
        </div>
    `).join('');
    
    autocomplete.classList.add('active');
}

// ê²€ìƒ‰ ê²°ê³¼ ì„ íƒ
function selectSearchResult(nodeId) {
    document.getElementById('searchAutocomplete').classList.remove('active');
    document.getElementById('orgSearch').value = '';
    
    // ê²½ë¡œ í¼ì¹˜ê³  í¬ì»¤ìŠ¤
    expandPath(nodeId);
    focusNode(nodeId);
}

// ë·° ëª¨ë“œ ë³€ê²½
function updateViewMode(mode) {
    console.log('Updating view mode to:', mode);
    OrgChartState.currentView = mode;
    
    // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    document.querySelectorAll('.view-mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    
    // ë·°ì— ë”°ë¥¸ ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚°
    if (mode === 'vertical') {
        calculateLayout();
    } else if (mode === 'radial') {
        calculateRadialLayout();
    } else if (mode === 'grid') {
        calculateGridLayout();
    } else if (mode === 'compact') {
        calculateCompactLayout();
    }
    
    console.log('Rendering chart with view mode:', mode);
    renderChart();
}

// ë ˆë²¨ í•„í„° ì—…ë°ì´íŠ¸
function updateLevelFilter(level) {
    console.log('Updating level filter to:', level);
    OrgChartState.currentLevel = level;
    
    // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    document.querySelectorAll('.level-filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.level === level);
    });
    
    // ë ˆë²¨ í•„í„° ë³€ê²½ ì‹œ expandedNodes ì´ˆê¸°í™”í•˜ê³  í•„ìš”í•œ ë…¸ë“œë“¤ë§Œ í™•ì¥
    if (level !== 'all') {
        OrgChartState.expandedNodes.clear();
        console.log('Cleared expandedNodes for level filtering');
        
        // í•„í„°ì— ë§ëŠ” ëª¨ë“  ë…¸ë“œë“¤ì˜ ë¶€ëª¨ ì²´ì¸ì„ ë¯¸ë¦¬ í™•ì¥
        OrgChartState.nodes.forEach(node => {
            let shouldShow = false;
            switch(level) {
                case 'executive':
                    shouldShow = node.type === 'company' || node.type === 'division';
                    break;
                case 'division':
                    shouldShow = node.type === 'company' || node.type === 'division';
                    break;
                case 'department':
                    shouldShow = node.type === 'company' || node.type === 'division' || node.type === 'department';
                    break;
                case 'team':
                    shouldShow = node.type !== 'person';
                    break;
            }
            
            if (shouldShow) {
                ensureParentChainExpanded(node);
            }
        });
    } else {
        // 'all' ë ˆë²¨ì¸ ê²½ìš° ë£¨íŠ¸ ë…¸ë“œë§Œ í™•ì¥ëœ ìƒíƒœë¡œ ì´ˆê¸°í™”
        OrgChartState.expandedNodes.clear();
        OrgChartState.expandedNodes.add('OKê¸ˆìœµê·¸ë£¹');
        console.log('Reset to default Progressive Disclosure mode');
    }
    
    console.log('Current state after level filter update:', OrgChartState.currentLevel);
    console.log('Expanded nodes:', Array.from(OrgChartState.expandedNodes));
    
    // ë ˆë²¨ì— ë”°ë¥¸ ìë™ ì¤Œ ì¡°ì • (Dense ëª¨ë“œ í™œì„±í™”ë¥¼ ìœ„í•´ 95% ë¯¸ë§Œìœ¼ë¡œ ì„¤ì •)
    let autoZoom = 80;
    switch(level) {
        case 'executive':
            autoZoom = 90;   // ì„ì›ê¸‰ì€ 90% (Dense ëª¨ë“œ)
            break;
        case 'division':
            autoZoom = 85;   // ë³¸ë¶€ê¸‰ì€ 85% (Dense ëª¨ë“œ)
            break;
        case 'department':
            autoZoom = 70;   // ë¶€ì„œê¸‰ì€ 70% (Dense ëª¨ë“œ)
            break;
        case 'team':
            autoZoom = 50;   // íŒ€ê¸‰ì€ 50%ë¡œ ì¶•ì†Œ (Dense ëª¨ë“œ)
            break;
        default:
            autoZoom = 80;   // ì „ì²´ëŠ” 80% (Dense ëª¨ë“œ)
    }
    
    updateZoom(autoZoom);
    renderChart();
}

// ì¤Œ ì—…ë°ì´íŠ¸
function updateZoom(level) {
    console.log(`ğŸ” Updating zoom from ${OrgChartState.zoomLevel}% to ${level}%`);
    
    const previousLevel = OrgChartState.zoomLevel;
    OrgChartState.zoomLevel = level;
    document.getElementById('zoomLevel').textContent = `${level}%`;
    
    // ëª¨ë“œ ì „í™˜ ì—†ì´ í•­ìƒ Dense ëª¨ë“œ ìœ ì§€ (30px Ã— 100px)
    console.log(`ğŸ¯ Keeping Dense mode at zoom ${level}%`);
    // ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚° ì—†ì´ ë…¸ë“œ í¬ê¸° ìœ ì§€
    
    const container = document.getElementById('treeContainer');
    container.style.transform = `scale(${level / 100})`;
    
    // ì‹œë§¨í‹± ì¤Œ í´ë˜ìŠ¤ ì ìš©
    container.classList.remove('zoom-small', 'zoom-large', 'dense-mode');
    if (level < 80) {
        container.classList.add('zoom-small');
    } else if (level > 120) {
        container.classList.add('zoom-large');
    }
    
    // Dense ëª¨ë“œ ë§ˆì»¤ í´ë˜ìŠ¤ ì¶”ê°€ (í•­ìƒ Dense ëª¨ë“œ)
    container.classList.add('dense-mode');
    console.log(`ğŸ¯ Dense mode maintained: Using ${CONFIG.NODE_WIDTH_DENSE}px wide cards`);
    
    // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸
    updateMinimap();
}

// ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateMinimap() {
    const canvas = document.getElementById('minimapCanvas');
    const chartViewport = document.getElementById('chartViewport');
    const treeContainer = document.getElementById('treeContainer');
    
    if (!canvas || !chartViewport || !treeContainer) return;
    
    const ctx = canvas.getContext('2d');
    
    // ìº”ë²„ìŠ¤ í´ë¦¬ì–´
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ë°°ê²½
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ë…¸ë“œë“¤ ì°¾ê¸°
    const nodes = document.querySelectorAll('.org-node, .dense-node');
    if (nodes.length === 0) return;
    
    // ì°¨íŠ¸ ë²”ìœ„ ê³„ì‚°
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    nodes.forEach(node => {
        const x = parseFloat(node.style.left) || 0;
        const y = parseFloat(node.style.top) || 0;
        const width = node.offsetWidth || 100;
        const height = node.offsetHeight || 50;
        
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x + width);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y + height);
    });
    
    // ì°¨íŠ¸ í¬ê¸°
    const chartWidth = maxX - minX || 1000;
    const chartHeight = maxY - minY || 600;
    
    // ìŠ¤ì¼€ì¼ ê³„ì‚°
    const scale = Math.min(
        canvas.width / chartWidth,
        canvas.height / chartHeight
    ) * 0.9;
    
    // ì°¨íŠ¸ ì˜ì—­ ì¤‘ì•™ ì •ë ¬
    const offsetX = (canvas.width - chartWidth * scale) / 2;
    const offsetY = (canvas.height - chartHeight * scale) / 2;
    
    // ë…¸ë“œ ê·¸ë¦¬ê¸°
    nodes.forEach(node => {
        const x = parseFloat(node.style.left) || 0;
        const y = parseFloat(node.style.top) || 0;
        const width = node.offsetWidth || 100;
        const height = node.offsetHeight || 50;
        
        // ë…¸ë“œ íƒ€ì…ì— ë”°ë¼ ìƒ‰ìƒ êµ¬ë¶„
        const nodeType = node.dataset.type || 'default';
        if (nodeType === 'group' || nodeType === 'subsidiary') {
            ctx.fillStyle = '#00d4ff';
        } else if (nodeType === 'division') {
            ctx.fillStyle = '#00a8cc';
        } else if (nodeType === 'department') {
            ctx.fillStyle = '#0088aa';
        } else {
            ctx.fillStyle = '#006688';
        }
        
        const nodeX = offsetX + (x - minX) * scale;
        const nodeY = offsetY + (y - minY) * scale;
        const nodeWidth = Math.max(2, width * scale);
        const nodeHeight = Math.max(2, height * scale);
        
        ctx.fillRect(nodeX, nodeY, nodeWidth, nodeHeight);
    });
    
    // ë·°í¬íŠ¸ í‘œì‹œ ì˜ì—­
    const zoomLevel = OrgChartState.zoomLevel / 100;
    const viewportWidth = chartViewport.clientWidth / zoomLevel;
    const viewportHeight = chartViewport.clientHeight / zoomLevel;
    const viewportX = offsetX + (chartViewport.scrollLeft - minX) * scale;
    const viewportY = offsetY + (chartViewport.scrollTop - minY) * scale;
    
    // ë·°í¬íŠ¸ ì˜ì—­ í…Œë‘ë¦¬
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    ctx.strokeRect(
        viewportX,
        viewportY,
        viewportWidth * scale,
        viewportHeight * scale
    );
    
    // ë°˜íˆ¬ëª… í•˜ì´ë¼ì´íŠ¸
    ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
    ctx.fillRect(
        viewportX,
        viewportY,
        viewportWidth * scale,
        viewportHeight * scale
    );
}

// ë¯¸ë‹ˆë§µì— ë…¸ë“œ í‘œì‹œ
function updateMinimapNodes(minimap, nodes, offsetX, offsetY, scale) {
    // Canvas ë°©ì‹ìœ¼ë¡œ ë³€ê²½ë˜ì–´ ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ
    return;
    /*
    // ê¸°ì¡´ ë¯¸ë‹ˆë§µ ë…¸ë“œ ì œê±°
    minimap.querySelectorAll('.minimap-node').forEach(n => n.remove());
    
    // ë…¸ë“œë¥¼ ë¯¸ë‹ˆë§µì— í‘œì‹œ
    nodes.forEach(node => {
        const x = (parseFloat(node.style.left) || 0) - offsetX;
        const y = (parseFloat(node.style.top) || 0) - offsetY;
        
        const minimapNode = document.createElement('div');
        minimapNode.className = 'minimap-node';
        minimapNode.style.cssText = `
            position: absolute;
            left: ${x * scale}px;
            top: ${y * scale}px;
            width: ${3}px;
            height: ${3}px;
            background: rgba(0, 212, 255, 0.5);
            border-radius: 50%;
        `;
        minimap.appendChild(minimapNode);
    });
    */
}

// ë²„í‚· í´ëŸ¬ìŠ¤í„° í™•ì¥ (ë²„í‚· í´ë¦­ ì‹œ ìˆ¨ê²¨ì§„ ë…¸ë“œ í‘œì‹œ)
function expandCluster(clusterId) {
    const clusterNode = OrgChartState.nodes.get(clusterId);
    if (!clusterNode || !clusterNode.isCluster) return;
    
    const hiddenNodes = OrgChartState.clusteredSiblings.get(clusterId);
    if (!hiddenNodes || hiddenNodes.length === 0) return;
    
    console.log(`Expanding cluster ${clusterId} with ${hiddenNodes.length} hidden nodes`);
    
    // ë¶€ëª¨ ë…¸ë“œ ì°¾ê¸°
    const parentNode = OrgChartState.nodes.get(clusterNode.parentId);
    if (!parentNode) return;
    
    // í´ëŸ¬ìŠ¤í„° ë…¸ë“œ ì œê±°
    OrgChartState.nodes.delete(clusterId);
    OrgChartState.clusteredSiblings.delete(clusterId);
    
    // ìˆ¨ê²¨ì§„ ë…¸ë“œë“¤ì„ ë…¸ë“œ ë§µì— ì¶”ê°€
    hiddenNodes.forEach(node => {
        const processedNode = {
            ...node,
            parentId: clusterNode.parentId,
            level: clusterNode.level,
            // x, y ì¢Œí‘œëŠ” calculateLayoutì—ì„œ ê³„ì‚°
        };
        OrgChartState.nodes.set(node.id, processedNode);
        
        // ìì‹ ë…¸ë“œë“¤ë„ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬
        if (node.children && node.children.length > 0) {
            function processChildren(children, parentId, level) {
                children.forEach(child => {
                    const childNode = {
                        ...child,
                        parentId: parentId,
                        level: level,
                        // x, y ì¢Œí‘œëŠ” calculateLayoutì—ì„œ ê³„ì‚°
                    };
                    OrgChartState.nodes.set(child.id, childNode);
                    
                    if (child.children) {
                        processChildren(child.children, child.id, level + 1);
                    }
                });
            }
            processChildren(node.children, node.id, clusterNode.level + 1);
        }
    });
    
    // ë¶€ëª¨ ë…¸ë“œê°€ í™•ì¥ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ì„¤ì •
    if (!OrgChartState.expandedNodes.has(clusterNode.parentId)) {
        OrgChartState.expandedNodes.add(clusterNode.parentId);
    }
    
    // ë ˆì´ì•„ì›ƒ ì¬ê³„ì‚° ë° ë Œë”ë§
    calculateLayout();
    renderChart();
    
    // ìŠ¤í¬ë¡¤ ì¡°ì • (ì„ íƒì )
    const parentElement = document.getElementById(`node-${clusterNode.parentId}`);
    if (parentElement) {
        parentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

// ë¡œë”© í‘œì‹œ
function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    overlay.style.display = show ? 'flex' : 'none';
}

// ì—ëŸ¬ í‘œì‹œ
function showError(message) {
    console.error(message);
    // ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ í™”ë©´ì— í‘œì‹œ
    const viewport = document.getElementById('chartViewport');
    if (viewport && !document.getElementById('errorMessage')) {
        const errorDiv = document.createElement('div');
        errorDiv.id = 'errorMessage';
        errorDiv.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 0, 0, 0.1); color: #ff6b6b; padding: 1rem 2rem; border-radius: 0.5rem; border: 1px solid #ff6b6b;';
        errorDiv.textContent = message;
        viewport.appendChild(errorDiv);
        
        // 3ì´ˆ í›„ ì—ëŸ¬ ë©”ì‹œì§€ ì œê±°
        setTimeout(() => {
            errorDiv.remove();
        }, 3000);
    }
}

// ìƒ˜í”Œ ë°ì´í„° ì‚¬ìš© (API ì‹¤íŒ¨ ì‹œ ë°±ì—…)
function useSampleData() {
    const sampleData = {
        id: 'OKê¸ˆìœµê·¸ë£¹',
        name: 'OKê¸ˆìœµê·¸ë£¹',
        type: 'company',
        title: 'CEO',
        headcount: 1700,
        childrenCount: 5,
        hasChildren: true,
        parentId: null,
        path: ['OKê¸ˆìœµê·¸ë£¹'],
        children: [
            {
                id: 'division-1',
                name: 'ê²½ì˜ì§€ì›ë³¸ë¶€',
                type: 'division',
                headcount: 320,
                childrenCount: 8,
                hasChildren: true,
                parentId: 'OKê¸ˆìœµê·¸ë£¹',
                path: ['OKê¸ˆìœµê·¸ë£¹', 'ê²½ì˜ì§€ì›ë³¸ë¶€'],
                children: [
                    {
                        id: 'dept-1-1',
                        name: 'ì¸ì‚¬ë¶€',
                        type: 'department',
                        headcount: 45,
                        childrenCount: 2,
                        hasChildren: true,
                        parentId: 'division-1',
                        path: ['OKê¸ˆìœµê·¸ë£¹', 'ê²½ì˜ì§€ì›ë³¸ë¶€', 'ì¸ì‚¬ë¶€'],
                        children: [
                            {
                                id: 'team-1-1-1',
                                name: 'ì±„ìš©íŒ€',
                                type: 'team',
                                headcount: 12,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-1',
                                path: ['OKê¸ˆìœµê·¸ë£¹', 'ê²½ì˜ì§€ì›ë³¸ë¶€', 'ì¸ì‚¬ë¶€', 'ì±„ìš©íŒ€']
                            },
                            {
                                id: 'team-1-1-2',
                                name: 'êµìœ¡íŒ€',
                                type: 'team',
                                headcount: 8,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-1',
                                path: ['OKê¸ˆìœµê·¸ë£¹', 'ê²½ì˜ì§€ì›ë³¸ë¶€', 'ì¸ì‚¬ë¶€', 'êµìœ¡íŒ€']
                            }
                        ]
                    },
                    {
                        id: 'dept-1-2',
                        name: 'ì¬ë¬´ë¶€',
                        type: 'department',
                        headcount: 38,
                        childrenCount: 1,
                        hasChildren: true,
                        parentId: 'division-1',
                        path: ['OKê¸ˆìœµê·¸ë£¹', 'ê²½ì˜ì§€ì›ë³¸ë¶€', 'ì¬ë¬´ë¶€'],
                        children: [
                            {
                                id: 'team-1-2-1',
                                name: 'íšŒê³„íŒ€',
                                type: 'team',
                                headcount: 15,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-2',
                                path: ['OKê¸ˆìœµê·¸ë£¹', 'ê²½ì˜ì§€ì›ë³¸ë¶€', 'ì¬ë¬´ë¶€', 'íšŒê³„íŒ€']
                            }
                        ]
                    }
                ]
            },
            {
                id: 'division-2',
                name: 'ITë³¸ë¶€',
                type: 'division',
                headcount: 450,
                childrenCount: 10,
                hasChildren: true,
                parentId: 'OKê¸ˆìœµê·¸ë£¹',
                path: ['OKê¸ˆìœµê·¸ë£¹', 'ITë³¸ë¶€'],
                children: [
                    {
                        id: 'dept-2-1',
                        name: 'ê°œë°œë¶€',
                        type: 'department',
                        headcount: 62,
                        childrenCount: 2,
                        hasChildren: true,
                        parentId: 'division-2',
                        path: ['OKê¸ˆìœµê·¸ë£¹', 'ITë³¸ë¶€', 'ê°œë°œë¶€'],
                        children: [
                            {
                                id: 'team-2-1-1',
                                name: 'í”„ë¡ íŠ¸ì—”ë“œíŒ€',
                                type: 'team',
                                headcount: 18,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-1',
                                path: ['OKê¸ˆìœµê·¸ë£¹', 'ITë³¸ë¶€', 'ê°œë°œë¶€', 'í”„ë¡ íŠ¸ì—”ë“œíŒ€']
                            },
                            {
                                id: 'team-2-1-2',
                                name: 'ë°±ì—”ë“œíŒ€',
                                type: 'team',
                                headcount: 25,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-1',
                                path: ['OKê¸ˆìœµê·¸ë£¹', 'ITë³¸ë¶€', 'ê°œë°œë¶€', 'ë°±ì—”ë“œíŒ€']
                            }
                        ]
                    },
                    {
                        id: 'dept-2-2',
                        name: 'ì¸í”„ë¼ë¶€',
                        type: 'department',
                        headcount: 35,
                        childrenCount: 1,
                        hasChildren: true,
                        parentId: 'division-2',
                        path: ['OKê¸ˆìœµê·¸ë£¹', 'ITë³¸ë¶€', 'ì¸í”„ë¼ë¶€'],
                        children: [
                            {
                                id: 'team-2-2-1',
                                name: 'í´ë¼ìš°ë“œíŒ€',
                                type: 'team',
                                headcount: 12,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-2',
                                path: ['OKê¸ˆìœµê·¸ë£¹', 'ITë³¸ë¶€', 'ì¸í”„ë¼ë¶€', 'í´ë¼ìš°ë“œíŒ€']
                            }
                        ]
                    }
                ]
            },
            {
                id: 'division-3',
                name: 'ì˜ì—…ë³¸ë¶€',
                type: 'division',
                headcount: 580,
                childrenCount: 15,
                hasChildren: true,
                parentId: 'OKê¸ˆìœµê·¸ë£¹',
                path: ['OKê¸ˆìœµê·¸ë£¹', 'ì˜ì—…ë³¸ë¶€'],
                children: []
            },
            {
                id: 'subsidiary-1',
                name: 'OKì €ì¶•ì€í–‰',
                type: 'division',
                headcount: 450,
                childrenCount: 8,
                hasChildren: true,
                parentId: 'OKê¸ˆìœµê·¸ë£¹',
                path: ['OKê¸ˆìœµê·¸ë£¹', 'OKì €ì¶•ì€í–‰'],
                children: [
                    {
                        id: 'bank-dept-1',
                        name: 'ë¦¬í…Œì¼ê¸ˆìœµë¶€',
                        type: 'department',
                        headcount: 85,
                        childrenCount: 3,
                        hasChildren: true,
                        parentId: 'subsidiary-1',
                        path: ['OKê¸ˆìœµê·¸ë£¹', 'OKì €ì¶•ì€í–‰', 'ë¦¬í…Œì¼ê¸ˆìœµë¶€'],
                        children: []
                    },
                    {
                        id: 'bank-dept-2',
                        name: 'ê¸°ì—…ê¸ˆìœµë¶€',
                        type: 'department',
                        headcount: 72,
                        childrenCount: 2,
                        hasChildren: true,
                        parentId: 'subsidiary-1',
                        path: ['OKê¸ˆìœµê·¸ë£¹', 'OKì €ì¶•ì€í–‰', 'ê¸°ì—…ê¸ˆìœµë¶€'],
                        children: []
                    }
                ]
            }
        ]
    };
    
    showLoading(false);
    
    // ë…¸ë“œ ì²˜ë¦¬ (ì´ˆê¸° ë¡œë“œ ì‹œ ë²„í‚· í´ëŸ¬ìŠ¤í„°ë§ ë¹„í™œì„±í™”)
    processOrgData(sampleData, true);
    
    // ì´ˆê¸° ë¡œë“œ ì‹œ ëª¨ë“  ë…¸ë“œ í¼ì¹˜ê¸° (Progressive Disclosure ì—†ì´ ì „ì²´ êµ¬ì¡° í‘œì‹œ)
    console.log('Auto-expanding ALL nodes for initial display...');
    console.log(`Total nodes in state: ${OrgChartState.nodes.size}`);
    
    // ëª¨ë“  ë…¸ë“œ í™•ì¥
    OrgChartState.nodes.forEach(node => {
        if (node.hasChildren) {  // ëª¨ë“  ìì‹ì´ ìˆëŠ” ë…¸ë“œë¥¼ í™•ì¥
            OrgChartState.expandedNodes.add(node.id);
            console.log(`Auto-expanded: ${node.name} (level ${node.level}, id: ${node.id})`);
        }
    });
    
    console.log(`Total expanded nodes: ${OrgChartState.expandedNodes.size}`);
    console.log('Expanded node IDs:', Array.from(OrgChartState.expandedNodes));
    
    // ë ˆì´ì•„ì›ƒê³¼ ë Œë”ë§ì€ initializeChart()ì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ìƒëµ
    // calculateLayout();  
    // renderChart();
}

// ê¸°íƒ€ ë ˆì´ì•„ì›ƒ ê³„ì‚° í•¨ìˆ˜ë“¤ (ê°„ë‹¨í•œ êµ¬í˜„)
function calculateRadialLayout() {
    console.log('Calculating radial layout...');
    // ë°©ì‚¬í˜• ë ˆì´ì•„ì›ƒ ê³„ì‚° ë¡œì§
    // ì„ì‹œë¡œ ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ì‚¬ìš©
    calculateLayout();
}

function calculateGridLayout() {
    console.log('Calculating grid layout...');
    // ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ ê³„ì‚° ë¡œì§
    const nodes = Array.from(OrgChartState.nodes.values());
    const cols = 4;
    let row = 0, col = 0;
    
    nodes.forEach((node, index) => {
        node.x = col * (CONFIG.NODE_WIDTH + CONFIG.SIBLING_SPACING) - (cols * CONFIG.NODE_WIDTH) / 2;
        node.y = row * (CONFIG.NODE_HEIGHT + 40);
        
        col++;
        if (col >= cols) {
            col = 0;
            row++;
        }
    });
}

function calculateCompactLayout() {
    console.log('Calculating compact layout...');
    // ì»´íŒ©íŠ¸ ë ˆì´ì•„ì›ƒ ê³„ì‚° ë¡œì§
    // ì„ì‹œë¡œ ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ì‚¬ìš©
    calculateLayout();
}
</script>
{% endblock %}