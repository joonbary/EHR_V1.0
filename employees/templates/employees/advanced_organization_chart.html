{% extends "base_revolutionary.html" %}
{% load static %}

{% block title %}차세대 조직도 | AI HRM{% endblock %}

{% block extra_css %}
<style>
    /* 기본 레이아웃 - 가로 스크롤 차단 */
    .org-chart-container {
        background: linear-gradient(180deg, #0b1324, #0a0f1e);
        min-height: calc(100vh - 70px);
        position: relative;
        display: flex;
        flex-direction: column;
        overflow-x: hidden; /* 가로 스크롤 차단 */
    }

    /* 툴바 스타일 */
    .org-toolbar {
        background: rgba(26, 31, 46, 0.95);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        padding: 1rem;
        position: sticky;
        top: 0;
        z-index: 1000;
    }

    .toolbar-inner {
        display: flex;
        align-items: center;
        gap: 1.5rem;
        max-width: 1600px;
        margin: 0 auto;
    }

    /* 뷰 모드 선택 */
    .view-modes {
        display: flex;
        gap: 0.5rem;
        background: rgba(10, 15, 27, 0.6);
        padding: 0.25rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(0, 212, 255, 0.2);
    }

    .view-mode-btn {
        padding: 0.5rem 1rem;
        background: transparent;
        color: #94a3b8;
        border: none;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.875rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .view-mode-btn.active {
        background: linear-gradient(135deg, #00d4ff, #0099cc);
        color: white;
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
    }

    .view-mode-btn:hover:not(.active) {
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
    }

    /* 레벨 필터 */
    .level-filters {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    .level-filter-btn {
        padding: 0.375rem 0.75rem;
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.813rem;
    }

    .level-filter-btn.active {
        background: rgba(0, 212, 255, 0.2);
        border-color: #00d4ff;
        box-shadow: 0 0 10px rgba(0, 212, 255, 0.2);
    }

    /* 검색 박스 */
    .org-search-box {
        position: relative;
        flex: 1;
        max-width: 400px;
    }

    .org-search-input {
        width: 100%;
        padding: 0.625rem 1rem 0.625rem 2.5rem;
        background: rgba(10, 15, 27, 0.6);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        color: white;
        font-size: 0.875rem;
        transition: all 0.3s ease;
    }

    .org-search-input:focus {
        border-color: #00d4ff;
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        outline: none;
    }

    .org-search-icon {
        position: absolute;
        left: 0.875rem;
        top: 50%;
        transform: translateY(-50%);
        color: #94a3b8;
    }

    /* 자동완성 드롭다운 */
    .search-autocomplete {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        margin-top: 0.5rem;
        background: rgba(26, 31, 46, 0.98);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        z-index: 1001;
    }

    .search-autocomplete.active {
        display: block;
    }

    .autocomplete-item {
        padding: 0.75rem 1rem;
        color: #cbd5e1;
        cursor: pointer;
        transition: all 0.2s ease;
        border-bottom: 1px solid rgba(0, 212, 255, 0.1);
    }

    .autocomplete-item:hover {
        background: rgba(0, 212, 255, 0.1);
        color: white;
    }

    .autocomplete-item-name {
        font-weight: 500;
        color: white;
    }

    .autocomplete-item-path {
        font-size: 0.75rem;
        color: #64748b;
        margin-top: 0.25rem;
    }

    /* 줌 컨트롤 */
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background: rgba(10, 15, 27, 0.6);
        padding: 0.25rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(0, 212, 255, 0.2);
    }

    .zoom-btn {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        color: #94a3b8;
        border: none;
        border-radius: 0.375rem;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .zoom-btn:hover {
        background: rgba(0, 212, 255, 0.1);
        color: #00d4ff;
    }

    .zoom-level {
        color: #00d4ff;
        font-size: 0.813rem;
        min-width: 50px;
        text-align: center;
    }

    /* 메인 차트 영역 - 가로 스크롤 금지 */
    .chart-viewport {
        flex: 1;
        position: relative;
        overflow-y: auto;
        overflow-x: hidden; /* 가로 스크롤 금지 */
        padding: 1rem;
        background: linear-gradient(to bottom, 
            rgba(10, 15, 27, 0.9),
            rgba(26, 31, 46, 0.95));
    }

    /* 트리 컨테이너 - 확대 기준 상단 중앙 */
    .tree-container {
        min-height: 100%;
        position: relative;
        transition: transform 0.3s ease;
        transform-origin: top center; /* 확대 기준점 */
        padding: 50px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    /* TallNode 스타일 - 세로 길쭉한 카드 (180×300) */
    .org-node {
        position: absolute;
        background: rgba(14, 23, 40, 0.8); /* #0e1728/80 */
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 1rem; /* rounded-2xl */
        width: 180px;
        min-height: 300px;
        max-height: 420px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.875rem;
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    /* 노드 왼쪽 세로 spine (타입 표시) */
    .node-spine {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 24px; /* w-6 */
        opacity: 0.7;
        border-radius: 1rem 0 0 1rem;
    }
    
    .node-spine.company {
        background: linear-gradient(to bottom, #06b6d4, transparent); /* cyan-500 */
    }
    
    .node-spine.division {
        background: linear-gradient(to bottom, #d946ef, transparent); /* fuchsia-500 */
    }
    
    .node-spine.department {
        background: linear-gradient(to bottom, #14b8a6, transparent); /* teal-500 */
    }
    
    .node-spine.team {
        background: linear-gradient(to bottom, #64748b, transparent); /* slate-500 */
    }
    
    .node-spine.person {
        background: linear-gradient(to bottom, #f59e0b, transparent); /* amber-500 */
    }

    .org-node:hover {
        border-color: #00d4ff;
        box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
        transform: translateY(-2px);
    }

    .org-node.focused {
        border-color: #00d4ff;
        box-shadow: 0 0 40px rgba(0, 212, 255, 0.5);
        background: rgba(0, 212, 255, 0.05);
    }

    .org-node.collapsed .node-children-info {
        display: block;
    }

    /* 노드 헤더 */
    .node-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0.5rem;
    }

    .node-type-badge {
        display: inline-block;
        padding: 0.125rem 0.5rem;
        background: rgba(0, 212, 255, 0.2);
        color: #00d4ff;
        border-radius: 0.25rem;
        font-size: 0.688rem;
        font-weight: 500;
        text-transform: uppercase;
    }

    .node-type-badge.company {
        background: rgba(168, 85, 247, 0.2);
        color: #a855f7;
    }

    .node-type-badge.division {
        background: rgba(236, 72, 153, 0.2);
        color: #ec4899;
    }

    .node-type-badge.department {
        background: rgba(34, 197, 94, 0.2);
        color: #22c55e;
    }

    .node-type-badge.team {
        background: rgba(251, 146, 60, 0.2);
        color: #fb923c;
    }

    /* 노드 콘텐츠 - TallNode 레이아웃 */
    .node-content {
        color: white;
        padding: 0.75rem;
        padding-left: 2rem; /* spine 공간 확보 */
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        flex: 1;
    }

    .node-name {
        font-size: 0.75rem; /* text-[12px] */
        font-weight: 600;
        line-height: 1.2;
        color: rgba(255, 255, 255, 0.9);
        /* 3줄 클램프 */
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .node-title {
        font-size: 0.688rem; /* text-[11px] */
        color: rgba(255, 255, 255, 0.6);
        line-height: 1.4;
        /* 2줄 클램프 */
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* 노드 통계 그리드 */
    .node-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.25rem;
        margin-top: 0.25rem;
    }

    .node-stat {
        background: rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.7);
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.625rem; /* text-[10px] */
        text-align: center;
    }

    /* 노드 배지 */
    .node-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        margin-top: 0.25rem;
    }
    
    .node-badge {
        padding: 0.125rem 0.375rem;
        background: rgba(16, 185, 129, 0.1); /* emerald-400/10 */
        color: #10b981; /* emerald-300 */
        border-radius: 0.25rem;
        font-size: 0.625rem; /* text-[10px] */
    }

    /* 접기/펼치기 버튼 */
    .node-toggle {
        position: absolute;
        bottom: -12px;
        left: 50%;
        transform: translateX(-50%);
        width: 24px;
        height: 24px;
        background: rgba(26, 31, 46, 0.95);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: #00d4ff;
        transition: all 0.2s ease;
    }

    .node-toggle:hover {
        background: rgba(0, 212, 255, 0.2);
        border-color: #00d4ff;
    }

    /* 하위 노드 정보 (접힌 상태) */
    .node-children-info {
        display: none;
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid rgba(0, 212, 255, 0.1);
        font-size: 0.813rem;
        color: #00d4ff;
    }

    /* 오버플로우 클러스터 */
    .overflow-cluster {
        background: rgba(0, 212, 255, 0.05);
        border: 1px solid rgba(0, 212, 255, 0.2);
        border-radius: 0.5rem;
        padding: 0.75rem;
        margin-top: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
    }

    .overflow-cluster:hover {
        background: rgba(0, 212, 255, 0.1);
        border-color: #00d4ff;
    }

    .overflow-cluster-text {
        color: #00d4ff;
        font-size: 0.875rem;
    }

    /* 연결선 */
    .org-edge {
        position: absolute;
        background: linear-gradient(to bottom, rgba(0, 212, 255, 0.3), transparent);
        width: 2px;
        transition: all 0.3s ease;
        pointer-events: none;
    }

    .org-edge.horizontal {
        height: 2px;
        width: auto;
        background: linear-gradient(to right, transparent, rgba(0, 212, 255, 0.3), transparent);
    }

    /* 미니맵 */
    .minimap {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 200px;
        height: 120px;
        background: rgba(26, 31, 46, 0.95);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 0.5rem;
        padding: 0.5rem;
        z-index: 900;
    }

    .minimap-viewport {
        position: absolute;
        background: rgba(0, 212, 255, 0.2);
        border: 1px solid #00d4ff;
        pointer-events: none;
    }

    /* 브레드크럼 */
    .breadcrumb-nav {
        background: rgba(10, 15, 27, 0.6);
        padding: 0.75rem 1rem;
        border-bottom: 1px solid rgba(0, 212, 255, 0.1);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        overflow-x: auto;
    }

    .breadcrumb-item {
        color: #64748b;
        font-size: 0.875rem;
        white-space: nowrap;
        cursor: pointer;
        transition: color 0.2s ease;
    }

    .breadcrumb-item:hover {
        color: #00d4ff;
    }

    .breadcrumb-separator {
        color: #475569;
    }

    .breadcrumb-item.active {
        color: white;
        font-weight: 500;
    }

    /* 로딩 상태 */
    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(10, 15, 27, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(0, 212, 255, 0.2);
        border-top-color: #00d4ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    /* 반응형 디자인 */
    @media (max-width: 768px) {
        .toolbar-inner {
            flex-direction: column;
            gap: 1rem;
        }

        .org-search-box {
            max-width: 100%;
        }

        .minimap {
            width: 150px;
            height: 90px;
        }
    }

    /* 시맨틱 줌 레벨 */
    .tree-container.zoom-small .node-title,
    .tree-container.zoom-small .node-stats {
        display: none;
    }

    .tree-container.zoom-small .org-node {
        padding: 0.5rem;
        min-width: 150px;
    }

    .tree-container.zoom-large .org-node {
        padding: 1.25rem;
        min-width: 250px;
    }

    /* 키보드 내비게이션 포커스 */
    .org-node:focus {
        outline: 2px solid #00d4ff;
        outline-offset: 2px;
    }

    /* 접근성 */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }
    
    /* 세로 글자 유틸리티 (DenseTallNode용) - CJK 최적화 - 작업지시서 사양 */
    .vertical-cjk {
        writing-mode: vertical-rl !important;
        text-orientation: upright !important; /* CJK 문자 직립 */
    }
    
    .vertical-mixed {
        writing-mode: vertical-rl !important;
        text-orientation: mixed !important; /* 영문/숫자 섞일 때 */
    }
    
    .v-chip {
        writing-mode: vertical-rl !important;
        text-orientation: mixed !important;
        font-size: 10px !important;
        line-height: 1 !important;
    }
    
    /* DenseTallNode 스타일 - 초슬림 세로 카드 (40px 폭으로 더 축소) */
    .dense-node {
        width: 40px !important;
        min-height: 200px !important;
        max-height: 280px !important;
        padding: 0.25rem !important;
        background: rgba(14, 23, 40, 0.9) !important;
        border: 1px solid rgba(0, 212, 255, 0.3) !important;
    }
    
    .dense-node .node-content {
        padding: 0.5rem !important;
        padding-left: 1rem !important;
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        gap: 0.75rem !important;
        height: 100% !important;
    }
    
    /* Dense 노드 이름 - 세로쓰기 강제 적용 */
    .dense-node .node-name,
    .dense-node .vertical-cjk {
        writing-mode: vertical-rl !important;
        text-orientation: upright !important; /* 작업지시서: CJK upright */
        max-height: 220px !important;
        overflow: hidden !important;
        flex: 1 !important;
        display: flex !important;
        align-items: center !important;
    }
    
    .dense-node .node-stats {
        display: flex !important;
        flex-direction: column !important;
        gap: 0.25rem !important;
    }
    
    /* Dense 노드 통계 칩 - 세로쓰기 강제 적용 */
    .dense-node .node-stat,
    .dense-node .v-chip {
        writing-mode: vertical-rl !important;
        text-orientation: mixed !important;
        font-size: 10px !important;
        padding: 0.25rem !important;
        background: rgba(255, 255, 255, 0.05) !important;
        color: rgba(255, 255, 255, 0.7) !important;
        border-radius: 0.25rem !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="org-chart-container">
    <!-- 툴바 -->
    <div class="org-toolbar">
        <div class="toolbar-inner">
            <!-- 뷰 모드 선택 -->
            <div class="view-modes">
                <button class="view-mode-btn active" data-mode="vertical">
                    <i class="fas fa-sitemap"></i>
                    <span>세로형</span>
                </button>
                <button class="view-mode-btn" data-mode="grid">
                    <i class="fas fa-th"></i>
                    <span>그리드</span>
                </button>
                <button class="view-mode-btn" data-mode="radial">
                    <i class="fas fa-circle-notch"></i>
                    <span>방사형</span>
                </button>
                <button class="view-mode-btn" data-mode="compact">
                    <i class="fas fa-list"></i>
                    <span>컴팩트</span>
                </button>
            </div>

            <!-- 레벨 필터 -->
            <div class="level-filters">
                <span style="color: #94a3b8; font-size: 0.875rem;">레벨:</span>
                <button class="level-filter-btn active" data-level="all">전체</button>
                <button class="level-filter-btn" data-level="executive">임원</button>
                <button class="level-filter-btn" data-level="division">본부</button>
                <button class="level-filter-btn" data-level="department">부서</button>
                <button class="level-filter-btn" data-level="team">팀</button>
            </div>

            <!-- 검색 -->
            <div class="org-search-box">
                <i class="fas fa-search org-search-icon"></i>
                <input type="text" class="org-search-input" placeholder="이름, 부서, 직급으로 검색..." id="orgSearch">
                <div class="search-autocomplete" id="searchAutocomplete"></div>
            </div>

            <!-- 줌 컨트롤 -->
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">
                    <i class="fas fa-minus"></i>
                </button>
                <span class="zoom-level" id="zoomLevel">100%</span>
                <button class="zoom-btn" id="zoomIn">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="zoom-btn" id="zoomReset">
                    <i class="fas fa-expand"></i>
                </button>
            </div>
            
            <!-- 깊이 확장 버튼 -->
            <div class="depth-controls" style="display: flex; gap: 0.5rem;">
                <button class="level-filter-btn" onclick="expandToDepth('OK금융그룹', 2)" title="레벨 2까지 펼침">
                    <i class="fas fa-layer-group"></i> L2
                </button>
                <button class="level-filter-btn" onclick="expandToDepth('OK금융그룹', 3)" title="레벨 3까지 펼침">
                    <i class="fas fa-layer-group"></i> L3
                </button>
                <button class="level-filter-btn" onclick="expandToDepth('OK금융그룹', 4)" title="레벨 4까지 펼침">
                    <i class="fas fa-layer-group"></i> L4
                </button>
            </div>
        </div>
    </div>

    <!-- 브레드크럼 네비게이션 -->
    <div class="breadcrumb-nav" id="breadcrumbNav">
        <span class="breadcrumb-item active">전체 조직</span>
    </div>

    <!-- 메인 차트 영역 -->
    <div class="chart-viewport" id="chartViewport">
        <div class="tree-container" id="treeContainer">
            <!-- 동적으로 생성될 조직도 노드들 -->
        </div>

        <!-- 로딩 오버레이 -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- 미니맵 -->
    <div class="minimap" id="minimap">
        <div class="minimap-viewport"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// 전역 상태 관리
const OrgChartState = {
    currentView: 'vertical',
    currentLevel: 'all',
    zoomLevel: 100,
    focusedNode: null,
    expandedNodes: new Set(['OK금융그룹']), // 루트 노드만 초기 펼침
    searchQuery: '',
    nodes: new Map(),
    edges: [],
    clusteredSiblings: new Map(), // 오버플로우 클러스터링 상태
};

// 상수 정의 - ELK 레이아웃용 파라미터 강화
const CONFIG = {
    MAX_VISIBLE_SIBLINGS: 12, // 최대 표시 형제 노드 수 (초과시 버킷 그룹화)
    NODE_WIDTH: 120,  // TallNode 너비 (일반 모드) - 더 축소
    NODE_WIDTH_DENSE: 40, // DenseTallNode 너비 (초슬림 모드) - 40px로 축소
    NODE_HEIGHT: 300, // 노드 높이 (세로 길쭉한 형태)
    NODE_HEIGHT_DENSE: 300, // Dense 모드에서도 동일 높이
    LEVEL_SPACING: 120,  // 레벨 간격 (레이어 간 거리) - 축소
    SIBLING_SPACING: 30, // 형제 간격 (일반 모드) - 축소
    SIBLING_SPACING_DENSE: 15, // 형제 간격 (Dense 모드) - 더 축소
    ZOOM_MIN: 30,  // 더 작게 축소 가능
    ZOOM_MAX: 200,
    ZOOM_STEP: 10,
    ZOOM_DENSE_THRESHOLD: 95, // 95% 미만일 때 DenseTallNode 사용
    SEARCH_DELAY: 300,
    ANIMATION_DURATION: 300,
    MAX_WIDTH_PER_LEVEL: 2400, // 레벨당 최대 너비 증가
    MIN_SPACING_RATIO: 0.6, // 최소 간격 비율 (자식이 많을 때)
    COLLISION_PADDING: 20, // 충돌 감지 여백
    BUCKET_THRESHOLD: 12, // 버킷 그룹화 임계값 (>12 형제)
};

// 그래프 검증 유틸리티 - 체인(직렬) 엣지 검출
function validateGraph(edges) {
    const childCount = new Map();
    edges.forEach(e => {
        childCount.set(e.source.id || e.source, 
            (childCount.get(e.source.id || e.source) || 0) + 1);
    });
    
    // 부모가 계속 1명 자식만 가지는 구간은 체인 의심
    const singleChildParents = [];
    childCount.forEach((count, id) => {
        if (count === 1) {
            singleChildParents.push(id);
        }
    });
    
    // 체인 길이 계산
    const chainLength = singleChildParents.length;
    const hasLongChain = chainLength > 3; // 3개 이상 연속이면 경고
    
    if (hasLongChain) {
        console.warn(`Graph validation warning: Found chain of ${chainLength} single-child parents`, singleChildParents);
    }
    
    return { 
        singleChildParents, 
        chainLength,
        hasLongChain,
        isValid: !hasLongChain
    };
}

// 초기화
document.addEventListener('DOMContentLoaded', function() {
    console.log('Advanced Org Chart: DOM loaded, initializing...');
    
    try {
        initializeChart();
        setupEventListeners();
        setupKeyboardNavigation();
        
        // API 데이터 로드를 시도하고, 실패하면 샘플 데이터 사용
        loadInitialData().catch((error) => {
            console.log('API failed, using sample data...', error);
            useSampleData();
        });
    } catch (error) {
        console.error('Initialization error:', error);
        // 초기화 실패 시 샘플 데이터로 백업
        useSampleData();
    }
});

// 차트 초기화
function initializeChart() {
    // 초기 뷰 설정 (적절한 균형을 위해 70% 줌으로 시작)
    updateViewMode('vertical');
    updateZoom(70); // Dense 모드 활성화하되 더 작은 줌으로 전체 뷰 제공
    
    console.log('💡 고급 조직도 초기화 완료 - Dense 모드 활성화 (70% 줌)');
}

// 이벤트 리스너 설정
function setupEventListeners() {
    console.log('Setting up event listeners...');
    
    // 뷰 모드 변경
    const viewModeBtns = document.querySelectorAll('.view-mode-btn');
    console.log(`Found ${viewModeBtns.length} view mode buttons`);
    viewModeBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            console.log('View mode clicked:', this.dataset.mode);
            const mode = this.dataset.mode;
            updateViewMode(mode);
        });
    });

    // 레벨 필터
    const levelFilterBtns = document.querySelectorAll('.level-filter-btn');
    console.log(`Found ${levelFilterBtns.length} level filter buttons`);
    levelFilterBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            console.log('Level filter clicked:', this.dataset.level);
            const level = this.dataset.level;
            updateLevelFilter(level);
        });
    });

    // 검색
    const searchInput = document.getElementById('orgSearch');
    let searchTimeout;
    searchInput.addEventListener('input', function(e) {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            performSearch(e.target.value);
        }, CONFIG.SEARCH_DELAY);
    });

    // 줌 컨트롤
    document.getElementById('zoomIn').addEventListener('click', () => {
        updateZoom(Math.min(OrgChartState.zoomLevel + CONFIG.ZOOM_STEP, CONFIG.ZOOM_MAX));
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
        updateZoom(Math.max(OrgChartState.zoomLevel - CONFIG.ZOOM_STEP, CONFIG.ZOOM_MIN));
    });

    document.getElementById('zoomReset').addEventListener('click', () => {
        updateZoom(100);
    });

    // 마우스 휠 줌 - 부드러운 전환
    document.getElementById('chartViewport').addEventListener('wheel', function(e) {
        if (e.ctrlKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -CONFIG.ZOOM_STEP : CONFIG.ZOOM_STEP;
            const newZoom = Math.max(CONFIG.ZOOM_MIN, Math.min(CONFIG.ZOOM_MAX, OrgChartState.zoomLevel + delta));
            
            // Dense 모드 전환 임계값 근처에서 부드러운 전환
            const wasInDenseMode = OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD;
            const willBeInDenseMode = newZoom < CONFIG.ZOOM_DENSE_THRESHOLD;
            
            if (wasInDenseMode !== willBeInDenseMode) {
                console.log(`Switching node mode: ${willBeInDenseMode ? 'Dense' : 'Normal'} at zoom ${newZoom}%`);
            }
            
            updateZoom(newZoom);
        }
    });
}

// 키보드 내비게이션 설정
function setupKeyboardNavigation() {
    document.addEventListener('keydown', function(e) {
        if (OrgChartState.focusedNode) {
            const node = OrgChartState.nodes.get(OrgChartState.focusedNode);
            if (!node) return;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    navigateToSibling(node, -1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    navigateToSibling(node, 1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (node.hasChildren && !OrgChartState.expandedNodes.has(node.id)) {
                        toggleNode(node.id);
                    } else if (node.children && node.children.length > 0) {
                        focusNode(node.children[0]);
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (OrgChartState.expandedNodes.has(node.id)) {
                        toggleNode(node.id);
                    } else if (node.parentId) {
                        focusNode(node.parentId);
                    }
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (node.hasChildren) {
                        toggleNode(node.id);
                    }
                    break;
                case '/':
                    e.preventDefault();
                    document.getElementById('orgSearch').focus();
                    break;
            }
        }
    });
}

// 초기 데이터 로드
async function loadInitialData() {
    showLoading(true);
    
    try {
        // API에서 초기 2레벨 데이터 로드
        const response = await fetch('/employees/api/org/root?depth=5');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        console.log('Loaded org data:', data); // 디버깅용
        
        // 노드 생성 및 렌더링
        processOrgData(data);
        calculateLayout();  // 레이아웃 계산 추가
        renderChart();
        
    } catch (error) {
        console.error('Failed to load organization data:', error);
        showError('조직 데이터를 불러오는데 실패했습니다.');
    } finally {
        showLoading(false);
    }
}

// 조직 데이터 처리 (버킷 클러스터링 적용)
function processOrgData(data) {
    // 형제 노드 버킷 처리 함수
    function bucketSiblings(children, parentId, level) {
        if (!children || children.length === 0) return [];
        
        // BUCKET_THRESHOLD를 초과하면 버킷 그룹화
        if (children.length > CONFIG.BUCKET_THRESHOLD) {
            const visibleChildren = children.slice(0, CONFIG.BUCKET_THRESHOLD);
            const hiddenChildren = children.slice(CONFIG.BUCKET_THRESHOLD);
            const hiddenCount = hiddenChildren.length;
            
            // 클러스터 ID 생성
            const clusterId = `${parentId}-bucket-${Date.now()}`;
            
            // 숨겨진 노드들 저장
            OrgChartState.clusteredSiblings.set(clusterId, hiddenChildren);
            
            // 버킷 노드 생성
            const bucketNode = {
                id: clusterId,
                name: `+${hiddenCount} 더보기`,
                type: 'bucket',
                parentId: parentId,
                level: level,
                isCluster: true,
                hiddenChildren: hiddenChildren,
                hasChildren: false,
            };
            
            return [...visibleChildren, bucketNode];
        }
        
        return children;
    }
    
    // 재귀적으로 노드 처리
    function processNode(node, parentId = null, level = 0) {
        const processedNode = {
            ...node,
            parentId,
            level,
            x: 0,
            y: level * CONFIG.LEVEL_SPACING,
        };
        
        OrgChartState.nodes.set(node.id, processedNode);
        
        if (node.children && node.children.length > 0) {
            // 버킷 클러스터링 적용
            const bucketedChildren = bucketSiblings(node.children, node.id, level + 1);
            
            bucketedChildren.forEach(child => {
                if (child.isCluster) {
                    // 버킷 노드 처리
                    OrgChartState.nodes.set(child.id, child);
                } else {
                    // 일반 노드 처리
                    processNode(child, node.id, level + 1);
                }
            });
        }
    }
    
    processNode(data);
    
    // 레이아웃 계산
    calculateLayout();
}

// PDF 스타일 수평 확장 레이아웃 계산 (OK저축은행 조직도 형태)
function calculateLayout() {
    const levelMap = new Map();
    let maxDepth = 0;
    
    // Dense 모드 판별 - 줌 레벨과 뷰모드에 따라 결정
    const isDenseMode = OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD || 
                       OrgChartState.currentView === 'compact';
    
    // 노드 크기 설정 (Dense 모드일 때 초슬림 카드)
    const nodeWidth = isDenseMode ? CONFIG.NODE_WIDTH_DENSE : CONFIG.NODE_WIDTH;
    const nodeHeight = isDenseMode ? CONFIG.NODE_HEIGHT_DENSE : CONFIG.NODE_HEIGHT;  
    const siblingSpacing = isDenseMode ? CONFIG.SIBLING_SPACING_DENSE : CONFIG.SIBLING_SPACING;
    
    // 렌더링할 노드만 필터링
    const visibleNodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    console.log(`Layout calculation for ${visibleNodes.length} visible nodes`);
    
    // 실제 트리 깊이 계산 및 레벨별로 노드 그룹화
    function calculateDepth(node, depth = 0) {
        if (!shouldRenderNode(node)) return; // 렌더링하지 않을 노드는 스킵
        
        node.treeDepth = depth;
        maxDepth = Math.max(maxDepth, depth);
        
        if (!levelMap.has(depth)) {
            levelMap.set(depth, []);
        }
        levelMap.get(depth).push(node);
        
        // 자식 노드들의 깊이 계산
        visibleNodes.forEach(childNode => {
            if (childNode.parentId === node.id) {
                calculateDepth(childNode, depth + 1);
            }
        });
    }
    
    // 루트 노드부터 시작
    visibleNodes.forEach(node => {
        if (!node.parentId) {
            calculateDepth(node, 0);
        }
    });
    
    // PDF 스타일의 수평 확장 레이아웃 (충돌 방지 포함)
    levelMap.forEach((nodes, depth) => {
        if (depth === 0) {
            // 루트 노드(대표이사)는 상단 중앙에
            nodes.forEach(node => {
                node.x = 0;
                node.y = 50;
            });
        } else {
            // 각 레벨의 노드들을 수평으로 배치 (부모 중심으로)
            const levelY = 50 + depth * (nodeHeight + CONFIG.LEVEL_SPACING);
            
            // 부모별로 그룹화
            const parentGroups = new Map();
            nodes.forEach(node => {
                const parentId = node.parentId;
                if (!parentGroups.has(parentId)) {
                    parentGroups.set(parentId, []);
                }
                parentGroups.get(parentId).push(node);
            });
            
            // 각 부모 그룹의 자식들을 배치
            parentGroups.forEach((children, parentId) => {
                const parent = OrgChartState.nodes.get(parentId);
                if (!parent) return;
                
                // 자식들의 총 너비 계산
                const totalWidth = children.length * (nodeWidth + siblingSpacing) - siblingSpacing;
                const startX = parent.x - (totalWidth / 2);
                
                // 각 자식 노드 배치
                children.forEach((child, index) => {
                    child.x = startX + index * (nodeWidth + siblingSpacing) + (nodeWidth / 2);
                    child.y = levelY;
                    console.log(`Placed ${child.name} at x=${child.x}, y=${child.y} (parent: ${parent.name} at x=${parent.x})`);
                });
            });
            
            // 겹침 방지를 위한 충돌 감지 및 조정
            // 같은 Y 레벨의 노드들을 그룹화
            const sameLevelNodes = nodes.filter(n => Math.abs(n.y - levelY) < 1);
            
            if (sameLevelNodes.length > 1) {
                // X 좌표 기준으로 정렬
                sameLevelNodes.sort((a, b) => a.x - b.x);
                
                // 겹침 해결
                for (let i = 1; i < sameLevelNodes.length; i++) {
                    const prev = sameLevelNodes[i - 1];
                    const curr = sameLevelNodes[i];
                    const minDistance = nodeWidth + siblingSpacing;
                    
                    if (curr.x - prev.x < minDistance) {
                        // 겹침 발생 - 오른쪽으로 이동
                        const shift = minDistance - (curr.x - prev.x);
                        console.log(`Collision detected: moving ${curr.name} by ${shift}px`);
                        for (let j = i; j < sameLevelNodes.length; j++) {
                            sameLevelNodes[j].x += shift;
                        }
                    }
                }
            }
        }
    });
    
    // 엣지 생성 (직선 연결)
    OrgChartState.edges = [];
    OrgChartState.nodes.forEach(node => {
        if (node.parentId) {
            const parent = OrgChartState.nodes.get(node.parentId);
            if (parent) {
                OrgChartState.edges.push({
                    source: parent,
                    target: node,
                    type: 'straight' // PDF처럼 직선 연결
                });
            }
        }
    });
}

// 차트 렌더링
function renderChart() {
    console.log('Rendering chart. Current view:', OrgChartState.currentView, 'Current level:', OrgChartState.currentLevel);
    
    const container = document.getElementById('treeContainer');
    if (!container) {
        console.error('Tree container not found!');
        return;
    }
    
    container.innerHTML = '';
    
    // 렌더링할 노드 수 확인
    const visibleNodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    console.log(`Rendering ${visibleNodes.length} visible nodes out of ${OrgChartState.nodes.size} total nodes`);
    
    // 뷰 모드에 따른 특화된 렌더링
    if (OrgChartState.currentView === 'grid') {
        renderGridView();
    } else if (OrgChartState.currentView === 'radial') {
        renderRadialView();
    } else if (OrgChartState.currentView === 'compact') {
        renderCompactView();
    } else {
        // 기본 세로형 뷰
        renderVerticalView();
    }
}

// 세로형 뷰 렌더링
function renderVerticalView() {
    const container = document.getElementById('treeContainer');
    const viewport = document.getElementById('chartViewport');
    const viewportWidth = viewport.offsetWidth;
    
    // Dense 모드 판별 (줌 < 95% 또는 Compact Dense 뷰)
    const isDenseMode = OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD || 
                        OrgChartState.currentView === 'compact';
    const nodeWidth = isDenseMode ? CONFIG.NODE_WIDTH_DENSE : CONFIG.NODE_WIDTH;
    const nodeHeight = isDenseMode ? CONFIG.NODE_HEIGHT_DENSE : CONFIG.NODE_HEIGHT;
    
    // 컨테이너 최소 크기 설정
    let minX = 0, maxX = 0, maxY = 0;
    
    // 노드 위치 범위 계산
    OrgChartState.nodes.forEach(node => {
        if (shouldRenderNode(node)) {
            minX = Math.min(minX, node.x);
            maxX = Math.max(maxX, node.x);
            maxY = Math.max(maxY, node.y);
        }
    });
    
    // 컨테이너 크기 설정
    const containerWidth = Math.max(viewportWidth, (maxX - minX) + nodeWidth + 200);
    const containerHeight = maxY + nodeHeight + 200;
    
    container.style.width = `${containerWidth}px`;
    container.style.height = `${containerHeight}px`;
    
    // 중앙 정렬 오프셋
    const offsetX = containerWidth / 2;
    
    // 노드 렌더링 (Dense 또는 Normal 모드)
    OrgChartState.nodes.forEach(node => {
        if (shouldRenderNode(node)) {
            // Dense 모드일 때는 createDenseNodeElement 사용
            const nodeElement = isDenseMode ? 
                createDenseNodeElement(node) : 
                createNodeElement(node);
            
            nodeElement.style.left = `${offsetX + node.x - nodeWidth / 2}px`;
            nodeElement.style.top = `${node.y + 50}px`; // 상단 여백
            container.appendChild(nodeElement);
        }
    });
    
    // 엣지 렌더링
    OrgChartState.edges.forEach(edge => {
        if (shouldRenderEdge(edge)) {
            const edgeElement = createEdgeElement(edge, offsetX);
            container.appendChild(edgeElement);
        }
    });
    
    // 초기 줌 설정 - 팀 레벨일 때 자동 축소
    if (OrgChartState.currentLevel === 'team') {
        updateZoom(50); // 50% 로 자동 축소
    }
}

// 그리드 뷰 렌더링
function renderGridView() {
    const container = document.getElementById('treeContainer');
    const nodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    const cols = 4;
    
    nodes.forEach((node, index) => {
        const row = Math.floor(index / cols);
        const col = index % cols;
        const nodeElement = createGridNodeElement(node);
        nodeElement.style.left = `${col * 250 + 50}px`;
        nodeElement.style.top = `${row * 180 + 50}px`;
        container.appendChild(nodeElement);
    });
}

// 방사형 뷰 렌더링
function renderRadialView() {
    const container = document.getElementById('treeContainer');
    const viewportWidth = document.getElementById('chartViewport').offsetWidth;
    const viewportHeight = document.getElementById('chartViewport').offsetHeight;
    const centerX = viewportWidth / 2;
    const centerY = viewportHeight / 2;
    
    // 중앙에 루트 노드
    const rootNode = OrgChartState.nodes.get('root');
    if (rootNode && shouldRenderNode(rootNode)) {
        const rootElement = createNodeElement(rootNode);
        rootElement.style.left = `${centerX - CONFIG.NODE_WIDTH / 2}px`;
        rootElement.style.top = `${centerY - CONFIG.NODE_HEIGHT / 2}px`;
        container.appendChild(rootElement);
        
        // 자식 노드들을 원형으로 배치
        const children = Array.from(OrgChartState.nodes.values())
            .filter(n => n.parentId === 'root' && shouldRenderNode(n));
        
        const angleStep = (2 * Math.PI) / children.length;
        const radius = 250;
        
        children.forEach((child, index) => {
            const angle = index * angleStep - Math.PI / 2;
            const x = centerX + radius * Math.cos(angle) - CONFIG.NODE_WIDTH / 2;
            const y = centerY + radius * Math.sin(angle) - CONFIG.NODE_HEIGHT / 2;
            
            const childElement = createNodeElement(child);
            childElement.style.left = `${x}px`;
            childElement.style.top = `${y}px`;
            container.appendChild(childElement);
        });
    }
}

// 컴팩트 뷰 렌더링
function renderCompactView() {
    const container = document.getElementById('treeContainer');
    const nodes = Array.from(OrgChartState.nodes.values()).filter(shouldRenderNode);
    
    let y = 20;
    nodes.forEach(node => {
        const nodeElement = createCompactNodeElement(node);
        nodeElement.style.left = `20px`;
        nodeElement.style.top = `${y}px`;
        nodeElement.style.width = 'calc(100% - 40px)';
        container.appendChild(nodeElement);
        y += 50;
    });
}

// 노드 렌더링 여부 확인
function shouldRenderNode(node) {
    // 레벨 필터가 활성화된 경우 먼저 확인
    if (OrgChartState.currentLevel !== 'all') {
        console.log(`Filtering node ${node.name} (type: ${node.type}) with filter: ${OrgChartState.currentLevel}`);
        
        let shouldShow = false;
        switch(OrgChartState.currentLevel) {
            case 'executive':
                // 임원급만 표시 (회사, 본부)
                shouldShow = node.type === 'company' || node.type === 'division';
                break;
            case 'division':
                // 본부급까지만 표시
                shouldShow = node.type === 'company' || node.type === 'division';
                break;
            case 'department':
                // 부서급까지 표시
                shouldShow = node.type === 'company' || node.type === 'division' || node.type === 'department';
                break;
            case 'team':
                // 팀급까지 표시 - 모든 상위 조직 포함
                shouldShow = true; // 모든 노드를 표시
                break;
            default:
                shouldShow = true;
        }
        
        console.log(`Node ${node.name} - Level Filter Show: ${shouldShow}`);
        
        // 레벨 필터에서 보여야 하는 노드면 부모 체인도 자동 확장
        if (shouldShow) {
            ensureParentChainExpanded(node);
            return true;
        } else {
            return false;
        }
    }
    
    // Progressive Disclosure: 펼쳐진 부모의 자식만 표시
    if (node.parentId) {
        const parent = OrgChartState.nodes.get(node.parentId);
        if (!parent) {
            console.log(`Node ${node.name} hidden - parent ${node.parentId} not found`);
            return false;
        }
        
        // 상위 노드가 확장되지 않은 경우에만 숨김
        if (!OrgChartState.expandedNodes.has(node.parentId)) {
            console.log(`Node ${node.name} hidden - parent ${node.parentId} not expanded`);
            return false;
        }
    }
    
    // 노드가 화면 범위를 벗어났는지 체크 (디버깅용)
    if (node.x !== undefined && node.y !== undefined) {
        if (Math.abs(node.x) > 5000 || node.y > 5000) {
            console.warn(`Node ${node.name} is out of bounds: x=${node.x}, y=${node.y}`);
        }
    }
    
    return true;
}

// 부모 체인을 자동으로 확장
function ensureParentChainExpanded(node) {
    let currentNode = node;
    const nodesToExpand = [];
    
    // 루트까지 부모 체인을 추적
    while (currentNode.parentId) {
        const parent = OrgChartState.nodes.get(currentNode.parentId);
        if (parent) {
            nodesToExpand.push(parent.id);
            currentNode = parent;
        } else {
            break;
        }
    }
    
    // 모든 부모 노드를 확장된 상태로 설정
    nodesToExpand.forEach(nodeId => {
        OrgChartState.expandedNodes.add(nodeId);
        console.log(`Auto-expanded parent node: ${nodeId}`);
    });
}

// 엣지 렌더링 여부 확인
function shouldRenderEdge(edge) {
    return shouldRenderNode(edge.source) && shouldRenderNode(edge.target);
}

// 그리드 뷰용 노드 엘리먼트
function createGridNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node grid-node';
    div.id = `node-grid-${node.id}`;
    
    const badgeClass = `node-type-badge ${node.type}`;
    div.innerHTML = `
        <div class="node-header">
            <span class="${badgeClass}">${getNodeTypeLabel(node.type)}</span>
        </div>
        <div class="node-content">
            <div class="node-name">${node.name}</div>
            <div class="node-stats">
                <div class="node-stat">
                    <i class="fas fa-users node-stat-icon"></i>
                    <span>${node.headcount || 0}명</span>
                </div>
            </div>
        </div>
    `;
    
    div.addEventListener('click', () => focusNode(node.id));
    return div;
}

// 컴팩트 뷰용 노드 엘리먼트
function createCompactNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node compact-node';
    div.id = `node-compact-${node.id}`;
    div.style.cssText = 'display: flex; align-items: center; padding: 0.5rem 1rem; min-width: auto;';
    
    div.innerHTML = `
        <span class="node-type-badge ${node.type}" style="margin-right: 1rem;">${getNodeTypeLabel(node.type)}</span>
        <span style="flex: 1; color: white; font-weight: 500;">${node.name}</span>
        <span style="color: #94a3b8; font-size: 0.875rem;">${node.headcount || 0}명</span>
    `;
    
    div.addEventListener('click', () => focusNode(node.id));
    return div;
}

// DenseTallNode 엘리먼트 생성 (초슬림 세로 카드)
function createDenseNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node dense-node';
    div.id = `node-${node.id}`;
    div.setAttribute('role', 'treeitem');
    div.setAttribute('aria-expanded', OrgChartState.expandedNodes.has(node.id));
    div.setAttribute('aria-level', node.level);
    div.tabIndex = 0;
    
    if (node.id === OrgChartState.focusedNode) {
        div.classList.add('focused');
    }
    
    if (!OrgChartState.expandedNodes.has(node.id) && node.hasChildren) {
        div.classList.add('collapsed');
    }
    
    // Dense 모드에서는 40px 초슬림 카드로 고정
    div.style.cssText = `
        position: absolute;
        left: ${node.x}px;
        top: ${node.y}px;
        width: ${CONFIG.NODE_WIDTH_DENSE}px;
        height: auto;
        min-height: 160px;
        max-height: 240px;
        padding: 0.125rem;
        background: rgba(14, 23, 40, 0.95);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(0, 212, 255, 0.4);
        border-radius: 0.375rem;
        transition: all 0.2s ease;
        cursor: pointer;
        z-index: ${node.type === 'company' ? '100' : '10'};
        overflow: hidden;
    `;
    
    // 버킷 노드 특별 처리
    if (node.isCluster || node.type === 'bucket') {
        // 클러스터는 더 작은 크기로 재설정
        div.style.width = '80px';
        div.style.height = '80px';
        div.style.minHeight = '80px';
        div.innerHTML = `
            <div style="
                width: 100%;
                height: 100%;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(0, 212, 255, 0.4);
                border-radius: 0.75rem;
                display: flex;
                align-items: center;
                justify-content: center;
                color: #00d4ff;
                font-size: 0.75rem;
                cursor: pointer;
                transition: all 0.3s ease;
                writing-mode: vertical-rl;
                text-orientation: mixed;
            " onmouseover="this.style.borderColor='#00d4ff'; this.style.background='rgba(0, 212, 255, 0.1)'"
               onmouseout="this.style.borderColor='rgba(0, 212, 255, 0.4)'; this.style.background='rgba(255, 255, 255, 0.05)'">
                ${node.name}
            </div>
        `;
        div.addEventListener('click', () => expandCluster(node.id));
    } else {
        // DenseTallNode 콘텐츠 (세로 글자)
        const headcount = node.headcount || 0;
        const childrenCount = node.childrenCount || 0;
        const typeColor = {
            'company': 'from-cyan-500',
            'division': 'from-fuchsia-500',
            'department': 'from-teal-500',
            'team': 'from-slate-500',
            'person': 'from-amber-500'
        }[node.type] || 'from-cyan-500';
        
        div.innerHTML = `
            <!-- 타입 표시 라인 -->
            <div class="node-spine ${node.type}" style="
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                width: 6px;
                background: linear-gradient(to bottom, ${typeColor}, transparent);
                opacity: 0.7;
                border-radius: 1rem 0 0 1rem;
            "></div>
            
            <!-- 노드 콘텐츠 (세로 글자) - 초슬림 스펙 -->
            <div class="node-content" style="
                margin-left: 4px;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
                height: 100%;
                padding: 0.25rem 0.125rem;
            ">
                <!-- 이름 (세로 글자 - CJK 최적화) -->
                <div class="vertical-cjk" style="
                    font-size: 11px;
                    font-weight: 600;
                    color: rgba(255, 255, 255, 0.9);
                    line-height: 1.1;
                    flex: 1;
                    max-height: 200px;
                    overflow: hidden;
                ">${node.name}</div>
                
                <!-- 통계 (세로) - 미니말 -->
                <div style="display: flex; flex-direction: column; gap: 0.1rem;">
                    <div class="v-chip" style="padding: 0.1rem; font-size: 9px;">${headcount}</div>
                    <div class="v-chip" style="padding: 0.1rem; font-size: 9px;">${childrenCount}</div>
                </div>
            </div>
            
            <!-- 접기/펼치기 버튼 -->
            ${node.hasChildren ? `
                <button class="node-toggle" aria-label="${OrgChartState.expandedNodes.has(node.id) ? '접기' : '펼치기'}" style="
                    position: absolute;
                    bottom: -12px;
                    left: 50%;
                    transform: translateX(-50%);
                ">
                    <i class="fas fa-chevron-${OrgChartState.expandedNodes.has(node.id) ? 'up' : 'down'}"></i>
                </button>
            ` : ''}
        `;
        
        // 이벤트 리스너
        div.addEventListener('click', () => focusNode(node.id));
        
        const toggleBtn = div.querySelector('.node-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleNode(node.id);
            });
        }
    }
    
    return div;
}

// TallNode 엘리먼트 생성 (세로 길쭉한 카드)
function createNodeElement(node) {
    const div = document.createElement('div');
    div.className = 'org-node';
    div.id = `node-${node.id}`;
    div.setAttribute('role', 'treeitem');
    div.setAttribute('aria-expanded', OrgChartState.expandedNodes.has(node.id));
    div.setAttribute('aria-level', node.level);
    div.tabIndex = 0;
    
    if (node.id === OrgChartState.focusedNode) {
        div.classList.add('focused');
    }
    
    if (!OrgChartState.expandedNodes.has(node.id) && node.hasChildren) {
        div.classList.add('collapsed');
    }
    
    // 버킷 노드 특별 처리
    if (node.isCluster || node.type === 'bucket') {
        div.style.cssText = 'width: 120px; height: 80px; min-height: 80px;';
        div.innerHTML = `
            <div style="
                width: 100%;
                height: 100%;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(0, 212, 255, 0.4);
                border-radius: 0.75rem;
                display: flex;
                align-items: center;
                justify-content: center;
                color: #00d4ff;
                font-size: 0.875rem;
                cursor: pointer;
                transition: all 0.3s ease;
            " onmouseover="this.style.borderColor='#00d4ff'; this.style.background='rgba(0, 212, 255, 0.1)'"
               onmouseout="this.style.borderColor='rgba(0, 212, 255, 0.4)'; this.style.background='rgba(255, 255, 255, 0.05)'">
                ${node.name}
            </div>
        `;
        div.addEventListener('click', () => expandCluster(node.id));
    } else {
        // TallNode 콘텐츠 (일반 가로 글자 노드) - 180px 폭
        const headcount = node.headcount || 0;
        const childrenCount = node.childrenCount || 0;
        const badges = node.badges || [];
        
        div.innerHTML = `
            <!-- 왼쪽 세로 spine (타입 표시) -->
            <div class="node-spine ${node.type}"></div>
            
            <!-- 노드 콘텐츠 (가로 글자) -->
            <div class="node-content">
                <!-- 이름 (3줄 클램프) -->
                <div class="node-name">${node.name}</div>
                
                <!-- 직급/타이틀 (2줄 클램프) -->
                ${node.title ? `<div class="node-title">${node.title}</div>` : ''}
                
                <!-- 통계 그리드 -->
                <div class="node-stats">
                    <div class="node-stat">인원 ${headcount}</div>
                    <div class="node-stat">하위 ${childrenCount}</div>
                </div>
                
                <!-- 배지 (최대 3개 표시) -->
                ${badges.length > 0 ? `
                    <div class="node-badges">
                        ${badges.slice(0, 3).map(badge => 
                            `<span class="node-badge">${badge}</span>`
                        ).join('')}
                        ${badges.length > 3 ? 
                            `<span class="node-badge">+${badges.length - 3}</span>` : ''
                        }
                    </div>
                ` : ''}
                
                <!-- 접힌 상태에서 하위 조직 정보 -->
                ${!OrgChartState.expandedNodes.has(node.id) && node.hasChildren ? `
                    <div class="node-children-info" style="
                        margin-top: 0.5rem;
                        padding-top: 0.5rem;
                        border-top: 1px solid rgba(0, 212, 255, 0.1);
                        font-size: 0.813rem;
                        color: #00d4ff;
                    ">
                        <i class="fas fa-chevron-down"></i> ${childrenCount}개 하위 조직
                    </div>
                ` : ''}
            </div>
            
            <!-- 접기/펼치기 버튼 -->
            ${node.hasChildren ? `
                <button class="node-toggle" aria-label="${OrgChartState.expandedNodes.has(node.id) ? '접기' : '펼치기'}">
                    <i class="fas fa-chevron-${OrgChartState.expandedNodes.has(node.id) ? 'up' : 'down'}"></i>
                </button>
            ` : ''}
        `;
        
        // 이벤트 리스너
        div.addEventListener('click', () => focusNode(node.id));
        
        const toggleBtn = div.querySelector('.node-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleNode(node.id);
            });
        }
    }
    
    return div;
}

// 엣지 엘리먼트 생성 (직각 연결선 지원)
function createEdgeElement(edge, centerX) {
    const container = document.createElement('div');
    container.className = 'edge-container';
    container.style.position = 'absolute';
    container.style.pointerEvents = 'none';
    
    // Dense 모드 판별
    const isDenseMode = OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD || 
                        OrgChartState.currentView === 'compact';
    const nodeHeight = isDenseMode ? CONFIG.NODE_HEIGHT_DENSE : CONFIG.NODE_HEIGHT;
    
    const sourceX = centerX + edge.source.x;
    const sourceY = edge.source.y + nodeHeight - 20; // 노드 하단
    const targetX = centerX + edge.target.x;
    const targetY = edge.target.y + 20; // 노드 상단
    
    if (edge.type === 'orthogonal' && sourceX !== targetX) {
        // 직각 연결선 (ㄱ자 형태)
        const midY = sourceY + (targetY - sourceY) / 2;
        
        // 수직선 1 (부모에서 아래로)
        const vLine1 = document.createElement('div');
        vLine1.className = 'org-edge';
        vLine1.style.left = `${sourceX - 1}px`;
        vLine1.style.top = `${sourceY}px`;
        vLine1.style.height = `${midY - sourceY}px`;
        vLine1.style.width = '2px';
        container.appendChild(vLine1);
        
        // 수평선 (좌우 연결)
        const hLine = document.createElement('div');
        hLine.className = 'org-edge horizontal';
        hLine.style.left = `${Math.min(sourceX, targetX)}px`;
        hLine.style.top = `${midY - 1}px`;
        hLine.style.width = `${Math.abs(targetX - sourceX)}px`;
        hLine.style.height = '2px';
        container.appendChild(hLine);
        
        // 수직선 2 (자식으로 연결)
        const vLine2 = document.createElement('div');
        vLine2.className = 'org-edge';
        vLine2.style.left = `${targetX - 1}px`;
        vLine2.style.top = `${midY}px`;
        vLine2.style.height = `${targetY - midY}px`;
        vLine2.style.width = '2px';
        container.appendChild(vLine2);
    } else {
        // 일직선 연결 (부모와 자식이 같은 X 위치)
        const vLine = document.createElement('div');
        vLine.className = 'org-edge';
        vLine.style.left = `${sourceX - 1}px`;
        vLine.style.top = `${sourceY}px`;
        vLine.style.height = `${targetY - sourceY}px`;
        vLine.style.width = '2px';
        container.appendChild(vLine);
    }
    
    return container;
}

// 노드 타입 레이블
function getNodeTypeLabel(type) {
    const labels = {
        'company': '회사',
        'division': '본부',
        'department': '부서',
        'team': '팀',
        'person': '직원',
    };
    return labels[type] || type;
}

// 노드 토글
async function toggleNode(nodeId) {
    const node = OrgChartState.nodes.get(nodeId);
    if (!node || !node.hasChildren) return;
    
    if (OrgChartState.expandedNodes.has(nodeId)) {
        // 접기
        OrgChartState.expandedNodes.delete(nodeId);
        console.log(`Collapsed node: ${nodeId}`);
    } else {
        // 펼치기
        OrgChartState.expandedNodes.add(nodeId);
        console.log(`Expanded node: ${nodeId}`);
        
        // Lazy Load: 자식이 없으면 서버에서 로드
        if (!node.children || node.children.length === 0) {
            await loadNodeChildren(nodeId);
        }
    }
    
    // 레이아웃 재계산 필수 (특히 팀 레벨)
    calculateLayout();
    renderChart();
}

// 노드 자식 로드 (Lazy Loading)
async function loadNodeChildren(nodeId, depth = 1) {
    try {
        const response = await fetch(`/employees/api/org/node/${nodeId}?depth=${depth}`);
        
        // 응답 상태 확인
        if (!response.ok) {
            console.error(`HTTP Error: ${response.status} ${response.statusText}`);
            return;
        }
        
        const data = await response.json();
        
        // 에러 응답 확인
        if (data.error) {
            console.error('API Error:', data.error);
            return;
        }
        
        const node = OrgChartState.nodes.get(nodeId);
        if (node && data.children) {
            node.children = data.children;
            processOrgData({ ...node, children: data.children });
            calculateLayout();
            console.log(`Successfully loaded ${data.children.length} children for node ${nodeId} with depth ${depth}`);
        } else {
            console.log(`No children found for node ${nodeId}`);
        }
    } catch (error) {
        console.error('Failed to load node children:', error);
        console.error('Node ID:', nodeId);
    }
}

// 특정 깊이까지 노드 확장 (expandToDepth) - 큐 기반 BFS 최적화
async function expandToDepth(rootId, targetDepth = 3) {
    console.log(`🔄 Expanding node ${rootId} to depth ${targetDepth} - Dense mode test`);
    
    showLoading(true);
    
    // BFS 큐 방식으로 최적화
    const queue = [{ id: rootId, depth: 0 }];
    const seen = new Set([rootId]);
    const pagesToLoad = [];
    
    while (queue.length > 0) {
        const { id, depth } = queue.shift();
        
        if (depth >= targetDepth) continue;
        
        const node = OrgChartState.nodes.get(id);
        if (!node) continue;
        
        // 노드 확장 상태 설정
        if (node.hasChildren) {
            OrgChartState.expandedNodes.add(id);
        }
        
        // 자식이 없으면 로드 예약
        if (node.hasChildren && (!node.children || node.children.length === 0)) {
            pagesToLoad.push({ id, depth });
        }
        
        // 이미 로드된 자식들을 큐에 추가
        OrgChartState.nodes.forEach(childNode => {
            if (childNode.parentId === id && !seen.has(childNode.id)) {
                seen.add(childNode.id);
                queue.push({ id: childNode.id, depth: depth + 1 });
            }
        });
    }
    
    // 병렬로 필요한 노드들 로드
    if (pagesToLoad.length > 0) {
        const loadPromises = pagesToLoad.map(({ id }) => loadNodeChildren(id, 1));
        await Promise.all(loadPromises);
        
        // 로드된 노드들도 확장 상태로 설정
        pagesToLoad.forEach(({ id, depth }) => {
            if (depth < targetDepth - 1) {
                const node = OrgChartState.nodes.get(id);
                if (node && node.children) {
                    // 새로 로드된 자식들도 확장
                    OrgChartState.nodes.forEach(childNode => {
                        if (childNode.parentId === id && childNode.hasChildren) {
                            OrgChartState.expandedNodes.add(childNode.id);
                        }
                    });
                }
            }
        });
    }
    
    showLoading(false);
    
    // 확장 후 상태 체크
    console.log(`📊 Current zoom: ${OrgChartState.zoomLevel}% (Dense mode: ${OrgChartState.zoomLevel < CONFIG.ZOOM_DENSE_THRESHOLD})`);
    
    // 확장 후 Dense 모드 강제 확인 (초슬림 카드 테스트용)
    if (OrgChartState.zoomLevel >= CONFIG.ZOOM_DENSE_THRESHOLD) {
        console.log('🔥 Forcing Dense mode for ultra-slim cards verification');
        updateZoom(80); // Dense 모드 강제 활성화
        return; // updateZoom에서 이미 렌더링됨
    }
    
    // 레이아웃 재계산 및 렌더링
    calculateLayout();
    
    // 그래프 검증
    const validation = validateGraph(OrgChartState.edges);
    if (!validation.isValid) {
        console.warn('Graph validation issues detected:', validation);
    }
    
    renderChart();
}

// 노드 포커스
function focusNode(nodeId) {
    OrgChartState.focusedNode = nodeId;
    
    // 모든 노드에서 포커스 클래스 제거
    document.querySelectorAll('.org-node').forEach(el => {
        el.classList.remove('focused');
    });
    
    // 새 노드에 포커스 클래스 추가
    const nodeElement = document.getElementById(`node-${nodeId}`);
    if (nodeElement) {
        nodeElement.classList.add('focused');
        nodeElement.focus();
        
        // 브레드크럼 업데이트
        updateBreadcrumb(nodeId);
        
        // 포커스 경로 펼치기
        expandPath(nodeId);
        
        // 스크롤 조정
        nodeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

// 경로 펼치기 (포커스된 노드까지)
function expandPath(nodeId) {
    const node = OrgChartState.nodes.get(nodeId);
    if (!node) return;
    
    const path = [];
    let current = node;
    while (current) {
        path.unshift(current.id);
        current = current.parentId ? OrgChartState.nodes.get(current.parentId) : null;
    }
    
    // 경로상의 모든 노드 펼치기
    path.forEach(id => {
        if (!OrgChartState.expandedNodes.has(id)) {
            const n = OrgChartState.nodes.get(id);
            if (n && n.hasChildren) {
                OrgChartState.expandedNodes.add(id);
            }
        }
    });
    
    renderChart();
}

// 브레드크럼 업데이트
function updateBreadcrumb(nodeId) {
    const breadcrumb = document.getElementById('breadcrumbNav');
    const node = OrgChartState.nodes.get(nodeId);
    if (!node) return;
    
    const path = [];
    let current = node;
    while (current) {
        path.unshift(current);
        current = current.parentId ? OrgChartState.nodes.get(current.parentId) : null;
    }
    
    breadcrumb.innerHTML = path.map((n, index) => `
        <span class="breadcrumb-item ${index === path.length - 1 ? 'active' : ''}" 
              onclick="focusNode('${n.id}')">
            ${n.name}
        </span>
        ${index < path.length - 1 ? '<span class="breadcrumb-separator">›</span>' : ''}
    `).join('');
}

// 형제 노드 탐색
function navigateToSibling(node, direction) {
    if (!node.parentId) return;
    
    const parent = OrgChartState.nodes.get(node.parentId);
    if (!parent || !parent.children) return;
    
    const currentIndex = parent.children.findIndex(c => c.id === node.id);
    if (currentIndex === -1) return;
    
    const newIndex = currentIndex + direction;
    if (newIndex >= 0 && newIndex < parent.children.length) {
        focusNode(parent.children[newIndex].id);
    }
}

// 검색 수행
async function performSearch(query) {
    OrgChartState.searchQuery = query;
    
    if (!query || query.length < 2) {
        document.getElementById('searchAutocomplete').classList.remove('active');
        return;
    }
    
    try {
        const response = await fetch(`/employees/api/org/search?q=${encodeURIComponent(query)}`);
        const results = await response.json();
        
        showSearchResults(results);
    } catch (error) {
        console.error('Search failed:', error);
    }
}

// 검색 결과 표시
function showSearchResults(data) {
    const autocomplete = document.getElementById('searchAutocomplete');
    
    // API 응답에서 results 배열 추출
    const results = data.results || data;
    
    if (!results || results.length === 0) {
        autocomplete.classList.remove('active');
        return;
    }
    
    autocomplete.innerHTML = results.slice(0, 10).map(result => `
        <div class="autocomplete-item" onclick="selectSearchResult('${result.id}')">
            <div class="autocomplete-item-name">${result.name}</div>
            <div class="autocomplete-item-path">${result.path.join(' › ')}</div>
        </div>
    `).join('');
    
    autocomplete.classList.add('active');
}

// 검색 결과 선택
function selectSearchResult(nodeId) {
    document.getElementById('searchAutocomplete').classList.remove('active');
    document.getElementById('orgSearch').value = '';
    
    // 경로 펼치고 포커스
    expandPath(nodeId);
    focusNode(nodeId);
}

// 뷰 모드 변경
function updateViewMode(mode) {
    console.log('Updating view mode to:', mode);
    OrgChartState.currentView = mode;
    
    // 버튼 상태 업데이트
    document.querySelectorAll('.view-mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    
    // 뷰에 따른 레이아웃 재계산
    if (mode === 'vertical') {
        calculateLayout();
    } else if (mode === 'radial') {
        calculateRadialLayout();
    } else if (mode === 'grid') {
        calculateGridLayout();
    } else if (mode === 'compact') {
        calculateCompactLayout();
    }
    
    console.log('Rendering chart with view mode:', mode);
    renderChart();
}

// 레벨 필터 업데이트
function updateLevelFilter(level) {
    console.log('Updating level filter to:', level);
    OrgChartState.currentLevel = level;
    
    // 버튼 상태 업데이트
    document.querySelectorAll('.level-filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.level === level);
    });
    
    // 레벨 필터 변경 시 expandedNodes 초기화하고 필요한 노드들만 확장
    if (level !== 'all') {
        OrgChartState.expandedNodes.clear();
        console.log('Cleared expandedNodes for level filtering');
        
        // 필터에 맞는 모든 노드들의 부모 체인을 미리 확장
        OrgChartState.nodes.forEach(node => {
            let shouldShow = false;
            switch(level) {
                case 'executive':
                    shouldShow = node.type === 'company' || node.type === 'division';
                    break;
                case 'division':
                    shouldShow = node.type === 'company' || node.type === 'division';
                    break;
                case 'department':
                    shouldShow = node.type === 'company' || node.type === 'division' || node.type === 'department';
                    break;
                case 'team':
                    shouldShow = node.type !== 'person';
                    break;
            }
            
            if (shouldShow) {
                ensureParentChainExpanded(node);
            }
        });
    } else {
        // 'all' 레벨인 경우 루트 노드만 확장된 상태로 초기화
        OrgChartState.expandedNodes.clear();
        OrgChartState.expandedNodes.add('OK금융그룹');
        console.log('Reset to default Progressive Disclosure mode');
    }
    
    console.log('Current state after level filter update:', OrgChartState.currentLevel);
    console.log('Expanded nodes:', Array.from(OrgChartState.expandedNodes));
    
    // 레벨에 따른 자동 줌 조정 (Dense 모드 활성화를 위해 95% 미만으로 설정)
    let autoZoom = 80;
    switch(level) {
        case 'executive':
            autoZoom = 90;   // 임원급은 90% (Dense 모드)
            break;
        case 'division':
            autoZoom = 85;   // 본부급은 85% (Dense 모드)
            break;
        case 'department':
            autoZoom = 70;   // 부서급은 70% (Dense 모드)
            break;
        case 'team':
            autoZoom = 50;   // 팀급은 50%로 축소 (Dense 모드)
            break;
        default:
            autoZoom = 80;   // 전체는 80% (Dense 모드)
    }
    
    updateZoom(autoZoom);
    renderChart();
}

// 줌 업데이트
function updateZoom(level) {
    OrgChartState.zoomLevel = level;
    document.getElementById('zoomLevel').textContent = `${level}%`;
    
    const container = document.getElementById('treeContainer');
    container.style.transform = `scale(${level / 100})`;
    
    // 시맨틱 줌 클래스 적용
    container.classList.remove('zoom-small', 'zoom-large');
    if (level < 80) {
        container.classList.add('zoom-small');
    } else if (level > 120) {
        container.classList.add('zoom-large');
    }
}

// 버킷 클러스터 확장 (버킷 클릭 시 숨겨진 노드 표시)
function expandCluster(clusterId) {
    const clusterNode = OrgChartState.nodes.get(clusterId);
    if (!clusterNode || !clusterNode.isCluster) return;
    
    const hiddenNodes = OrgChartState.clusteredSiblings.get(clusterId);
    if (!hiddenNodes || hiddenNodes.length === 0) return;
    
    console.log(`Expanding cluster ${clusterId} with ${hiddenNodes.length} hidden nodes`);
    
    // 부모 노드 찾기
    const parentNode = OrgChartState.nodes.get(clusterNode.parentId);
    if (!parentNode) return;
    
    // 클러스터 노드 제거
    OrgChartState.nodes.delete(clusterId);
    OrgChartState.clusteredSiblings.delete(clusterId);
    
    // 숨겨진 노드들을 노드 맵에 추가
    hiddenNodes.forEach(node => {
        const processedNode = {
            ...node,
            parentId: clusterNode.parentId,
            level: clusterNode.level,
            x: 0,
            y: clusterNode.level * CONFIG.LEVEL_SPACING,
        };
        OrgChartState.nodes.set(node.id, processedNode);
        
        // 자식 노드들도 재귀적으로 처리
        if (node.children && node.children.length > 0) {
            function processChildren(children, parentId, level) {
                children.forEach(child => {
                    const childNode = {
                        ...child,
                        parentId: parentId,
                        level: level,
                        x: 0,
                        y: level * CONFIG.LEVEL_SPACING,
                    };
                    OrgChartState.nodes.set(child.id, childNode);
                    
                    if (child.children) {
                        processChildren(child.children, child.id, level + 1);
                    }
                });
            }
            processChildren(node.children, node.id, clusterNode.level + 1);
        }
    });
    
    // 부모 노드가 확장되어 있는지 확인하고 설정
    if (!OrgChartState.expandedNodes.has(clusterNode.parentId)) {
        OrgChartState.expandedNodes.add(clusterNode.parentId);
    }
    
    // 레이아웃 재계산 및 렌더링
    calculateLayout();
    renderChart();
    
    // 스크롤 조정 (선택적)
    const parentElement = document.getElementById(`node-${clusterNode.parentId}`);
    if (parentElement) {
        parentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

// 로딩 표시
function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    overlay.style.display = show ? 'flex' : 'none';
}

// 에러 표시
function showError(message) {
    console.error(message);
    // 에러 메시지를 화면에 표시
    const viewport = document.getElementById('chartViewport');
    if (viewport && !document.getElementById('errorMessage')) {
        const errorDiv = document.createElement('div');
        errorDiv.id = 'errorMessage';
        errorDiv.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 0, 0, 0.1); color: #ff6b6b; padding: 1rem 2rem; border-radius: 0.5rem; border: 1px solid #ff6b6b;';
        errorDiv.textContent = message;
        viewport.appendChild(errorDiv);
        
        // 3초 후 에러 메시지 제거
        setTimeout(() => {
            errorDiv.remove();
        }, 3000);
    }
}

// 샘플 데이터 사용 (API 실패 시 백업)
function useSampleData() {
    const sampleData = {
        id: 'OK금융그룹',
        name: 'OK금융그룹',
        type: 'company',
        title: 'CEO',
        headcount: 1700,
        childrenCount: 5,
        hasChildren: true,
        parentId: null,
        path: ['OK금융그룹'],
        children: [
            {
                id: 'division-1',
                name: '경영지원본부',
                type: 'division',
                headcount: 320,
                childrenCount: 8,
                hasChildren: true,
                parentId: 'root',
                path: ['OK금융그룹', '경영지원본부'],
                children: [
                    {
                        id: 'dept-1-1',
                        name: '인사부',
                        type: 'department',
                        headcount: 45,
                        childrenCount: 2,
                        hasChildren: true,
                        parentId: 'division-1',
                        path: ['OK금융그룹', '경영지원본부', '인사부'],
                        children: [
                            {
                                id: 'team-1-1-1',
                                name: '채용팀',
                                type: 'team',
                                headcount: 12,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-1',
                                path: ['OK금융그룹', '경영지원본부', '인사부', '채용팀']
                            },
                            {
                                id: 'team-1-1-2',
                                name: '교육팀',
                                type: 'team',
                                headcount: 8,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-1',
                                path: ['OK금융그룹', '경영지원본부', '인사부', '교육팀']
                            }
                        ]
                    },
                    {
                        id: 'dept-1-2',
                        name: '재무부',
                        type: 'department',
                        headcount: 38,
                        childrenCount: 1,
                        hasChildren: true,
                        parentId: 'division-1',
                        path: ['OK금융그룹', '경영지원본부', '재무부'],
                        children: [
                            {
                                id: 'team-1-2-1',
                                name: '회계팀',
                                type: 'team',
                                headcount: 15,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-1-2',
                                path: ['OK금융그룹', '경영지원본부', '재무부', '회계팀']
                            }
                        ]
                    }
                ]
            },
            {
                id: 'division-2',
                name: 'IT본부',
                type: 'division',
                headcount: 450,
                childrenCount: 10,
                hasChildren: true,
                parentId: 'root',
                path: ['OK금융그룹', 'IT본부'],
                children: [
                    {
                        id: 'dept-2-1',
                        name: '개발부',
                        type: 'department',
                        headcount: 62,
                        childrenCount: 2,
                        hasChildren: true,
                        parentId: 'division-2',
                        path: ['OK금융그룹', 'IT본부', '개발부'],
                        children: [
                            {
                                id: 'team-2-1-1',
                                name: '프론트엔드팀',
                                type: 'team',
                                headcount: 18,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-1',
                                path: ['OK금융그룹', 'IT본부', '개발부', '프론트엔드팀']
                            },
                            {
                                id: 'team-2-1-2',
                                name: '백엔드팀',
                                type: 'team',
                                headcount: 25,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-1',
                                path: ['OK금융그룹', 'IT본부', '개발부', '백엔드팀']
                            }
                        ]
                    },
                    {
                        id: 'dept-2-2',
                        name: '인프라부',
                        type: 'department',
                        headcount: 35,
                        childrenCount: 1,
                        hasChildren: true,
                        parentId: 'division-2',
                        path: ['OK금융그룹', 'IT본부', '인프라부'],
                        children: [
                            {
                                id: 'team-2-2-1',
                                name: '클라우드팀',
                                type: 'team',
                                headcount: 12,
                                childrenCount: 0,
                                hasChildren: false,
                                parentId: 'dept-2-2',
                                path: ['OK금융그룹', 'IT본부', '인프라부', '클라우드팀']
                            }
                        ]
                    }
                ]
            },
            {
                id: 'division-3',
                name: '영업본부',
                type: 'division',
                headcount: 580,
                childrenCount: 15,
                hasChildren: true,
                parentId: 'root',
                path: ['OK금융그룹', '영업본부'],
                children: []
            }
        ]
    };
    
    showLoading(false);
    processOrgData(sampleData);
    calculateLayout();  // 레이아웃 계산 추가
    renderChart();
}

// 기타 레이아웃 계산 함수들 (간단한 구현)
function calculateRadialLayout() {
    console.log('Calculating radial layout...');
    // 방사형 레이아웃 계산 로직
    // 임시로 기본 레이아웃 사용
    calculateLayout();
}

function calculateGridLayout() {
    console.log('Calculating grid layout...');
    // 그리드 레이아웃 계산 로직
    const nodes = Array.from(OrgChartState.nodes.values());
    const cols = 4;
    let row = 0, col = 0;
    
    nodes.forEach((node, index) => {
        node.x = col * (CONFIG.NODE_WIDTH + CONFIG.SIBLING_SPACING) - (cols * CONFIG.NODE_WIDTH) / 2;
        node.y = row * (CONFIG.NODE_HEIGHT + 40);
        
        col++;
        if (col >= cols) {
            col = 0;
            row++;
        }
    });
}

function calculateCompactLayout() {
    console.log('Calculating compact layout...');
    // 컴팩트 레이아웃 계산 로직
    // 임시로 기본 레이아웃 사용
    calculateLayout();
}
</script>
{% endblock %}