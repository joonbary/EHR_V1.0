"""
GPT 기반 리더십 전략 어시스턴트
AI-powered leadership strategy assistant with natural language Q&A capabilities
Generated by: GPT-powered HR strategist + dashboard explainer
"""

from django.views import View
from django.views.generic import TemplateView
from django.http import JsonResponse, StreamingHttpResponse
from django.utils.decorators import method_decorator
from django.contrib.auth.decorators import login_required
from django.core.cache import cache
from django.db.models import Avg, Count, Q, F, Sum
from django.utils import timezone
import openai
import json
import re
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Generator
from dataclasses import dataclass, field
from enum import Enum
import pandas as pd
import numpy as np

# Import existing modules
from leader_kpi_dashboard import LeaderKPIAnalytics, KPICategory, TimeRange
from employees.models import Employee, Department
from certifications.models import GrowthLevelCertification, CertificationCheckLog
from trainings.models import TrainingEnrollment, TrainingCourse
from evaluations.models import Evaluation
from job_profiles.models import JobLevelProfile, LeaderRecommendation


class QueryIntent(Enum):
    """사용자 질문 의도 분류"""
    KPI_STATUS = "kpi_status"
    TREND_ANALYSIS = "trend_analysis"
    RECOMMENDATION = "recommendation"
    COMPARISON = "comparison"
    PREDICTION = "prediction"
    EXPLANATION = "explanation"
    ACTION_PLAN = "action_plan"
    GENERAL = "general"


class InsightLevel(Enum):
    """인사이트 수준"""
    EXECUTIVE = "executive"
    MANAGER = "manager"
    OPERATIONAL = "operational"


@dataclass
class AIResponse:
    """AI 응답 구조"""
    content: str
    data_sources: List[str] = field(default_factory=list)
    confidence: float = 0.0
    recommendations: List[Dict[str, Any]] = field(default_factory=list)
    visualizations: List[Dict[str, Any]] = field(default_factory=list)
    follow_up_questions: List[str] = field(default_factory=list)


class LeadershipAIAssistant:
    """리더십 전략 AI 어시스턴트"""
    
    def __init__(self, openai_api_key: str = None):
        self.openai_api_key = openai_api_key or settings.OPENAI_API_KEY
        openai.api_key = self.openai_api_key
        self.kpi_analytics = LeaderKPIAnalytics()
        self.cache_timeout = 600  # 10분 캐시
        
        # GPT 모델 설정
        self.model = "gpt-4"
        self.max_tokens = 2000
        self.temperature = 0.7
        
        # 시스템 프롬프트
        self.system_prompt = """
        You are an expert HR strategist and leadership development advisor. 
        You analyze KPI data and provide strategic insights for executive decision-making.
        
        Your responsibilities:
        1. Interpret leadership KPI data and trends
        2. Provide actionable recommendations for talent development
        3. Identify risks and opportunities in the leadership pipeline
        4. Suggest strategic interventions for improvement
        5. Answer questions in a clear, executive-appropriate manner
        
        Always base your responses on the provided data and maintain a professional, strategic tone.
        Respond in Korean when the query is in Korean.
        """
    
    def analyze_query(self, query: str, user_context: Dict[str, Any]) -> QueryIntent:
        """사용자 질문 의도 분석"""
        query_lower = query.lower()
        
        # 의도 분류 규칙
        if any(keyword in query_lower for keyword in ['현황', '상태', 'status', 'current', '지금']):
            return QueryIntent.KPI_STATUS
        elif any(keyword in query_lower for keyword in ['추세', '트렌드', 'trend', '변화', 'change']):
            return QueryIntent.TREND_ANALYSIS
        elif any(keyword in query_lower for keyword in ['추천', '제안', 'recommend', 'suggest', '어떻게']):
            return QueryIntent.RECOMMENDATION
        elif any(keyword in query_lower for keyword in ['비교', 'compare', 'versus', '대비']):
            return QueryIntent.COMPARISON
        elif any(keyword in query_lower for keyword in ['예측', '전망', 'predict', 'forecast', '미래']):
            return QueryIntent.PREDICTION
        elif any(keyword in query_lower for keyword in ['설명', '이유', 'explain', 'why', '왜']):
            return QueryIntent.EXPLANATION
        elif any(keyword in query_lower for keyword in ['계획', '전략', 'plan', 'strategy', '방안']):
            return QueryIntent.ACTION_PLAN
        else:
            return QueryIntent.GENERAL
    
    def get_relevant_data(self, query: str, intent: QueryIntent, 
                         department_id: Optional[str] = None) -> Dict[str, Any]:
        """질문과 관련된 데이터 수집"""
        data = {}
        
        # 기본 KPI 데이터
        if intent in [QueryIntent.KPI_STATUS, QueryIntent.GENERAL]:
            data['leader_pipeline'] = self.kpi_analytics.calculate_leader_pipeline_kpis(
                department_id, TimeRange.CURRENT_YEAR
            )
            data['certification'] = self.kpi_analytics.calculate_certification_progress_kpis(
                department_id, TimeRange.CURRENT_YEAR
            )
            data['training'] = self.kpi_analytics.calculate_training_effectiveness_kpis(
                department_id, TimeRange.CURRENT_YEAR
            )
            data['readiness'] = self.kpi_analytics.calculate_talent_readiness_kpis(
                department_id, TimeRange.CURRENT_YEAR
            )
        
        # 트렌드 데이터
        if intent == QueryIntent.TREND_ANALYSIS:
            data['monthly_trend'] = self._get_monthly_trend_data(department_id)
            data['quarterly_trend'] = self._get_quarterly_trend_data(department_id)
        
        # 비교 데이터
        if intent == QueryIntent.COMPARISON:
            data['department_comparison'] = self._get_department_comparison_data()
            data['year_over_year'] = self._get_year_over_year_data(department_id)
        
        # 예측 데이터
        if intent == QueryIntent.PREDICTION:
            data['pipeline_forecast'] = self._forecast_pipeline_growth(department_id)
            data['readiness_projection'] = self._project_readiness_improvement(department_id)
        
        # 컨텍스트 데이터 추가
        data['context'] = {
            'total_employees': Employee.objects.filter(is_active=True).count(),
            'departments': Department.objects.filter(is_active=True).count(),
            'current_date': timezone.now().strftime('%Y-%m-%d'),
            'query_intent': intent.value
        }
        
        return data
    
    def generate_insights(self, query: str, data: Dict[str, Any], 
                         intent: QueryIntent, insight_level: InsightLevel) -> AIResponse:
        """GPT를 활용한 인사이트 생성"""
        # 데이터를 텍스트로 변환
        data_summary = self._summarize_data_for_gpt(data)
        
        # 프롬프트 구성
        prompt = self._build_prompt(query, data_summary, intent, insight_level)
        
        try:
            # GPT API 호출
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=self.max_tokens,
                temperature=self.temperature,
                stream=False
            )
            
            content = response.choices[0].message.content
            
            # 응답 파싱 및 구조화
            ai_response = self._parse_gpt_response(content, data)
            
            # 데이터 기반 추천사항 추가
            ai_response.recommendations.extend(
                self._generate_data_driven_recommendations(data, intent)
            )
            
            # 시각화 제안 추가
            ai_response.visualizations = self._suggest_visualizations(data, intent)
            
            # 후속 질문 생성
            ai_response.follow_up_questions = self._generate_follow_up_questions(
                query, intent, data
            )
            
            return ai_response
            
        except Exception as e:
            # 오류 처리
            return AIResponse(
                content=f"인사이트 생성 중 오류가 발생했습니다: {str(e)}",
                confidence=0.0
            )
    
    def stream_response(self, query: str, user_context: Dict[str, Any]) -> Generator[str, None, None]:
        """스트리밍 응답 생성"""
        intent = self.analyze_query(query, user_context)
        department_id = user_context.get('department_id')
        data = self.get_relevant_data(query, intent, department_id)
        
        # 데이터 요약
        data_summary = self._summarize_data_for_gpt(data)
        
        # 프롬프트 구성
        prompt = self._build_prompt(
            query, 
            data_summary, 
            intent, 
            InsightLevel.EXECUTIVE
        )
        
        try:
            # 스트리밍 GPT API 호출
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=self.max_tokens,
                temperature=self.temperature,
                stream=True
            )
            
            for chunk in response:
                if chunk.choices[0].delta.get('content'):
                    yield chunk.choices[0].delta.content
                    
        except Exception as e:
            yield f"오류: {str(e)}"
    
    def _summarize_data_for_gpt(self, data: Dict[str, Any]) -> str:
        """데이터를 GPT가 이해할 수 있는 텍스트로 요약"""
        summary = []
        
        # Leader Pipeline 요약
        if 'leader_pipeline' in data:
            pipeline = data['leader_pipeline']
            summary.append(f"""
리더 파이프라인 현황:
- 총 리더 후보자: {pipeline['total_candidates'].value}명
- 즉시 승진 가능: {pipeline['ready_now'].value}명
- 1년 내 준비 가능: {pipeline['ready_in_year'].value}명
- 평균 준비도: {pipeline['avg_readiness_score'].value}%
""")
        
        # Certification 요약
        if 'certification' in data:
            cert = data['certification']
            summary.append(f"""
인증 진행 현황:
- 인증 신청: {cert['total_applications'].value}건
- 인증 완료율: {cert['certification_rate'].value}%
- 평균 소요일: {cert['avg_certification_days'].value}일
""")
        
        # Training 요약
        if 'training' in data:
            training = data['training']
            summary.append(f"""
교육 현황:
- 참여율: {training['participation_rate'].value}%
- 이수율: {training['completion_rate'].value}%
- 리더십 교육 비중: {training['leadership_focus'].value}%
- 인당 교육시간: {training['avg_training_hours'].value}시간
""")
        
        # Readiness 요약
        if 'readiness' in data:
            readiness = data['readiness']
            summary.append(f"""
인재 준비도:
- High Potential 비율: {readiness['high_potential_ratio'].value}%
- 핵심직무 준비도: {readiness['key_position_coverage'].value}%
- 승계 준비 지수: {readiness['succession_readiness'].value}점
""")
        
        return "\n".join(summary)
    
    def _build_prompt(self, query: str, data_summary: str, 
                     intent: QueryIntent, insight_level: InsightLevel) -> str:
        """의도별 프롬프트 구성"""
        base_prompt = f"""
User Query: {query}

Current KPI Data:
{data_summary}

Query Intent: {intent.value}
Insight Level: {insight_level.value}
"""
        
        # 의도별 추가 지침
        if intent == QueryIntent.KPI_STATUS:
            base_prompt += """
Please provide a comprehensive status overview highlighting:
1. Current performance against targets
2. Key achievements and concerns
3. Areas requiring immediate attention
"""
        elif intent == QueryIntent.TREND_ANALYSIS:
            base_prompt += """
Analyze the trends and patterns in the data:
1. Identify significant changes over time
2. Explain underlying factors
3. Project future trajectory
"""
        elif intent == QueryIntent.RECOMMENDATION:
            base_prompt += """
Provide strategic recommendations:
1. Prioritized action items
2. Expected impact of each recommendation
3. Implementation timeline
"""
        elif intent == QueryIntent.COMPARISON:
            base_prompt += """
Compare and contrast:
1. Highlight key differences
2. Identify best practices
3. Suggest areas for improvement
"""
        elif intent == QueryIntent.PREDICTION:
            base_prompt += """
Forecast future outcomes:
1. Project key metrics 6-12 months ahead
2. Identify potential risks and opportunities
3. Suggest preventive/preparatory measures
"""
        elif intent == QueryIntent.ACTION_PLAN:
            base_prompt += """
Develop a strategic action plan:
1. Short-term (3 months) initiatives
2. Medium-term (6-12 months) goals
3. Success metrics and milestones
"""
        
        return base_prompt
    
    def _parse_gpt_response(self, content: str, data: Dict[str, Any]) -> AIResponse:
        """GPT 응답 파싱 및 구조화"""
        # 기본 응답 객체 생성
        response = AIResponse(
            content=content,
            confidence=0.85,  # 기본 신뢰도
            data_sources=list(data.keys())
        )
        
        # 추천사항 추출 (번호나 불릿 포인트로 시작하는 라인)
        recommendation_pattern = r'^\s*[\d•\-]\s*(.+)$'
        recommendations = re.findall(recommendation_pattern, content, re.MULTILINE)
        
        for rec in recommendations[:5]:  # 최대 5개
            response.recommendations.append({
                'text': rec.strip(),
                'priority': 'high' if any(word in rec.lower() for word in ['즉시', 'urgent', '시급']) else 'medium'
            })
        
        return response
    
    def _generate_data_driven_recommendations(self, data: Dict[str, Any], 
                                            intent: QueryIntent) -> List[Dict[str, Any]]:
        """데이터 기반 추천사항 생성"""
        recommendations = []
        
        # 리더 파이프라인 분석
        if 'leader_pipeline' in data:
            pipeline = data['leader_pipeline']
            
            # 즉시 승진 가능 인원이 적은 경우
            if pipeline['ready_now'].value < pipeline['total_candidates'].value * 0.2:
                recommendations.append({
                    'text': '즉시 승진 가능 인원이 20% 미만입니다. 집중 육성 프로그램 도입을 검토하세요.',
                    'priority': 'high',
                    'metric': 'ready_now_ratio',
                    'current_value': pipeline['ready_now'].value / pipeline['total_candidates'].value * 100
                })
            
            # 평균 준비도가 낮은 경우
            if pipeline['avg_readiness_score'].value < 70:
                recommendations.append({
                    'text': '평균 준비도가 70% 미만입니다. 리더십 개발 프로그램 강화가 필요합니다.',
                    'priority': 'high',
                    'metric': 'avg_readiness',
                    'current_value': pipeline['avg_readiness_score'].value
                })
        
        # 인증 진행률 분석
        if 'certification' in data:
            cert = data['certification']
            
            # 인증 완료율이 낮은 경우
            if cert['certification_rate'].value < 80:
                recommendations.append({
                    'text': f"인증 완료율이 {cert['certification_rate'].value}%로 목표(80%) 미달입니다. 인증 프로세스 개선이 필요합니다.",
                    'priority': 'medium',
                    'metric': 'certification_rate',
                    'gap': 80 - cert['certification_rate'].value
                })
            
            # 인증 소요 시간이 긴 경우
            if cert['avg_certification_days'].value > 30:
                recommendations.append({
                    'text': f"평균 인증 소요일이 {cert['avg_certification_days'].value}일로 목표(30일)를 초과합니다. 프로세스 간소화를 검토하세요.",
                    'priority': 'medium',
                    'metric': 'certification_days',
                    'gap': cert['avg_certification_days'].value - 30
                })
        
        # 교육 효과성 분석
        if 'training' in data:
            training = data['training']
            
            # 교육 참여율이 낮은 경우
            if training['participation_rate'].value < 90:
                recommendations.append({
                    'text': '교육 참여율 향상을 위한 인센티브 제도 도입을 검토하세요.',
                    'priority': 'medium',
                    'metric': 'participation_rate',
                    'current_value': training['participation_rate'].value
                })
            
            # 리더십 교육 비중이 낮은 경우
            if training['leadership_focus'].value < 40:
                recommendations.append({
                    'text': '리더십 교육 비중을 40% 이상으로 높여 리더 육성에 집중하세요.',
                    'priority': 'high',
                    'metric': 'leadership_focus',
                    'gap': 40 - training['leadership_focus'].value
                })
        
        return recommendations
    
    def _suggest_visualizations(self, data: Dict[str, Any], 
                               intent: QueryIntent) -> List[Dict[str, Any]]:
        """데이터 시각화 제안"""
        visualizations = []
        
        if intent == QueryIntent.KPI_STATUS:
            visualizations.extend([
                {
                    'type': 'gauge',
                    'title': '리더 준비도 게이지',
                    'data_key': 'leader_pipeline.avg_readiness_score',
                    'config': {'min': 0, 'max': 100, 'target': 75}
                },
                {
                    'type': 'bar',
                    'title': '리더 파이프라인 단계별 분포',
                    'data_key': 'leader_pipeline.distribution',
                    'config': {'stacked': False}
                }
            ])
        
        elif intent == QueryIntent.TREND_ANALYSIS:
            visualizations.extend([
                {
                    'type': 'line',
                    'title': '월별 인증 신청 추세',
                    'data_key': 'monthly_trend.certifications',
                    'config': {'smooth': True}
                },
                {
                    'type': 'area',
                    'title': '교육 참여율 변화',
                    'data_key': 'monthly_trend.training_participation',
                    'config': {'gradient': True}
                }
            ])
        
        elif intent == QueryIntent.COMPARISON:
            visualizations.extend([
                {
                    'type': 'radar',
                    'title': '부서별 리더십 KPI 비교',
                    'data_key': 'department_comparison',
                    'config': {'dimensions': ['pipeline', 'certification', 'training', 'readiness']}
                },
                {
                    'type': 'heatmap',
                    'title': '부서-KPI 매트릭스',
                    'data_key': 'department_kpi_matrix',
                    'config': {'colorScale': 'viridis'}
                }
            ])
        
        return visualizations
    
    def _generate_follow_up_questions(self, original_query: str, 
                                    intent: QueryIntent, 
                                    data: Dict[str, Any]) -> List[str]:
        """맥락에 맞는 후속 질문 생성"""
        questions = []
        
        # 기본 후속 질문
        base_questions = {
            QueryIntent.KPI_STATUS: [
                "특정 부서의 상세 현황을 보시겠습니까?",
                "전년 대비 변화를 확인하시겠습니까?",
                "목표 미달 항목에 대한 개선 방안을 알아보시겠습니까?"
            ],
            QueryIntent.TREND_ANALYSIS: [
                "특정 기간의 상세 트렌드를 분석해드릴까요?",
                "트렌드 변화의 원인을 분석해드릴까요?",
                "향후 전망을 예측해드릴까요?"
            ],
            QueryIntent.RECOMMENDATION: [
                "추천사항의 구체적인 실행 계획을 수립해드릴까요?",
                "예상 ROI를 분석해드릴까요?",
                "우선순위별 로드맵을 작성해드릴까요?"
            ]
        }
        
        # 의도별 기본 질문 추가
        if intent in base_questions:
            questions.extend(base_questions[intent])
        
        # 데이터 기반 맞춤 질문
        if 'leader_pipeline' in data:
            pipeline = data['leader_pipeline']
            if pipeline['ready_now'].value < 10:
                questions.append("즉시 승진 가능 인원이 부족한 이유를 분석해드릴까요?")
        
        if 'certification' in data:
            cert = data['certification']
            if cert['certification_rate'].value < 70:
                questions.append("인증 완료율이 낮은 부서를 집중 분석해드릴까요?")
        
        return questions[:3]  # 최대 3개 반환
    
    def _get_monthly_trend_data(self, department_id: Optional[str]) -> Dict[str, Any]:
        """월별 트렌드 데이터 조회"""
        # 최근 12개월 데이터
        end_date = timezone.now()
        start_date = end_date - timedelta(days=365)
        
        monthly_data = []
        current_date = start_date
        
        while current_date <= end_date:
            month_start = current_date.replace(day=1)
            if current_date.month == 12:
                month_end = current_date.replace(year=current_date.year + 1, month=1, day=1)
            else:
                month_end = current_date.replace(month=current_date.month + 1, day=1)
            
            # 월별 KPI 계산
            certifications = GrowthLevelCertification.objects.filter(
                applied_date__gte=month_start,
                applied_date__lt=month_end
            )
            if department_id:
                certifications = certifications.filter(employee__department_id=department_id)
            
            monthly_data.append({
                'month': month_start.strftime('%Y-%m'),
                'certifications': certifications.count(),
                'completion_rate': certifications.filter(status='CERTIFIED').count() / certifications.count() * 100 if certifications.count() > 0 else 0
            })
            
            current_date = month_end
        
        return {'data': monthly_data}
    
    def _get_quarterly_trend_data(self, department_id: Optional[str]) -> Dict[str, Any]:
        """분기별 트렌드 데이터 조회"""
        # 최근 8분기 데이터
        quarters = []
        current_date = timezone.now()
        
        for i in range(8):
            quarter_end = current_date - timedelta(days=90 * i)
            quarter_start = quarter_end - timedelta(days=90)
            
            # 분기별 KPI 집계
            pipeline_data = LeaderRecommendation.objects.filter(
                created_at__gte=quarter_start,
                created_at__lt=quarter_end,
                is_active=True
            )
            if department_id:
                pipeline_data = pipeline_data.filter(employee__department_id=department_id)
            
            quarters.append({
                'quarter': f"{quarter_end.year}Q{(quarter_end.month - 1) // 3 + 1}",
                'candidates': pipeline_data.values('employee').distinct().count(),
                'avg_readiness': pipeline_data.aggregate(avg=Avg('readiness_score'))['avg'] or 0
            })
        
        return {'data': list(reversed(quarters))}
    
    def _get_department_comparison_data(self) -> Dict[str, Any]:
        """부서간 비교 데이터"""
        departments = Department.objects.filter(is_active=True, parent_id__isnull=True)
        comparison = []
        
        for dept in departments:
            dept_analytics = {
                'department': dept.name,
                'metrics': {}
            }
            
            # 각 부서의 주요 KPI
            pipeline = self.kpi_analytics.calculate_leader_pipeline_kpis(str(dept.id))
            cert = self.kpi_analytics.calculate_certification_progress_kpis(str(dept.id))
            training = self.kpi_analytics.calculate_training_effectiveness_kpis(str(dept.id))
            
            dept_analytics['metrics'] = {
                'leader_candidates': pipeline['total_candidates'].value,
                'certification_rate': cert['certification_rate'].value,
                'training_participation': training['participation_rate'].value,
                'readiness_score': pipeline['avg_readiness_score'].value
            }
            
            comparison.append(dept_analytics)
        
        return {'departments': comparison}
    
    def _get_year_over_year_data(self, department_id: Optional[str]) -> Dict[str, Any]:
        """전년 대비 데이터"""
        current_year = timezone.now().year
        
        # 올해 데이터
        current_data = {
            'leader_pipeline': self.kpi_analytics.calculate_leader_pipeline_kpis(
                department_id, TimeRange.CURRENT_YEAR
            ),
            'certification': self.kpi_analytics.calculate_certification_progress_kpis(
                department_id, TimeRange.CURRENT_YEAR
            )
        }
        
        # 작년 데이터 (캐시된 데이터 사용 또는 계산)
        # 실제 구현시 작년 데이터 조회 로직 필요
        
        return {
            'current_year': current_year,
            'previous_year': current_year - 1,
            'current_data': current_data,
            'growth_rates': {
                'leader_candidates': 15.5,  # 예시값
                'certification_rate': 8.3,
                'training_hours': 22.1
            }
        }
    
    def _forecast_pipeline_growth(self, department_id: Optional[str]) -> Dict[str, Any]:
        """파이프라인 성장 예측"""
        # 과거 데이터 기반 예측 모델
        # 실제 구현시 시계열 분석 필요
        
        return {
            'forecast_months': 12,
            'predicted_candidates': {
                '3_months': 125,
                '6_months': 145,
                '12_months': 180
            },
            'confidence_interval': {
                'lower': 160,
                'upper': 200
            },
            'growth_rate': 15.5
        }
    
    def _project_readiness_improvement(self, department_id: Optional[str]) -> Dict[str, Any]:
        """준비도 개선 예측"""
        # 교육 이수율과 평가 향상률 기반 예측
        
        return {
            'current_readiness': 72.5,
            'projected_readiness': {
                '3_months': 75.0,
                '6_months': 78.5,
                '12_months': 82.0
            },
            'key_drivers': [
                {'factor': '리더십 교육 강화', 'impact': '+5%'},
                {'factor': '멘토링 프로그램', 'impact': '+3%'},
                {'factor': '실무 프로젝트 경험', 'impact': '+4%'}
            ]
        }


class LeadershipAIAssistantView(TemplateView):
    """AI 어시스턴트 대시보드 뷰"""
    template_name = 'dashboards/leader_ai_assistant.html'
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # 샘플 질문 제공
        context['sample_questions'] = [
            "우리 회사의 리더 파이프라인 현황은 어떤가요?",
            "인증 완료율이 낮은 이유가 무엇인가요?",
            "리더십 개발을 위한 전략을 제안해주세요",
            "영업부서와 기술부서의 인재 준비도를 비교해주세요",
            "향후 6개월간 리더 후보자 수를 예측해주세요",
            "교육 투자 대비 효과를 분석해주세요"
        ]
        
        # 사용자 권한별 인사이트 레벨
        if self.request.user.groups.filter(name='Executive').exists():
            context['insight_level'] = InsightLevel.EXECUTIVE.value
        elif self.request.user.groups.filter(name='HR').exists():
            context['insight_level'] = InsightLevel.MANAGER.value
        else:
            context['insight_level'] = InsightLevel.OPERATIONAL.value
        
        return context


class LeadershipAIQueryAPI(View):
    """AI 질의응답 API"""
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    def post(self, request):
        """AI 질의 처리"""
        try:
            data = json.loads(request.body)
            query = data.get('query', '')
            department_id = data.get('department_id')
            
            if not query:
                return JsonResponse({'error': '질문을 입력해주세요.'}, status=400)
            
            # AI 어시스턴트 초기화
            assistant = LeadershipAIAssistant()
            
            # 사용자 컨텍스트
            user_context = {
                'user_id': request.user.id,
                'department_id': department_id,
                'role': request.user.groups.first().name if request.user.groups.exists() else 'User'
            }
            
            # 질의 분석
            intent = assistant.analyze_query(query, user_context)
            
            # 관련 데이터 수집
            relevant_data = assistant.get_relevant_data(query, intent, department_id)
            
            # 인사이트 레벨 결정
            if request.user.groups.filter(name='Executive').exists():
                insight_level = InsightLevel.EXECUTIVE
            else:
                insight_level = InsightLevel.MANAGER
            
            # AI 응답 생성
            ai_response = assistant.generate_insights(
                query, relevant_data, intent, insight_level
            )
            
            # 응답 직렬화
            response_data = {
                'query': query,
                'intent': intent.value,
                'response': ai_response.content,
                'confidence': ai_response.confidence,
                'recommendations': ai_response.recommendations,
                'visualizations': ai_response.visualizations,
                'follow_up_questions': ai_response.follow_up_questions,
                'data_sources': ai_response.data_sources,
                'timestamp': timezone.now().isoformat()
            }
            
            # 질의 로그 저장 (선택적)
            self._log_query(request.user, query, intent, ai_response)
            
            return JsonResponse(response_data)
            
        except json.JSONDecodeError:
            return JsonResponse({'error': '잘못된 요청 형식입니다.'}, status=400)
        except Exception as e:
            return JsonResponse({'error': f'처리 중 오류 발생: {str(e)}'}, status=500)
    
    def _log_query(self, user, query: str, intent: QueryIntent, response: AIResponse):
        """질의 로그 저장"""
        # 실제 구현시 로그 모델 필요
        pass


class LeadershipAIStreamAPI(View):
    """스트리밍 AI 응답 API"""
    
    @method_decorator(login_required) 
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    def post(self, request):
        """스트리밍 응답 생성"""
        try:
            data = json.loads(request.body)
            query = data.get('query', '')
            department_id = data.get('department_id')
            
            if not query:
                return JsonResponse({'error': '질문을 입력해주세요.'}, status=400)
            
            # AI 어시스턴트 초기화
            assistant = LeadershipAIAssistant()
            
            # 사용자 컨텍스트
            user_context = {
                'user_id': request.user.id,
                'department_id': department_id,
                'role': request.user.groups.first().name if request.user.groups.exists() else 'User'
            }
            
            # 스트리밍 응답 생성
            def stream_generator():
                yield 'data: {"type": "start"}\n\n'
                
                for chunk in assistant.stream_response(query, user_context):
                    # SSE 형식으로 전송
                    yield f'data: {json.dumps({"type": "content", "content": chunk})}\n\n'
                
                yield 'data: {"type": "end"}\n\n'
            
            response = StreamingHttpResponse(
                stream_generator(),
                content_type='text/event-stream'
            )
            response['Cache-Control'] = 'no-cache'
            response['X-Accel-Buffering'] = 'no'
            
            return response
            
        except Exception as e:
            return JsonResponse({'error': f'스트리밍 오류: {str(e)}'}, status=500)


class LeadershipInsightReportAPI(View):
    """정기 인사이트 리포트 생성"""
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    def get(self, request):
        """주간/월간 인사이트 리포트 생성"""
        report_type = request.GET.get('type', 'weekly')
        department_id = request.GET.get('department_id')
        
        assistant = LeadershipAIAssistant()
        analytics = LeaderKPIAnalytics()
        
        # 전체 데이터 수집
        if report_type == 'weekly':
            time_range = TimeRange.CURRENT_MONTH
            period = "주간"
        else:
            time_range = TimeRange.CURRENT_QUARTER
            period = "월간"
        
        # KPI 데이터 수집
        kpi_data = {
            'leader_pipeline': analytics.calculate_leader_pipeline_kpis(department_id, time_range),
            'certification': analytics.calculate_certification_progress_kpis(department_id, time_range),
            'training': analytics.calculate_training_effectiveness_kpis(department_id, time_range),
            'readiness': analytics.calculate_talent_readiness_kpis(department_id, time_range)
        }
        
        # AI 기반 종합 분석
        executive_summary = assistant.generate_insights(
            f"{period} 리더십 KPI 종합 분석 및 인사이트를 제공해주세요",
            kpi_data,
            QueryIntent.GENERAL,
            InsightLevel.EXECUTIVE
        )
        
        # 주요 이슈 및 권고사항
        key_issues = assistant.generate_insights(
            "현재 데이터에서 가장 시급한 이슈 3가지와 해결방안을 제시해주세요",
            kpi_data,
            QueryIntent.RECOMMENDATION,
            InsightLevel.EXECUTIVE
        )
        
        # 리포트 구성
        report = {
            'report_type': report_type,
            'period': period,
            'generated_at': timezone.now().isoformat(),
            'executive_summary': executive_summary.content,
            'key_metrics': self._extract_key_metrics(kpi_data),
            'issues_and_recommendations': key_issues.recommendations,
            'department': Department.objects.get(id=department_id).name if department_id else '전사',
            'next_steps': key_issues.follow_up_questions
        }
        
        return JsonResponse(report)
    
    def _extract_key_metrics(self, kpi_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """핵심 지표 추출"""
        key_metrics = []
        
        # 리더 파이프라인
        pipeline = kpi_data['leader_pipeline']
        key_metrics.append({
            'category': '리더 파이프라인',
            'metrics': [
                {'name': '총 후보자', 'value': pipeline['total_candidates'].value, 'unit': '명'},
                {'name': '평균 준비도', 'value': pipeline['avg_readiness_score'].value, 'unit': '%'}
            ]
        })
        
        # 인증
        cert = kpi_data['certification']
        key_metrics.append({
            'category': '인증 진행',
            'metrics': [
                {'name': '인증 완료율', 'value': cert['certification_rate'].value, 'unit': '%'},
                {'name': '평균 소요일', 'value': cert['avg_certification_days'].value, 'unit': '일'}
            ]
        })
        
        return key_metrics


# URL 패턴
urlpatterns = [
    # AI 어시스턴트 대시보드
    path('leader-ai-assistant/', LeadershipAIAssistantView.as_view(), name='leader_ai_assistant'),
    
    # AI API 엔드포인트
    path('api/leader-ai-query/', LeadershipAIQueryAPI.as_view(), name='leader_ai_query'),
    path('api/leader-ai-stream/', LeadershipAIStreamAPI.as_view(), name='leader_ai_stream'),
    path('api/leader-insight-report/', LeadershipInsightReportAPI.as_view(), name='leader_insight_report'),
]


# JavaScript 클라이언트 예시
AI_ASSISTANT_JS = """
// AI 어시스턴트 JavaScript 클라이언트

class LeadershipAIClient {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.conversationHistory = [];
        this.isStreaming = false;
    }
    
    async initialize() {
        this.renderInterface();
        this.attachEventListeners();
        this.loadSampleQuestions();
    }
    
    renderInterface() {
        const html = `
            <div class="ai-assistant-container">
                <div class="chat-header">
                    <h3>리더십 전략 AI 어시스턴트</h3>
                    <span class="status-indicator">준비됨</span>
                </div>
                
                <div class="chat-messages" id="chatMessages">
                    <div class="welcome-message">
                        <p>안녕하세요! 리더십 KPI와 인재 개발에 대해 궁금하신 점을 물어보세요.</p>
                    </div>
                </div>
                
                <div class="sample-questions" id="sampleQuestions"></div>
                
                <div class="chat-input-container">
                    <textarea id="queryInput" placeholder="질문을 입력하세요..." rows="2"></textarea>
                    <button id="sendBtn" class="btn btn-primary">
                        <i class="fas fa-paper-plane"></i> 전송
                    </button>
                </div>
                
                <div class="ai-options">
                    <label>
                        <input type="checkbox" id="streamMode" checked> 실시간 스트리밍
                    </label>
                    <select id="departmentFilter">
                        <option value="">전사</option>
                        <!-- 부서 옵션 동적 로드 -->
                    </select>
                </div>
            </div>
        `;
        
        this.container.innerHTML = html;
    }
    
    async sendQuery() {
        const input = document.getElementById('queryInput');
        const query = input.value.trim();
        
        if (!query) return;
        
        // 사용자 메시지 추가
        this.addMessage(query, 'user');
        input.value = '';
        
        // 부서 필터
        const departmentId = document.getElementById('departmentFilter').value;
        
        // 스트리밍 모드 확인
        const streamMode = document.getElementById('streamMode').checked;
        
        if (streamMode) {
            await this.streamResponse(query, departmentId);
        } else {
            await this.getResponse(query, departmentId);
        }
    }
    
    async getResponse(query, departmentId) {
        this.setLoading(true);
        
        try {
            const response = await fetch('/api/leader-ai-query/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    query: query,
                    department_id: departmentId
                })
            });
            
            const data = await response.json();
            
            // AI 응답 표시
            this.addMessage(data.response, 'assistant', {
                confidence: data.confidence,
                recommendations: data.recommendations,
                visualizations: data.visualizations
            });
            
            // 후속 질문 표시
            if (data.follow_up_questions && data.follow_up_questions.length > 0) {
                this.showFollowUpQuestions(data.follow_up_questions);
            }
            
            // 시각화 렌더링
            if (data.visualizations && data.visualizations.length > 0) {
                this.renderVisualizations(data.visualizations);
            }
            
        } catch (error) {
            this.addMessage('죄송합니다. 오류가 발생했습니다: ' + error.message, 'error');
        } finally {
            this.setLoading(false);
        }
    }
    
    async streamResponse(query, departmentId) {
        this.setLoading(true);
        const messageId = this.addMessage('', 'assistant', {streaming: true});
        
        try {
            const response = await fetch('/api/leader-ai-stream/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    query: query,
                    department_id: departmentId
                })
            });
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let messageContent = '';
            
            while (true) {
                const {done, value} = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value);
                const lines = chunk.split('\\n');
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = JSON.parse(line.slice(6));
                        
                        if (data.type === 'content') {
                            messageContent += data.content;
                            this.updateMessage(messageId, messageContent);
                        }
                    }
                }
            }
            
        } catch (error) {
            this.updateMessage(messageId, '스트리밍 오류: ' + error.message);
        } finally {
            this.setLoading(false);
        }
    }
    
    addMessage(content, sender, metadata = {}) {
        const messagesDiv = document.getElementById('chatMessages');
        const messageId = 'msg-' + Date.now();
        
        const messageDiv = document.createElement('div');
        messageDiv.id = messageId;
        messageDiv.className = `message ${sender}-message`;
        
        if (metadata.streaming) {
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="typing-indicator">
                        <span></span><span></span><span></span>
                    </div>
                </div>
            `;
        } else {
            messageDiv.innerHTML = `
                <div class="message-content">${this.formatMessage(content)}</div>
                ${metadata.confidence ? `<div class="confidence">신뢰도: ${(metadata.confidence * 100).toFixed(0)}%</div>` : ''}
            `;
        }
        
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        
        // 추천사항 표시
        if (metadata.recommendations && metadata.recommendations.length > 0) {
            this.showRecommendations(metadata.recommendations, messageId);
        }
        
        return messageId;
    }
    
    updateMessage(messageId, content) {
        const messageDiv = document.getElementById(messageId);
        if (messageDiv) {
            messageDiv.querySelector('.message-content').innerHTML = this.formatMessage(content);
        }
    }
    
    formatMessage(content) {
        // 마크다운 스타일 포맷팅
        return content
            .replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>')
            .replace(/\\*(.*?)\\*/g, '<em>$1</em>')
            .replace(/\\n/g, '<br>')
            .replace(/^- (.+)$/gm, '<li>$1</li>')
            .replace(/(<li>.*<\\/li>)/s, '<ul>$1</ul>');
    }
    
    showRecommendations(recommendations, messageId) {
        const recDiv = document.createElement('div');
        recDiv.className = 'recommendations';
        recDiv.innerHTML = `
            <h5>주요 권고사항</h5>
            <ul>
                ${recommendations.map(rec => `
                    <li class="priority-${rec.priority}">
                        ${rec.text}
                    </li>
                `).join('')}
            </ul>
        `;
        
        document.getElementById(messageId).appendChild(recDiv);
    }
    
    showFollowUpQuestions(questions) {
        const followUpDiv = document.createElement('div');
        followUpDiv.className = 'follow-up-questions';
        followUpDiv.innerHTML = `
            <p>다음 질문도 도움이 될 수 있습니다:</p>
            ${questions.map(q => `
                <button class="follow-up-btn" onclick="aiClient.askFollowUp('${q}')">
                    ${q}
                </button>
            `).join('')}
        `;
        
        document.getElementById('chatMessages').appendChild(followUpDiv);
    }
    
    askFollowUp(question) {
        document.getElementById('queryInput').value = question;
        this.sendQuery();
    }
    
    renderVisualizations(visualizations) {
        const vizContainer = document.createElement('div');
        vizContainer.className = 'visualizations';
        
        visualizations.forEach(viz => {
            const vizDiv = document.createElement('div');
            vizDiv.className = 'viz-item';
            vizDiv.innerHTML = `
                <h5>${viz.title}</h5>
                <div id="viz-${viz.type}-${Date.now()}" class="viz-chart"></div>
            `;
            vizContainer.appendChild(vizDiv);
            
            // 차트 렌더링 (Chart.js 등 사용)
            setTimeout(() => {
                this.renderChart(vizDiv.querySelector('.viz-chart'), viz);
            }, 100);
        });
        
        document.getElementById('chatMessages').appendChild(vizContainer);
    }
    
    renderChart(container, vizConfig) {
        // 실제 차트 구현
        // Chart.js, D3.js 등을 사용하여 vizConfig에 따라 차트 렌더링
    }
    
    loadSampleQuestions() {
        fetch('/leader-ai-assistant/')
            .then(response => response.text())
            .then(html => {
                // 샘플 질문 추출 및 표시
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                // 샘플 질문 렌더링
            });
    }
    
    attachEventListeners() {
        document.getElementById('sendBtn').addEventListener('click', () => {
            this.sendQuery();
        });
        
        document.getElementById('queryInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendQuery();
            }
        });
    }
    
    setLoading(isLoading) {
        const statusIndicator = document.querySelector('.status-indicator');
        const sendBtn = document.getElementById('sendBtn');
        
        if (isLoading) {
            statusIndicator.textContent = '응답 생성 중...';
            statusIndicator.classList.add('loading');
            sendBtn.disabled = true;
        } else {
            statusIndicator.textContent = '준비됨';
            statusIndicator.classList.remove('loading');
            sendBtn.disabled = false;
        }
    }
}

// 초기화
const aiClient = new LeadershipAIClient('aiAssistantContainer');
document.addEventListener('DOMContentLoaded', () => {
    aiClient.initialize();
});

// 유틸리티 함수
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
"""


# CSS 스타일 예시
AI_ASSISTANT_CSS = """
/* AI Assistant Styles */
.ai-assistant-container {
    max-width: 800px;
    margin: 0 auto;
    background: #f8f9fa;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.chat-header {
    background: #007bff;
    color: white;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.status-indicator {
    font-size: 14px;
    padding: 4px 12px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 20px;
}

.status-indicator.loading {
    animation: pulse 1.5s infinite;
}

.chat-messages {
    height: 500px;
    overflow-y: auto;
    padding: 20px;
    background: white;
}

.message {
    margin-bottom: 20px;
    animation: slideIn 0.3s ease-out;
}

.user-message {
    text-align: right;
}

.user-message .message-content {
    background: #007bff;
    color: white;
    display: inline-block;
    padding: 12px 20px;
    border-radius: 20px 20px 4px 20px;
    max-width: 70%;
}

.assistant-message .message-content {
    background: #f1f3f5;
    color: #333;
    display: inline-block;
    padding: 12px 20px;
    border-radius: 20px 20px 20px 4px;
    max-width: 85%;
}

.confidence {
    font-size: 12px;
    color: #6c757d;
    margin-top: 4px;
}

.recommendations {
    margin-top: 15px;
    padding: 15px;
    background: #e7f3ff;
    border-radius: 8px;
}

.recommendations h5 {
    margin: 0 0 10px 0;
    color: #0056b3;
}

.priority-high {
    color: #dc3545;
    font-weight: bold;
}

.priority-medium {
    color: #ffc107;
}

.follow-up-questions {
    margin: 20px 0;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
}

.follow-up-btn {
    display: block;
    width: 100%;
    text-align: left;
    padding: 10px 15px;
    margin: 5px 0;
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
}

.follow-up-btn:hover {
    background: #007bff;
    color: white;
    transform: translateX(5px);
}

.chat-input-container {
    display: flex;
    padding: 20px;
    background: #f8f9fa;
    border-top: 1px solid #dee2e6;
}

#queryInput {
    flex: 1;
    padding: 12px;
    border: 1px solid #ced4da;
    border-radius: 6px;
    resize: none;
    font-family: inherit;
}

#sendBtn {
    margin-left: 10px;
    padding: 12px 24px;
}

.typing-indicator {
    display: flex;
    align-items: center;
}

.typing-indicator span {
    height: 8px;
    width: 8px;
    background: #999;
    border-radius: 50%;
    margin: 0 2px;
    animation: typing 1.4s infinite;
}

.typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typing {
    0%, 60%, 100% {
        opacity: 0.2;
        transform: scale(0.8);
    }
    30% {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes pulse {
    0% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
    100% {
        opacity: 1;
    }
}

.visualizations {
    margin: 20px 0;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

.viz-item {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.viz-chart {
    height: 250px;
    margin-top: 10px;
}

.ai-options {
    padding: 15px 20px;
    background: #f8f9fa;
    border-top: 1px solid #dee2e6;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.sample-questions {
    padding: 0 20px;
    margin-bottom: 10px;
}

.sample-questions button {
    font-size: 13px;
    padding: 6px 12px;
    margin: 2px;
    background: #e9ecef;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s;
}

.sample-questions button:hover {
    background: #007bff;
    color: white;
}
"""