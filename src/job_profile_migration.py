"""
OK금융그룹 Job Profile PDF→DB/JSON/AI 마이그레이션 자동화
Automated PDF to Database/JSON migration system for OK Financial Group Job Profiles
Generated by: Data migration engineer + NLP job analyst + HR taxonomy specialist
"""

import os
import json
import re
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
import logging

# PDF parsing libraries
import PyPDF2
import pdfplumber
import tabula
import camelot

# Data processing
import pandas as pd
import numpy as np
from openpyxl import Workbook

# NLP libraries
import nltk
from konlpy.tag import Okt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import KMeans

# Django ORM
from django.db import transaction, models
from django.core.management.base import BaseCommand
from django.utils import timezone

# AI/ML libraries
import openai
from transformers import pipeline

# Import existing models
from job_profiles.models import (
    JobCategory, JobSubCategory, JobLevelProfile,
    JobCompetency, JobResponsibility, JobRequirement,
    JobQualification, JobPreferredQualification
)


# Configuration
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
openai.api_key = OPENAI_API_KEY

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@dataclass
class JobProfileData:
    """직무 프로필 데이터 구조"""
    # 기본 정보
    job_code: str
    job_title: str
    job_category: str
    job_subcategory: str
    job_level: str
    department: str
    company: str = "OK금융그룹"
    
    # 직무 개요
    job_summary: str = ""
    job_purpose: str = ""
    
    # 주요 책임
    key_responsibilities: List[str] = field(default_factory=list)
    
    # 역량 요구사항
    required_competencies: List[Dict[str, Any]] = field(default_factory=list)
    technical_skills: List[str] = field(default_factory=list)
    soft_skills: List[str] = field(default_factory=list)
    
    # 자격 요건
    education_requirement: str = ""
    experience_requirement: str = ""
    certifications: List[str] = field(default_factory=list)
    
    # 우대 사항
    preferred_qualifications: List[str] = field(default_factory=list)
    
    # 기타 정보
    career_path: List[str] = field(default_factory=list)
    related_jobs: List[str] = field(default_factory=list)
    
    # 메타데이터
    extracted_date: datetime = field(default_factory=datetime.now)
    confidence_score: float = 0.0
    validation_status: str = "pending"
    raw_text: str = ""
    page_numbers: List[int] = field(default_factory=list)


@dataclass
class ExtractionResult:
    """추출 결과 데이터"""
    job_profiles: List[JobProfileData]
    extraction_stats: Dict[str, Any]
    errors: List[Dict[str, Any]]
    warnings: List[Dict[str, Any]]


class PDFJobProfileExtractor:
    """PDF에서 Job Profile 추출하는 메인 클래스"""
    
    def __init__(self, pdf_path: str):
        self.pdf_path = pdf_path
        self.raw_text = ""
        self.pages = []
        self.tables = []
        self.metadata = {}
        
        # NLP 초기화
        self.okt = Okt()
        
        # 패턴 정의
        self.patterns = self._initialize_patterns()
        
        # 필드 매핑
        self.field_mappings = self._initialize_field_mappings()
        
    def _initialize_patterns(self) -> Dict[str, re.Pattern]:
        """정규식 패턴 초기화"""
        return {
            'job_code': re.compile(r'(?:직무코드|Job Code)[\s:：]*([A-Z0-9\-]+)', re.IGNORECASE),
            'job_title': re.compile(r'(?:직무명|Job Title)[\s:：]*([가-힣A-Za-z\s\-]+)'),
            'department': re.compile(r'(?:부서|Department)[\s:：]*([가-힣A-Za-z\s\-]+)'),
            'level': re.compile(r'(?:직급|Level)[\s:：]*([가-힣A-Za-z0-9\s\-]+)'),
            'responsibility': re.compile(r'(?:주요\s*책임|Key\s*Responsibilities?)[\s:：]*([\s\S]+?)(?=\n\n|주요|요구|자격)'),
            'requirement': re.compile(r'(?:자격\s*요건|Requirements?)[\s:：]*([\s\S]+?)(?=\n\n|우대|기타)'),
            'competency': re.compile(r'(?:필요\s*역량|Competenc(?:y|ies))[\s:：]*([\s\S]+?)(?=\n\n|자격|기타)'),
            'education': re.compile(r'(?:학력|Education)[\s:：]*([가-힣A-Za-z\s]+)'),
            'experience': re.compile(r'(?:경력|Experience)[\s:：]*([가-힣0-9\s년이상]+)'),
            'bullet_point': re.compile(r'[•·\-▪▫◦]\s*(.+)'),
            'numbered_list': re.compile(r'^\d+[\)\.]\s*(.+)', re.MULTILINE)
        }
    
    def _initialize_field_mappings(self) -> Dict[str, List[str]]:
        """필드 매핑 초기화"""
        return {
            'job_category': ['직군', '직무군', 'Job Family', 'Category'],
            'job_subcategory': ['직무', '세부직무', 'Job', 'Subcategory'],
            'responsibilities': ['주요 책임', '담당업무', 'Key Responsibilities', 'Main Duties'],
            'competencies': ['필요 역량', '핵심 역량', 'Required Competencies', 'Core Competencies'],
            'qualifications': ['자격 요건', '필수 자격', 'Qualifications', 'Requirements'],
            'preferred': ['우대 사항', '우대 조건', 'Preferred', 'Plus'],
            'skills': ['필요 기술', '기술 요구사항', 'Technical Skills', 'Required Skills']
        }
    
    def extract(self) -> ExtractionResult:
        """메인 추출 프로세스"""
        logger.info(f"Starting extraction from: {self.pdf_path}")
        
        try:
            # 1. PDF 읽기
            self._read_pdf()
            
            # 2. 테이블 추출
            self._extract_tables()
            
            # 3. 텍스트 전처리
            self._preprocess_text()
            
            # 4. Job Profile 추출
            job_profiles = self._extract_job_profiles()
            
            # 5. AI 보강
            job_profiles = self._enhance_with_ai(job_profiles)
            
            # 6. 검증
            job_profiles, errors, warnings = self._validate_profiles(job_profiles)
            
            # 7. 통계 생성
            stats = self._generate_statistics(job_profiles)
            
            return ExtractionResult(
                job_profiles=job_profiles,
                extraction_stats=stats,
                errors=errors,
                warnings=warnings
            )
            
        except Exception as e:
            logger.error(f"Extraction failed: {str(e)}")
            raise
    
    def _read_pdf(self):
        """PDF 파일 읽기"""
        logger.info("Reading PDF file...")
        
        # PyPDF2로 기본 텍스트 추출
        with open(self.pdf_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            self.metadata = {
                'num_pages': len(pdf_reader.pages),
                'metadata': pdf_reader.metadata
            }
            
            # 페이지별 텍스트 추출
            for i, page in enumerate(pdf_reader.pages):
                page_text = page.extract_text()
                self.pages.append({
                    'page_num': i + 1,
                    'text': page_text
                })
                self.raw_text += page_text + "\n\n"
        
        # pdfplumber로 상세 추출
        with pdfplumber.open(self.pdf_path) as pdf:
            for i, page in enumerate(pdf.pages):
                # 테이블 감지
                tables = page.extract_tables()
                if tables:
                    self.pages[i]['tables'] = tables
                
                # 더 나은 텍스트 추출
                better_text = page.extract_text()
                if better_text and len(better_text) > len(self.pages[i]['text']):
                    self.pages[i]['text'] = better_text
    
    def _extract_tables(self):
        """테이블 데이터 추출"""
        logger.info("Extracting tables...")
        
        try:
            # Camelot으로 테이블 추출 (더 정확함)
            tables = camelot.read_pdf(self.pdf_path, pages='all', flavor='lattice')
            
            for i, table in enumerate(tables):
                self.tables.append({
                    'table_num': i + 1,
                    'page': table.page,
                    'data': table.df,
                    'accuracy': table.accuracy
                })
                
            logger.info(f"Extracted {len(tables)} tables using Camelot")
            
        except Exception as e:
            logger.warning(f"Camelot extraction failed, trying tabula: {str(e)}")
            
            # Tabula 대체 사용
            try:
                tables = tabula.read_pdf(self.pdf_path, pages='all', multiple_tables=True)
                for i, table in enumerate(tables):
                    self.tables.append({
                        'table_num': i + 1,
                        'data': table,
                        'accuracy': 0.8  # 기본값
                    })
                logger.info(f"Extracted {len(tables)} tables using Tabula")
            except Exception as e2:
                logger.error(f"Table extraction failed: {str(e2)}")
    
    def _preprocess_text(self):
        """텍스트 전처리"""
        logger.info("Preprocessing text...")
        
        # 기본 정제
        self.raw_text = re.sub(r'\s+', ' ', self.raw_text)
        self.raw_text = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\xff]', '', self.raw_text)
        
        # 페이지별 정제
        for page in self.pages:
            page['cleaned_text'] = self._clean_text(page['text'])
    
    def _clean_text(self, text: str) -> str:
        """텍스트 정제"""
        # 불필요한 공백 제거
        text = re.sub(r'\s+', ' ', text)
        
        # 특수문자 정규화
        text = text.replace('•', '·')
        text = text.replace('－', '-')
        
        # 줄바꿈 정규화
        text = re.sub(r'\n{3,}', '\n\n', text)
        
        return text.strip()
    
    def _extract_job_profiles(self) -> List[JobProfileData]:
        """Job Profile 추출"""
        logger.info("Extracting job profiles...")
        
        job_profiles = []
        
        # 1. 테이블 기반 추출
        if self.tables:
            table_profiles = self._extract_from_tables()
            job_profiles.extend(table_profiles)
        
        # 2. 텍스트 기반 추출
        text_profiles = self._extract_from_text()
        job_profiles.extend(text_profiles)
        
        # 3. 중복 제거 및 병합
        job_profiles = self._merge_duplicate_profiles(job_profiles)
        
        logger.info(f"Extracted {len(job_profiles)} job profiles")
        return job_profiles
    
    def _extract_from_tables(self) -> List[JobProfileData]:
        """테이블에서 Job Profile 추출"""
        profiles = []
        
        for table_info in self.tables:
            df = table_info['data']
            
            # 테이블 구조 분석
            headers = self._identify_table_headers(df)
            
            if self._is_job_profile_table(headers):
                # 각 행을 Job Profile로 변환
                for _, row in df.iterrows():
                    profile = self._parse_table_row(row, headers)
                    if profile:
                        profile.page_numbers = [table_info.get('page', 0)]
                        profiles.append(profile)
        
        return profiles
    
    def _identify_table_headers(self, df: pd.DataFrame) -> Dict[str, int]:
        """테이블 헤더 식별"""
        headers = {}
        
        # 첫 번째 행이 헤더인지 확인
        first_row = df.iloc[0] if not df.empty else []
        
        for idx, cell in enumerate(first_row):
            cell_str = str(cell).lower()
            
            # 필드 매핑을 통한 헤더 식별
            for field, keywords in self.field_mappings.items():
                for keyword in keywords:
                    if keyword.lower() in cell_str:
                        headers[field] = idx
                        break
        
        return headers
    
    def _is_job_profile_table(self, headers: Dict[str, int]) -> bool:
        """Job Profile 테이블인지 확인"""
        required_fields = ['job_category', 'job_subcategory']
        return any(field in headers for field in required_fields)
    
    def _parse_table_row(self, row: pd.Series, headers: Dict[str, int]) -> Optional[JobProfileData]:
        """테이블 행을 JobProfileData로 파싱"""
        try:
            profile = JobProfileData(
                job_code=self._generate_job_code(row),
                job_title="",
                job_category="",
                job_subcategory="",
                job_level=""
            )
            
            # 헤더 매핑에 따라 데이터 추출
            for field, col_idx in headers.items():
                if col_idx < len(row):
                    value = str(row.iloc[col_idx]).strip()
                    
                    if field == 'job_category':
                        profile.job_category = value
                    elif field == 'job_subcategory':
                        profile.job_subcategory = value
                        profile.job_title = value  # 세부직무를 직무명으로도 사용
                    elif field == 'responsibilities':
                        profile.key_responsibilities = self._parse_list_field(value)
                    elif field == 'competencies':
                        competencies = self._parse_list_field(value)
                        profile.required_competencies = [
                            {'name': comp, 'level': 'required'} for comp in competencies
                        ]
                    elif field == 'qualifications':
                        self._parse_qualifications(value, profile)
                    elif field == 'skills':
                        profile.technical_skills = self._parse_list_field(value)
            
            # 유효성 검사
            if profile.job_category and profile.job_subcategory:
                return profile
            
        except Exception as e:
            logger.warning(f"Failed to parse table row: {str(e)}")
        
        return None
    
    def _generate_job_code(self, row: pd.Series) -> str:
        """Job Code 생성"""
        # 기존 코드가 있으면 사용
        for cell in row:
            if isinstance(cell, str) and re.match(r'^[A-Z]{2,3}-[A-Z]{2,3}-\d{2,3}$', cell):
                return cell
        
        # 없으면 생성
        import hashlib
        row_str = ''.join(str(cell) for cell in row)
        hash_val = hashlib.md5(row_str.encode()).hexdigest()[:6].upper()
        return f"OK-JP-{hash_val}"
    
    def _parse_list_field(self, value: str) -> List[str]:
        """리스트 형태의 필드 파싱"""
        items = []
        
        # 불릿 포인트 패턴
        bullet_matches = self.patterns['bullet_point'].findall(value)
        if bullet_matches:
            items.extend(bullet_matches)
        
        # 번호 리스트 패턴
        numbered_matches = self.patterns['numbered_list'].findall(value)
        if numbered_matches:
            items.extend(numbered_matches)
        
        # 세미콜론 또는 쉼표 구분
        if not items:
            if ';' in value:
                items = [item.strip() for item in value.split(';') if item.strip()]
            elif ',' in value and len(value) > 50:  # 긴 텍스트에서만 쉼표 구분
                items = [item.strip() for item in value.split(',') if item.strip()]
            else:
                items = [value.strip()] if value.strip() else []
        
        return items
    
    def _parse_qualifications(self, value: str, profile: JobProfileData):
        """자격 요건 파싱"""
        # 학력 추출
        edu_match = self.patterns['education'].search(value)
        if edu_match:
            profile.education_requirement = edu_match.group(1).strip()
        
        # 경력 추출
        exp_match = self.patterns['experience'].search(value)
        if exp_match:
            profile.experience_requirement = exp_match.group(1).strip()
        
        # 자격증 추출
        cert_keywords = ['자격증', '자격', 'Certificate', 'Certification']
        for keyword in cert_keywords:
            if keyword in value:
                # 자격증 부분 추출 로직
                cert_section = value.split(keyword)[1].split('\n')[0]
                profile.certifications = self._parse_list_field(cert_section)
    
    def _extract_from_text(self) -> List[JobProfileData]:
        """텍스트에서 Job Profile 추출"""
        profiles = []
        
        # 페이지별로 처리
        for page_info in self.pages:
            text = page_info.get('cleaned_text', page_info['text'])
            
            # Job Profile 섹션 찾기
            profile_sections = self._find_profile_sections(text)
            
            for section in profile_sections:
                profile = self._parse_text_section(section)
                if profile:
                    profile.page_numbers = [page_info['page_num']]
                    profiles.append(profile)
        
        return profiles
    
    def _find_profile_sections(self, text: str) -> List[str]:
        """텍스트에서 Job Profile 섹션 찾기"""
        sections = []
        
        # 섹션 구분 패턴
        section_patterns = [
            r'={3,}([\s\S]+?)(?=={3,}|\Z)',  # === 구분선
            r'[-]{3,}([\s\S]+?)(?=[-]{3,}|\Z)',  # --- 구분선
            r'(?:직무\s*프로필|Job\s*Profile)\s*:?\s*([\s\S]+?)(?=직무\s*프로필|Job\s*Profile|\Z)'
        ]
        
        for pattern in section_patterns:
            matches = re.finditer(pattern, text, re.IGNORECASE)
            for match in matches:
                sections.append(match.group(1))
        
        # 섹션이 없으면 전체 텍스트를 하나의 섹션으로
        if not sections and len(text) > 100:
            sections = [text]
        
        return sections
    
    def _parse_text_section(self, section: str) -> Optional[JobProfileData]:
        """텍스트 섹션을 JobProfileData로 파싱"""
        profile = JobProfileData(
            job_code="",
            job_title="",
            job_category="",
            job_subcategory="",
            job_level="",
            raw_text=section
        )
        
        # 패턴 매칭으로 필드 추출
        for field, pattern in self.patterns.items():
            match = pattern.search(section)
            if match:
                if field == 'job_code':
                    profile.job_code = match.group(1).strip()
                elif field == 'job_title':
                    profile.job_title = match.group(1).strip()
                elif field == 'department':
                    profile.department = match.group(1).strip()
                elif field == 'level':
                    profile.job_level = match.group(1).strip()
                elif field == 'responsibility':
                    responsibilities_text = match.group(1)
                    profile.key_responsibilities = self._parse_list_field(responsibilities_text)
                elif field == 'requirement':
                    self._parse_qualifications(match.group(1), profile)
                elif field == 'competency':
                    competencies_text = match.group(1)
                    competencies = self._parse_list_field(competencies_text)
                    profile.required_competencies = [
                        {'name': comp, 'level': 'required'} for comp in competencies
                    ]
        
        # AI를 통한 추가 정보 추출
        if not profile.job_title and section:
            profile = self._extract_with_nlp(section, profile)
        
        # 유효성 검사
        if profile.job_title or (profile.job_category and profile.job_subcategory):
            if not profile.job_code:
                profile.job_code = self._generate_job_code_from_profile(profile)
            return profile
        
        return None
    
    def _extract_with_nlp(self, text: str, profile: JobProfileData) -> JobProfileData:
        """NLP를 사용한 정보 추출"""
        # 한국어 형태소 분석
        tokens = self.okt.pos(text)
        
        # 명사 추출
        nouns = [word for word, pos in tokens if pos == 'Noun']
        
        # 직무 관련 키워드
        job_keywords = ['매니저', '담당자', '전문가', '팀장', '부장', '과장', '대리', '사원',
                       'Manager', 'Specialist', 'Expert', 'Lead', 'Senior', 'Junior']
        
        # 직무명 추측
        for noun in nouns:
            for keyword in job_keywords:
                if keyword in noun:
                    profile.job_title = noun
                    break
        
        # 부서/직군 키워드
        dept_keywords = ['개발', '영업', '마케팅', '인사', '재무', '기획', '운영', 'IT',
                        'Development', 'Sales', 'Marketing', 'HR', 'Finance', 'Planning']
        
        for noun in nouns:
            for keyword in dept_keywords:
                if keyword in noun:
                    profile.job_category = noun
                    break
        
        return profile
    
    def _generate_job_code_from_profile(self, profile: JobProfileData) -> str:
        """프로필 정보로 Job Code 생성"""
        # 카테고리 약어
        cat_abbr = self._get_abbreviation(profile.job_category) if profile.job_category else "GEN"
        subcat_abbr = self._get_abbreviation(profile.job_subcategory) if profile.job_subcategory else "MISC"
        
        # 고유 번호 생성
        import random
        unique_num = random.randint(100, 999)
        
        return f"OK-{cat_abbr}-{subcat_abbr}-{unique_num}"
    
    def _get_abbreviation(self, text: str) -> str:
        """텍스트 약어 생성"""
        if not text:
            return "UNK"
        
        # 영어인 경우
        if text.isascii():
            words = text.split()
            if len(words) == 1:
                return text[:3].upper()
            else:
                return ''.join(word[0].upper() for word in words[:3])
        
        # 한글인 경우
        else:
            # 초성 추출
            CHOSUNG_LIST = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 
                           'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ']
            result = ""
            for char in text:
                if '가' <= char <= '힣':
                    cho_idx = (ord(char) - ord('가')) // 588
                    result += CHOSUNG_LIST[cho_idx]
            
            # 영어 변환
            chosung_to_eng = {
                'ㄱ': 'G', 'ㄴ': 'N', 'ㄷ': 'D', 'ㄹ': 'R', 'ㅁ': 'M',
                'ㅂ': 'B', 'ㅅ': 'S', 'ㅇ': 'O', 'ㅈ': 'J', 'ㅊ': 'C',
                'ㅋ': 'K', 'ㅌ': 'T', 'ㅍ': 'P', 'ㅎ': 'H'
            }
            
            eng_result = ''.join(chosung_to_eng.get(ch, 'X') for ch in result[:3])
            return eng_result
    
    def _merge_duplicate_profiles(self, profiles: List[JobProfileData]) -> List[JobProfileData]:
        """중복 프로필 병합"""
        merged = {}
        
        for profile in profiles:
            key = f"{profile.job_category}_{profile.job_subcategory}_{profile.job_title}"
            
            if key in merged:
                # 기존 프로필과 병합
                existing = merged[key]
                
                # 더 많은 정보를 가진 것으로 업데이트
                if len(profile.key_responsibilities) > len(existing.key_responsibilities):
                    existing.key_responsibilities = profile.key_responsibilities
                
                if len(profile.required_competencies) > len(existing.required_competencies):
                    existing.required_competencies = profile.required_competencies
                
                # 페이지 번호 병합
                existing.page_numbers.extend(profile.page_numbers)
                existing.page_numbers = list(set(existing.page_numbers))
                
                # 신뢰도 점수 업데이트
                existing.confidence_score = max(existing.confidence_score, profile.confidence_score)
            else:
                merged[key] = profile
        
        return list(merged.values())
    
    def _enhance_with_ai(self, profiles: List[JobProfileData]) -> List[JobProfileData]:
        """AI를 사용한 프로필 보강"""
        logger.info("Enhancing profiles with AI...")
        
        enhanced_profiles = []
        
        for profile in profiles:
            try:
                enhanced = self._enhance_single_profile(profile)
                enhanced_profiles.append(enhanced)
            except Exception as e:
                logger.warning(f"AI enhancement failed for {profile.job_title}: {str(e)}")
                enhanced_profiles.append(profile)
        
        return enhanced_profiles
    
    def _enhance_single_profile(self, profile: JobProfileData) -> JobProfileData:
        """단일 프로필 AI 보강"""
        # GPT를 사용한 보강
        prompt = f"""
        다음 직무 프로필을 분석하고 부족한 정보를 보완해주세요:
        
        직무명: {profile.job_title}
        직군: {profile.job_category}
        직무: {profile.job_subcategory}
        
        주요 책임: {', '.join(profile.key_responsibilities[:3]) if profile.key_responsibilities else '정보 없음'}
        
        다음 정보를 JSON 형식으로 제공해주세요:
        1. job_summary: 직무 개요 (2-3문장)
        2. missing_competencies: 추가로 필요한 역량 리스트
        3. career_path: 경력 개발 경로 (3-5단계)
        4. related_jobs: 관련 직무 리스트
        5. industry_keywords: 업계 관련 키워드
        """
        
        try:
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are an HR specialist analyzing job profiles."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1000,
                temperature=0.7
            )
            
            ai_content = response.choices[0].message.content
            
            # JSON 파싱
            import json
            ai_data = json.loads(ai_content)
            
            # 프로필 업데이트
            if 'job_summary' in ai_data:
                profile.job_summary = ai_data['job_summary']
            
            if 'missing_competencies' in ai_data:
                for comp in ai_data['missing_competencies']:
                    profile.required_competencies.append({
                        'name': comp,
                        'level': 'recommended',
                        'source': 'AI'
                    })
            
            if 'career_path' in ai_data:
                profile.career_path = ai_data['career_path']
            
            if 'related_jobs' in ai_data:
                profile.related_jobs = ai_data['related_jobs']
            
            # 신뢰도 점수 상향
            profile.confidence_score = min(profile.confidence_score + 0.1, 1.0)
            
        except Exception as e:
            logger.warning(f"GPT enhancement failed: {str(e)}")
        
        # 추가 NLP 분석
        profile = self._nlp_analysis(profile)
        
        return profile
    
    def _nlp_analysis(self, profile: JobProfileData) -> JobProfileData:
        """NLP 기반 추가 분석"""
        # 텍스트 결합
        all_text = ' '.join([
            profile.job_title,
            profile.job_summary,
            ' '.join(profile.key_responsibilities),
            ' '.join(comp['name'] for comp in profile.required_competencies)
        ])
        
        if not all_text.strip():
            return profile
        
        # 키워드 추출
        try:
            # TF-IDF 기반 키워드 추출
            vectorizer = TfidfVectorizer(max_features=10, ngram_range=(1, 2))
            tfidf_matrix = vectorizer.fit_transform([all_text])
            feature_names = vectorizer.get_feature_names_out()
            
            # 상위 키워드를 기술 스킬로 추가
            for keyword in feature_names:
                if keyword not in profile.technical_skills and len(keyword) > 2:
                    profile.technical_skills.append(keyword)
        except:
            pass
        
        # 소프트 스킬 자동 감지
        soft_skills_keywords = [
            '리더십', '커뮤니케이션', '협업', '문제해결', '분석력', '창의성',
            '시간관리', '의사소통', '팀워크', '적응력', '주도성', '책임감',
            'Leadership', 'Communication', 'Teamwork', 'Problem-solving',
            'Analytical', 'Creative', 'Time management', 'Initiative'
        ]
        
        for skill in soft_skills_keywords:
            if skill.lower() in all_text.lower() and skill not in profile.soft_skills:
                profile.soft_skills.append(skill)
        
        return profile
    
    def _validate_profiles(self, profiles: List[JobProfileData]) -> Tuple[List[JobProfileData], List[Dict], List[Dict]]:
        """프로필 검증"""
        logger.info("Validating profiles...")
        
        valid_profiles = []
        errors = []
        warnings = []
        
        for i, profile in enumerate(profiles):
            validation_result = self._validate_single_profile(profile, i)
            
            if validation_result['is_valid']:
                profile.validation_status = 'valid'
                valid_profiles.append(profile)
            else:
                if validation_result['is_recoverable']:
                    profile.validation_status = 'warning'
                    valid_profiles.append(profile)
                    warnings.extend(validation_result['warnings'])
                else:
                    profile.validation_status = 'error'
                    errors.extend(validation_result['errors'])
        
        logger.info(f"Validation complete: {len(valid_profiles)} valid, {len(warnings)} warnings, {len(errors)} errors")
        
        return valid_profiles, errors, warnings
    
    def _validate_single_profile(self, profile: JobProfileData, index: int) -> Dict[str, Any]:
        """단일 프로필 검증"""
        result = {
            'is_valid': True,
            'is_recoverable': True,
            'errors': [],
            'warnings': []
        }
        
        # 필수 필드 검증
        if not profile.job_code:
            result['warnings'].append({
                'index': index,
                'field': 'job_code',
                'message': 'Job code is missing, auto-generated',
                'value': profile.job_code
            })
        
        if not profile.job_title and not (profile.job_category and profile.job_subcategory):
            result['is_valid'] = False
            result['is_recoverable'] = False
            result['errors'].append({
                'index': index,
                'field': 'job_title',
                'message': 'Neither job title nor category/subcategory found'
            })
        
        # 데이터 품질 검증
        if len(profile.key_responsibilities) < 3:
            result['warnings'].append({
                'index': index,
                'field': 'key_responsibilities',
                'message': f'Only {len(profile.key_responsibilities)} responsibilities found (recommended: 3+)'
            })
        
        if not profile.required_competencies:
            result['warnings'].append({
                'index': index,
                'field': 'required_competencies',
                'message': 'No competencies specified'
            })
        
        # 신뢰도 점수 계산
        confidence_score = self._calculate_confidence_score(profile)
        profile.confidence_score = confidence_score
        
        if confidence_score < 0.5:
            result['warnings'].append({
                'index': index,
                'field': 'confidence_score',
                'message': f'Low confidence score: {confidence_score:.2f}'
            })
        
        return result
    
    def _calculate_confidence_score(self, profile: JobProfileData) -> float:
        """신뢰도 점수 계산"""
        score = 0.0
        max_score = 10.0
        
        # 필수 필드 체크
        if profile.job_code: score += 1
        if profile.job_title: score += 1
        if profile.job_category: score += 1
        if profile.job_subcategory: score += 1
        
        # 상세 정보 체크
        if len(profile.key_responsibilities) >= 3: score += 1
        if len(profile.key_responsibilities) >= 5: score += 0.5
        
        if len(profile.required_competencies) >= 3: score += 1
        if len(profile.required_competencies) >= 5: score += 0.5
        
        if profile.education_requirement: score += 0.5
        if profile.experience_requirement: score += 0.5
        
        if profile.technical_skills: score += 0.5
        if profile.soft_skills: score += 0.5
        
        if profile.job_summary: score += 0.5
        if profile.career_path: score += 0.5
        
        return min(score / max_score, 1.0)
    
    def _generate_statistics(self, profiles: List[JobProfileData]) -> Dict[str, Any]:
        """통계 생성"""
        stats = {
            'total_profiles': len(profiles),
            'extraction_date': datetime.now().isoformat(),
            'source_file': self.pdf_path,
            'pages_processed': len(self.pages),
            'tables_found': len(self.tables)
        }
        
        # 카테고리별 통계
        categories = {}
        for profile in profiles:
            cat = profile.job_category
            if cat not in categories:
                categories[cat] = 0
            categories[cat] += 1
        stats['categories'] = categories
        
        # 품질 통계
        stats['quality'] = {
            'avg_confidence': sum(p.confidence_score for p in profiles) / len(profiles) if profiles else 0,
            'complete_profiles': sum(1 for p in profiles if p.confidence_score >= 0.8),
            'partial_profiles': sum(1 for p in profiles if 0.5 <= p.confidence_score < 0.8),
            'low_quality_profiles': sum(1 for p in profiles if p.confidence_score < 0.5)
        }
        
        # 데이터 완성도
        stats['completeness'] = {
            'with_responsibilities': sum(1 for p in profiles if p.key_responsibilities),
            'with_competencies': sum(1 for p in profiles if p.required_competencies),
            'with_qualifications': sum(1 for p in profiles if p.education_requirement or p.experience_requirement),
            'with_skills': sum(1 for p in profiles if p.technical_skills or p.soft_skills)
        }
        
        return stats


class JobProfileMigrator:
    """Job Profile 데이터 마이그레이션 클래스"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def migrate_to_database(self, profiles: List[JobProfileData]) -> Dict[str, Any]:
        """데이터베이스로 마이그레이션"""
        self.logger.info(f"Starting database migration for {len(profiles)} profiles...")
        
        results = {
            'success': 0,
            'failed': 0,
            'updated': 0,
            'errors': []
        }
        
        with transaction.atomic():
            for profile in profiles:
                try:
                    self._migrate_single_profile(profile, results)
                except Exception as e:
                    self.logger.error(f"Migration failed for {profile.job_code}: {str(e)}")
                    results['failed'] += 1
                    results['errors'].append({
                        'job_code': profile.job_code,
                        'error': str(e)
                    })
        
        self.logger.info(f"Migration complete: {results['success']} created, {results['updated']} updated, {results['failed']} failed")
        return results
    
    def _migrate_single_profile(self, profile: JobProfileData, results: Dict[str, Any]):
        """단일 프로필 마이그레이션"""
        # 카테고리 생성/조회
        category, _ = JobCategory.objects.get_or_create(
            name=profile.job_category,
            defaults={'description': f'{profile.job_category} 직군'}
        )
        
        # 서브카테고리 생성/조회
        subcategory, _ = JobSubCategory.objects.get_or_create(
            category=category,
            name=profile.job_subcategory,
            defaults={'description': f'{profile.job_subcategory} 직무'}
        )
        
        # JobLevelProfile 생성/업데이트
        job_profile, created = JobLevelProfile.objects.update_or_create(
            job_code=profile.job_code,
            defaults={
                'title': profile.job_title,
                'category': category,
                'subcategory': subcategory,
                'level': profile.job_level or 'All',
                'department': profile.department,
                'summary': profile.job_summary,
                'purpose': profile.job_purpose,
                'is_active': True,
                'metadata': {
                    'extracted_date': profile.extracted_date.isoformat(),
                    'confidence_score': profile.confidence_score,
                    'page_numbers': profile.page_numbers,
                    'validation_status': profile.validation_status
                }
            }
        )
        
        if created:
            results['success'] += 1
        else:
            results['updated'] += 1
        
        # 책임사항 추가
        for responsibility in profile.key_responsibilities:
            JobResponsibility.objects.get_or_create(
                job_profile=job_profile,
                description=responsibility,
                defaults={'priority': 1}
            )
        
        # 역량 추가
        for comp_data in profile.required_competencies:
            JobCompetency.objects.get_or_create(
                job_profile=job_profile,
                name=comp_data['name'],
                defaults={
                    'level': comp_data.get('level', 'required'),
                    'description': comp_data.get('description', '')
                }
            )
        
        # 자격요건 추가
        if profile.education_requirement or profile.experience_requirement:
            JobRequirement.objects.get_or_create(
                job_profile=job_profile,
                requirement_type='qualification',
                defaults={
                    'description': f"학력: {profile.education_requirement}\n경력: {profile.experience_requirement}"
                }
            )
        
        # 기술 스킬 추가
        if profile.technical_skills:
            JobRequirement.objects.get_or_create(
                job_profile=job_profile,
                requirement_type='technical',
                defaults={
                    'description': ', '.join(profile.technical_skills)
                }
            )
        
        # 소프트 스킬 추가
        if profile.soft_skills:
            JobRequirement.objects.get_or_create(
                job_profile=job_profile,
                requirement_type='soft_skill',
                defaults={
                    'description': ', '.join(profile.soft_skills)
                }
            )
        
        # 우대사항 추가
        for pref in profile.preferred_qualifications:
            JobPreferredQualification.objects.get_or_create(
                job_profile=job_profile,
                description=pref
            )
    
    def export_to_json(self, profiles: List[JobProfileData], output_path: str) -> str:
        """JSON으로 내보내기"""
        self.logger.info(f"Exporting {len(profiles)} profiles to JSON...")
        
        # 직렬화 가능한 형태로 변환
        json_data = {
            'metadata': {
                'export_date': datetime.now().isoformat(),
                'total_profiles': len(profiles),
                'version': '1.0'
            },
            'profiles': []
        }
        
        for profile in profiles:
            profile_dict = asdict(profile)
            # datetime 객체 처리
            profile_dict['extracted_date'] = profile_dict['extracted_date'].isoformat()
            json_data['profiles'].append(profile_dict)
        
        # JSON 파일 저장
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(json_data, f, ensure_ascii=False, indent=2)
        
        self.logger.info(f"JSON export complete: {output_file}")
        return str(output_file)
    
    def export_to_excel(self, profiles: List[JobProfileData], output_path: str) -> str:
        """Excel로 내보내기"""
        self.logger.info(f"Exporting {len(profiles)} profiles to Excel...")
        
        # DataFrame 생성
        data = []
        for profile in profiles:
            row = {
                'Job Code': profile.job_code,
                'Job Title': profile.job_title,
                'Category': profile.job_category,
                'Subcategory': profile.job_subcategory,
                'Level': profile.job_level,
                'Department': profile.department,
                'Summary': profile.job_summary,
                'Key Responsibilities': '\n'.join(profile.key_responsibilities),
                'Required Competencies': '\n'.join([c['name'] for c in profile.required_competencies]),
                'Technical Skills': ', '.join(profile.technical_skills),
                'Soft Skills': ', '.join(profile.soft_skills),
                'Education': profile.education_requirement,
                'Experience': profile.experience_requirement,
                'Certifications': ', '.join(profile.certifications),
                'Career Path': ' → '.join(profile.career_path),
                'Confidence Score': profile.confidence_score,
                'Validation Status': profile.validation_status,
                'Page Numbers': ', '.join(map(str, profile.page_numbers))
            }
            data.append(row)
        
        df = pd.DataFrame(data)
        
        # Excel 파일 생성
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
            # 메인 데이터
            df.to_excel(writer, sheet_name='Job Profiles', index=False)
            
            # 통계 시트
            stats_df = self._create_statistics_dataframe(profiles)
            stats_df.to_excel(writer, sheet_name='Statistics', index=False)
            
            # 포맷팅
            workbook = writer.book
            worksheet = writer.sheets['Job Profiles']
            
            # 열 너비 조정
            for column in worksheet.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 50)
                worksheet.column_dimensions[column_letter].width = adjusted_width
        
        self.logger.info(f"Excel export complete: {output_file}")
        return str(output_file)
    
    def _create_statistics_dataframe(self, profiles: List[JobProfileData]) -> pd.DataFrame:
        """통계 DataFrame 생성"""
        # 카테고리별 집계
        category_stats = {}
        for profile in profiles:
            cat = profile.job_category
            if cat not in category_stats:
                category_stats[cat] = {
                    'count': 0,
                    'avg_confidence': 0,
                    'complete': 0
                }
            category_stats[cat]['count'] += 1
            category_stats[cat]['avg_confidence'] += profile.confidence_score
            if profile.confidence_score >= 0.8:
                category_stats[cat]['complete'] += 1
        
        # 평균 계산
        for cat in category_stats:
            if category_stats[cat]['count'] > 0:
                category_stats[cat]['avg_confidence'] /= category_stats[cat]['count']
        
        # DataFrame 변환
        stats_data = []
        for cat, stats in category_stats.items():
            stats_data.append({
                'Category': cat,
                'Count': stats['count'],
                'Average Confidence': f"{stats['avg_confidence']:.2f}",
                'Complete Profiles': stats['complete'],
                'Completion Rate': f"{stats['complete'] / stats['count'] * 100:.1f}%"
            })
        
        return pd.DataFrame(stats_data)


class JobProfileMigrationCommand(BaseCommand):
    """Django management command for migration"""
    help = 'Migrate job profiles from PDF to database'
    
    def add_arguments(self, parser):
        parser.add_argument(
            'pdf_path',
            type=str,
            help='Path to the PDF file'
        )
        parser.add_argument(
            '--output-json',
            type=str,
            help='Path for JSON output'
        )
        parser.add_argument(
            '--output-excel',
            type=str,
            help='Path for Excel output'
        )
        parser.add_argument(
            '--skip-db',
            action='store_true',
            help='Skip database migration'
        )
    
    def handle(self, *args, **options):
        pdf_path = options['pdf_path']
        
        # 추출
        extractor = PDFJobProfileExtractor(pdf_path)
        result = extractor.extract()
        
        self.stdout.write(
            self.style.SUCCESS(
                f'Successfully extracted {len(result.job_profiles)} job profiles'
            )
        )
        
        # 경고 출력
        if result.warnings:
            for warning in result.warnings[:10]:  # 처음 10개만
                self.stdout.write(
                    self.style.WARNING(f"Warning: {warning}")
                )
        
        # 에러 출력
        if result.errors:
            for error in result.errors[:10]:  # 처음 10개만
                self.stdout.write(
                    self.style.ERROR(f"Error: {error}")
                )
        
        # 마이그레이션
        migrator = JobProfileMigrator()
        
        # DB 마이그레이션
        if not options['skip_db']:
            db_results = migrator.migrate_to_database(result.job_profiles)
            self.stdout.write(
                self.style.SUCCESS(
                    f'Database migration: {db_results["success"]} created, '
                    f'{db_results["updated"]} updated, {db_results["failed"]} failed'
                )
            )
        
        # JSON 내보내기
        if options['output_json']:
            json_path = migrator.export_to_json(
                result.job_profiles,
                options['output_json']
            )
            self.stdout.write(
                self.style.SUCCESS(f'JSON exported to: {json_path}')
            )
        
        # Excel 내보내기
        if options['output_excel']:
            excel_path = migrator.export_to_excel(
                result.job_profiles,
                options['output_excel']
            )
            self.stdout.write(
                self.style.SUCCESS(f'Excel exported to: {excel_path}')
            )


# 실행 함수
def migrate_job_profiles(pdf_path: str, output_dir: str = None) -> Dict[str, Any]:
    """Job Profile 마이그레이션 실행"""
    
    # 출력 디렉토리 설정
    if not output_dir:
        output_dir = Path(pdf_path).parent / 'job_profile_output'
    
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # 타임스탬프
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    # 추출
    extractor = PDFJobProfileExtractor(pdf_path)
    result = extractor.extract()
    
    # 마이그레이션
    migrator = JobProfileMigrator()
    
    # 결과 저장
    outputs = {
        'extraction_result': result,
        'outputs': {}
    }
    
    # JSON 저장
    json_path = output_dir / f'job_profiles_{timestamp}.json'
    outputs['outputs']['json'] = migrator.export_to_json(
        result.job_profiles,
        str(json_path)
    )
    
    # Excel 저장
    excel_path = output_dir / f'job_profiles_{timestamp}.xlsx'
    outputs['outputs']['excel'] = migrator.export_to_excel(
        result.job_profiles,
        str(excel_path)
    )
    
    # DB 마이그레이션
    try:
        db_results = migrator.migrate_to_database(result.job_profiles)
        outputs['outputs']['database'] = db_results
    except Exception as e:
        outputs['outputs']['database'] = {'error': str(e)}
    
    # 요약 리포트 생성
    summary_path = output_dir / f'migration_summary_{timestamp}.txt'
    with open(summary_path, 'w', encoding='utf-8') as f:
        f.write("OK Financial Group Job Profile Migration Summary\n")
        f.write("=" * 60 + "\n\n")
        f.write(f"Source: {pdf_path}\n")
        f.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        f.write(f"Extraction Results:\n")
        f.write(f"- Total profiles extracted: {len(result.job_profiles)}\n")
        f.write(f"- Pages processed: {result.extraction_stats['pages_processed']}\n")
        f.write(f"- Tables found: {result.extraction_stats['tables_found']}\n")
        f.write(f"- Warnings: {len(result.warnings)}\n")
        f.write(f"- Errors: {len(result.errors)}\n\n")
        
        f.write("Quality Statistics:\n")
        quality = result.extraction_stats['quality']
        f.write(f"- Average confidence: {quality['avg_confidence']:.2f}\n")
        f.write(f"- Complete profiles: {quality['complete_profiles']}\n")
        f.write(f"- Partial profiles: {quality['partial_profiles']}\n")
        f.write(f"- Low quality profiles: {quality['low_quality_profiles']}\n\n")
        
        f.write("Output Files:\n")
        for key, path in outputs['outputs'].items():
            if isinstance(path, str):
                f.write(f"- {key}: {path}\n")
    
    outputs['outputs']['summary'] = str(summary_path)
    
    return outputs


# 테스트 함수
def test_extraction():
    """추출 테스트"""
    # 테스트 PDF 경로
    test_pdf = r"C:\Users\apro\OneDrive\Desktop\설명회자료\OK_Job Profile.pdf"
    
    if not Path(test_pdf).exists():
        print(f"Test PDF not found: {test_pdf}")
        return
    
    # 추출 실행
    result = migrate_job_profiles(test_pdf)
    
    print("\nMigration Complete!")
    print(f"Profiles extracted: {len(result['extraction_result'].job_profiles)}")
    print(f"Outputs saved to: {Path(result['outputs']['json']).parent}")
    
    # 샘플 출력
    if result['extraction_result'].job_profiles:
        sample = result['extraction_result'].job_profiles[0]
        print(f"\nSample Profile:")
        print(f"- Job Code: {sample.job_code}")
        print(f"- Job Title: {sample.job_title}")
        print(f"- Category: {sample.job_category}")
        print(f"- Confidence: {sample.confidence_score:.2f}")


if __name__ == "__main__":
    test_extraction()