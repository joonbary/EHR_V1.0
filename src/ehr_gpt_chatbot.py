"""
풍성한 GPT 기반 eHR 인사 챗봇
Conversational AI-powered HR chatbot with multimodal capabilities
Generated by: Conversational UX designer + LLM HR analyst + API integrator
"""

from django.views import View
from django.views.generic import TemplateView
from django.http import JsonResponse, HttpResponse, StreamingHttpResponse
from django.utils.decorators import method_decorator
from django.contrib.auth.decorators import login_required
from django.core.cache import cache
from django.db.models import Q, Count, Avg
from django.utils import timezone
from django.template.loader import render_to_string
import openai
import json
import re
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Generator
from dataclasses import dataclass, field
from enum import Enum
import asyncio
from collections import defaultdict
import base64
from io import BytesIO
import requests

# Import existing modules
from employees.models import Employee, Department
from certifications.models import GrowthLevelCertification, CertificationCheckLog
from trainings.models import TrainingCourse, TrainingEnrollment
from evaluations.models import Evaluation
from job_profiles.models import JobLevelProfile, LeaderRecommendation
from leader_kpi_dashboard import LeaderKPIAnalytics
from leader_ai_assistant import LeadershipAIAssistant
from leader_strategy_reportgen import LeadershipStrategyReportGenerator, ReportType, ReportFormat


class ConversationIntent(Enum):
    """대화 의도 분류"""
    # 정보 조회
    PERSONAL_INFO = "personal_info"
    GROWTH_LEVEL = "growth_level"
    CERTIFICATION_CHECK = "certification_check"
    TRAINING_INQUIRY = "training_inquiry"
    EVALUATION_STATUS = "evaluation_status"
    LEADER_RECOMMENDATION = "leader_recommendation"
    
    # 액션 요청
    CERTIFICATION_APPLY = "certification_apply"
    TRAINING_ENROLLMENT = "training_enrollment"
    REPORT_REQUEST = "report_request"
    SCHEDULE_MEETING = "schedule_meeting"
    
    # 분석 및 조언
    CAREER_ADVICE = "career_advice"
    SKILL_GAP_ANALYSIS = "skill_gap_analysis"
    PERFORMANCE_FEEDBACK = "performance_feedback"
    DEVELOPMENT_PLANNING = "development_planning"
    
    # 일반 대화
    GREETING = "greeting"
    HELP = "help"
    CHITCHAT = "chitchat"
    FAREWELL = "farewell"
    
    # 관리자 기능
    TEAM_ANALYTICS = "team_analytics"
    KPI_DASHBOARD = "kpi_dashboard"
    STRATEGIC_PLANNING = "strategic_planning"


class ResponseMode(Enum):
    """응답 모드"""
    SIMPLE = "simple"           # 간단한 답변
    DETAILED = "detailed"       # 상세한 설명
    VISUAL = "visual"          # 차트/그래프 포함
    INTERACTIVE = "interactive" # 버튼/옵션 포함
    MULTIMODAL = "multimodal"  # 텍스트+이미지+차트


class ConversationContext(Enum):
    """대화 컨텍스트"""
    INITIAL = "initial"
    FOLLOWUP = "followup"
    CLARIFICATION = "clarification"
    CONFIRMATION = "confirmation"
    COMPLETION = "completion"


@dataclass
class UserProfile:
    """사용자 프로필"""
    employee_id: str
    name: str
    position: str
    department: str
    role: str  # employee, manager, hr, executive
    preferences: Dict[str, Any] = field(default_factory=dict)
    conversation_history: List[Dict[str, Any]] = field(default_factory=list)
    bookmarks: List[str] = field(default_factory=list)


@dataclass
class ConversationState:
    """대화 상태"""
    session_id: str
    user_profile: UserProfile
    current_intent: Optional[ConversationIntent] = None
    context: ConversationContext = ConversationContext.INITIAL
    context_data: Dict[str, Any] = field(default_factory=dict)
    pending_actions: List[Dict[str, Any]] = field(default_factory=list)
    clarification_needed: Optional[Dict[str, Any]] = None
    last_activity: datetime = field(default_factory=datetime.now)


@dataclass
class ChatbotResponse:
    """챗봇 응답"""
    message: str
    intent: ConversationIntent
    confidence: float
    mode: ResponseMode
    suggestions: List[str] = field(default_factory=list)
    actions: List[Dict[str, Any]] = field(default_factory=list)
    visualizations: List[Dict[str, Any]] = field(default_factory=list)
    attachments: List[Dict[str, Any]] = field(default_factory=list)
    quick_replies: List[Dict[str, str]] = field(default_factory=list)
    bookmarkable: bool = False
    bookmark_data: Optional[Dict[str, Any]] = None


class EHRGPTChatbot:
    """eHR GPT 챗봇 엔진"""
    
    def __init__(self):
        self.openai_api_key = settings.OPENAI_API_KEY
        openai.api_key = self.openai_api_key
        
        # GPT 설정
        self.model = "gpt-4"
        self.vision_model = "gpt-4-vision-preview"
        self.max_tokens = 1500
        self.temperature = 0.8
        
        # 서비스 통합
        self.kpi_analytics = LeaderKPIAnalytics()
        self.ai_assistant = LeadershipAIAssistant()
        self.report_generator = LeadershipStrategyReportGenerator()
        
        # 대화 상태 관리
        self.conversation_states = {}
        self.session_timeout = 3600  # 1시간
        
        # 시스템 프롬프트
        self.system_prompt = """
        You are an advanced HR assistant for the eHR system, designed to help employees with:
        1. Career development and growth planning
        2. Certification and training inquiries
        3. Performance feedback and evaluation
        4. Leadership development opportunities
        5. General HR questions and support
        
        Your personality:
        - Friendly, professional, and encouraging
        - Proactive in offering relevant suggestions
        - Context-aware and personalized responses
        - Clear and concise communication
        - Empathetic and supportive tone
        
        Key capabilities:
        - Access to employee data and HR systems
        - Real-time KPI and analytics
        - Training recommendations
        - Career path guidance
        - Report generation
        
        Always:
        - Greet users warmly
        - Understand their needs before responding
        - Provide actionable advice
        - Offer follow-up questions
        - Respect privacy and confidentiality
        
        Respond in the same language as the user's query.
        Use emojis sparingly but appropriately to enhance friendliness.
        """
        
        # 의도 패턴
        self.intent_patterns = self._initialize_intent_patterns()
        
    def _initialize_intent_patterns(self) -> Dict[ConversationIntent, List[str]]:
        """의도 인식 패턴 초기화"""
        return {
            ConversationIntent.GREETING: [
                r'안녕|hello|hi|반가워|좋은\s*(아침|오후|저녁)',
                r'처음\s*뵙겠습니다|nice to meet'
            ],
            ConversationIntent.PERSONAL_INFO: [
                r'내\s*(정보|프로필|인사.*정보)|my\s*(info|profile)',
                r'직급|부서|입사일|personal\s*information'
            ],
            ConversationIntent.GROWTH_LEVEL: [
                r'성장\s*레벨|growth\s*level|현재\s*레벨',
                r'레벨.*확인|what.*my.*level'
            ],
            ConversationIntent.CERTIFICATION_CHECK: [
                r'인증.*체크|인증.*확인|certification.*check',
                r'인증.*요건|자격.*확인|eligible.*certification'
            ],
            ConversationIntent.TRAINING_INQUIRY: [
                r'교육|training|course|강의|수업',
                r'수강.*신청|교육.*추천|recommend.*training'
            ],
            ConversationIntent.EVALUATION_STATUS: [
                r'평가|evaluation|performance|성과',
                r'평가.*결과|평가.*등급|performance.*rating'
            ],
            ConversationIntent.LEADER_RECOMMENDATION: [
                r'리더.*추천|leader.*recommendation|승진',
                r'리더십.*기회|leadership.*opportunity'
            ],
            ConversationIntent.CAREER_ADVICE: [
                r'경력.*조언|career.*advice|커리어.*상담',
                r'앞으로.*어떻게|성장.*방향|career.*path'
            ],
            ConversationIntent.HELP: [
                r'도움|help|사용법|how\s*to',
                r'무엇.*할.*있|what.*can.*do'
            ],
            ConversationIntent.TEAM_ANALYTICS: [
                r'팀.*현황|team.*analytics|부서.*분석',
                r'팀원.*성과|team.*performance'
            ],
            ConversationIntent.KPI_DASHBOARD: [
                r'kpi|대시보드|dashboard|지표',
                r'리더십.*kpi|leadership.*metrics'
            ]
        }
    
    async def process_message(self, user_id: str, message: str, 
                            attachments: List[Dict[str, Any]] = None,
                            session_id: Optional[str] = None) -> ChatbotResponse:
        """메시지 처리 메인 함수"""
        
        # 세션 관리
        if not session_id:
            session_id = str(uuid.uuid4())
        
        # 대화 상태 로드 또는 생성
        state = self._get_or_create_conversation_state(user_id, session_id)
        
        # 멀티모달 입력 처리
        if attachments:
            message = await self._process_multimodal_input(message, attachments)
        
        # 의도 분석
        intent, confidence = self._analyze_intent(message, state)
        state.current_intent = intent
        
        # 컨텍스트 업데이트
        self._update_context(state, message, intent)
        
        # 응답 생성
        response = await self._generate_response(state, message, intent, confidence)
        
        # 대화 기록 저장
        self._save_conversation_turn(state, message, response)
        
        # 상태 저장
        self._save_conversation_state(session_id, state)
        
        return response
    
    def _get_or_create_conversation_state(self, user_id: str, 
                                        session_id: str) -> ConversationState:
        """대화 상태 조회 또는 생성"""
        # 캐시에서 조회
        cache_key = f"chatbot_session_{session_id}"
        state = cache.get(cache_key)
        
        if state:
            return state
        
        # 새 상태 생성
        try:
            employee = Employee.objects.get(id=user_id)
            user_profile = UserProfile(
                employee_id=str(employee.id),
                name=employee.name,
                position=employee.position,
                department=employee.department.name if employee.department else "",
                role=self._determine_user_role(employee),
                preferences=self._load_user_preferences(employee)
            )
        except Employee.DoesNotExist:
            # 기본 프로필
            user_profile = UserProfile(
                employee_id=user_id,
                name="User",
                position="",
                department="",
                role="employee"
            )
        
        state = ConversationState(
            session_id=session_id,
            user_profile=user_profile
        )
        
        return state
    
    def _determine_user_role(self, employee: Employee) -> str:
        """사용자 역할 결정"""
        if employee.user.groups.filter(name='Executive').exists():
            return 'executive'
        elif employee.user.groups.filter(name='HR').exists():
            return 'hr'
        elif Employee.objects.filter(manager=employee).exists():
            return 'manager'
        else:
            return 'employee'
    
    def _load_user_preferences(self, employee: Employee) -> Dict[str, Any]:
        """사용자 선호 설정 로드"""
        # 실제 구현시 사용자 설정 모델에서 로드
        return {
            'language': 'ko',
            'response_mode': ResponseMode.DETAILED.value,
            'notification_enabled': True,
            'preferred_training_time': 'afternoon'
        }
    
    def _analyze_intent(self, message: str, state: ConversationState) -> Tuple[ConversationIntent, float]:
        """의도 분석"""
        message_lower = message.lower()
        
        # 패턴 매칭
        for intent, patterns in self.intent_patterns.items():
            for pattern in patterns:
                if re.search(pattern, message_lower):
                    return intent, 0.9
        
        # GPT 기반 의도 분류
        if state.context == ConversationContext.FOLLOWUP:
            # 후속 대화인 경우 이전 의도 참고
            return state.current_intent, 0.8
        
        # GPT로 의도 분류
        intent_prompt = f"""
        Classify the user's intent from this message: "{message}"
        
        Available intents:
        - PERSONAL_INFO: Asking about personal HR information
        - GROWTH_LEVEL: Inquiring about growth levels
        - CERTIFICATION_CHECK: Checking certification eligibility
        - TRAINING_INQUIRY: Questions about training courses
        - EVALUATION_STATUS: Performance evaluation queries
        - LEADER_RECOMMENDATION: Leadership opportunities
        - CAREER_ADVICE: Career development guidance
        - TEAM_ANALYTICS: Team performance analysis (managers)
        - KPI_DASHBOARD: KPI and metrics queries
        - HELP: General help or how-to questions
        - GREETING: Greetings and pleasantries
        - CHITCHAT: General conversation
        
        Return only the intent name.
        """
        
        try:
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are an intent classifier."},
                    {"role": "user", "content": intent_prompt}
                ],
                max_tokens=50,
                temperature=0.3
            )
            
            intent_str = response.choices[0].message.content.strip().upper()
            intent = ConversationIntent[intent_str]
            return intent, 0.85
            
        except:
            # 기본값
            return ConversationIntent.CHITCHAT, 0.5
    
    def _update_context(self, state: ConversationState, message: str, 
                       intent: ConversationIntent):
        """대화 컨텍스트 업데이트"""
        # 이전 대화와의 관련성 확인
        if state.conversation_history:
            last_turn = state.conversation_history[-1]
            time_diff = (datetime.now() - last_turn['timestamp']).total_seconds()
            
            if time_diff < 300:  # 5분 이내
                if last_turn.get('requires_followup'):
                    state.context = ConversationContext.FOLLOWUP
                elif '?' in message and len(message.split()) < 5:
                    state.context = ConversationContext.CLARIFICATION
            else:
                state.context = ConversationContext.INITIAL
        
        # 의도별 컨텍스트 데이터 설정
        if intent == ConversationIntent.CERTIFICATION_CHECK:
            state.context_data['requires_level'] = True
            state.context_data['requires_job'] = True
        elif intent == ConversationIntent.TRAINING_ENROLLMENT:
            state.context_data['requires_course_id'] = True
            state.context_data['requires_confirmation'] = True
    
    async def _generate_response(self, state: ConversationState, message: str,
                               intent: ConversationIntent, confidence: float) -> ChatbotResponse:
        """응답 생성"""
        # 사용자 데이터 수집
        user_data = self._collect_user_data(state.user_profile)
        
        # 의도별 처리
        if intent == ConversationIntent.GREETING:
            return await self._handle_greeting(state, user_data)
        
        elif intent == ConversationIntent.PERSONAL_INFO:
            return await self._handle_personal_info(state, user_data)
        
        elif intent == ConversationIntent.GROWTH_LEVEL:
            return await self._handle_growth_level(state, user_data)
        
        elif intent == ConversationIntent.CERTIFICATION_CHECK:
            return await self._handle_certification_check(state, user_data, message)
        
        elif intent == ConversationIntent.TRAINING_INQUIRY:
            return await self._handle_training_inquiry(state, user_data, message)
        
        elif intent == ConversationIntent.EVALUATION_STATUS:
            return await self._handle_evaluation_status(state, user_data)
        
        elif intent == ConversationIntent.LEADER_RECOMMENDATION:
            return await self._handle_leader_recommendation(state, user_data)
        
        elif intent == ConversationIntent.CAREER_ADVICE:
            return await self._handle_career_advice(state, user_data, message)
        
        elif intent == ConversationIntent.TEAM_ANALYTICS:
            return await self._handle_team_analytics(state, user_data)
        
        elif intent == ConversationIntent.KPI_DASHBOARD:
            return await self._handle_kpi_dashboard(state, user_data, message)
        
        elif intent == ConversationIntent.HELP:
            return await self._handle_help(state)
        
        else:
            # 일반 대화 처리
            return await self._handle_general_conversation(state, message, user_data)
    
    def _collect_user_data(self, profile: UserProfile) -> Dict[str, Any]:
        """사용자 관련 데이터 수집"""
        data = {
            'profile': profile,
            'current_date': timezone.now()
        }
        
        try:
            employee = Employee.objects.get(id=profile.employee_id)
            
            # 성장 레벨 정보
            data['growth_level'] = {
                'current': getattr(employee, 'growth_level', 'Lv.1'),
                'certifications': GrowthLevelCertification.objects.filter(
                    employee=employee,
                    status='CERTIFIED'
                ).order_by('-certified_date')
            }
            
            # 최근 평가
            data['latest_evaluation'] = Evaluation.objects.filter(
                employee=employee
            ).order_by('-evaluation_year', '-evaluation_quarter').first()
            
            # 교육 이력
            data['training_history'] = TrainingEnrollment.objects.filter(
                employee=employee
            ).order_by('-enrolled_date')[:5]
            
            # 리더 추천
            data['leader_recommendations'] = LeaderRecommendation.objects.filter(
                employee=employee,
                is_active=True
            ).order_by('-recommendation_date')
            
            # 팀 정보 (매니저인 경우)
            if profile.role in ['manager', 'executive']:
                data['team_members'] = Employee.objects.filter(
                    manager=employee,
                    is_active=True
                )
                
        except Employee.DoesNotExist:
            pass
        
        return data
    
    async def _handle_greeting(self, state: ConversationState, 
                             user_data: Dict[str, Any]) -> ChatbotResponse:
        """인사 처리"""
        hour = datetime.now().hour
        time_greeting = "좋은 아침입니다" if hour < 12 else "좋은 오후입니다" if hour < 18 else "좋은 저녁입니다"
        
        message = f"""
{time_greeting}, {state.user_profile.name}님! 😊

eHR 챗봇 서비스에 오신 것을 환영합니다.
오늘은 어떤 도움이 필요하신가요?
"""
        
        # 개인화된 제안
        suggestions = []
        
        # 최근 인증 체크가 있었다면
        if user_data.get('growth_level', {}).get('certifications'):
            suggestions.append("성장레벨 인증 진행상황 확인")
        
        # 교육 추천
        suggestions.append("맞춤형 교육과정 추천받기")
        
        # 평가 시즌이면
        current_month = datetime.now().month
        if current_month in [3, 6, 9, 12]:
            suggestions.append("평가 결과 확인하기")
        
        # 매니저라면
        if state.user_profile.role in ['manager', 'executive']:
            suggestions.append("팀 성과 대시보드 보기")
        
        quick_replies = [
            {"text": "내 정보 확인", "payload": "PERSONAL_INFO"},
            {"text": "성장레벨 체크", "payload": "GROWTH_LEVEL"},
            {"text": "교육 과정 찾기", "payload": "TRAINING_INQUIRY"},
            {"text": "도움말", "payload": "HELP"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.GREETING,
            confidence=1.0,
            mode=ResponseMode.INTERACTIVE,
            suggestions=suggestions,
            quick_replies=quick_replies
        )
    
    async def _handle_personal_info(self, state: ConversationState,
                                  user_data: Dict[str, Any]) -> ChatbotResponse:
        """개인정보 조회"""
        profile = state.user_profile
        
        # 상세 정보 구성
        info_sections = []
        
        # 기본 정보
        basic_info = f"""
📋 **기본 정보**
• 성명: {profile.name}
• 사번: {profile.employee_id}
• 직급: {profile.position}
• 부서: {profile.department}
"""
        info_sections.append(basic_info)
        
        # 성장 레벨
        growth_info = f"""
📈 **성장 레벨**
• 현재 레벨: {user_data.get('growth_level', {}).get('current', 'Lv.1')}
• 인증 이력: {len(user_data.get('growth_level', {}).get('certifications', []))}건
"""
        info_sections.append(growth_info)
        
        # 최근 평가
        if user_data.get('latest_evaluation'):
            eval_data = user_data['latest_evaluation']
            eval_info = f"""
📊 **최근 평가**
• 평가 기간: {eval_data.evaluation_year}년 {eval_data.evaluation_quarter}분기
• 평가 등급: {eval_data.grade}
• 종합 점수: {eval_data.total_score}점
"""
            info_sections.append(eval_info)
        
        # 교육 이수
        training_count = user_data.get('training_history', []).count()
        if training_count > 0:
            training_info = f"""
📚 **교육 현황**
• 총 이수 과정: {training_count}개
• 최근 교육: {user_data['training_history'][0].course.title if training_count > 0 else '-'}
"""
            info_sections.append(training_info)
        
        message = "\n".join(info_sections)
        
        # 시각화 추가
        visualizations = [
            {
                'type': 'info_card',
                'title': '나의 HR 프로필',
                'data': {
                    'employee_id': profile.employee_id,
                    'name': profile.name,
                    'position': profile.position,
                    'department': profile.department,
                    'growth_level': user_data.get('growth_level', {}).get('current', 'Lv.1')
                }
            }
        ]
        
        # 관련 액션
        actions = [
            {
                'type': 'button',
                'text': '상세 이력 보기',
                'action': 'VIEW_DETAILED_HISTORY'
            },
            {
                'type': 'button',
                'text': '정보 수정 요청',
                'action': 'REQUEST_INFO_UPDATE'
            }
        ]
        
        quick_replies = [
            {"text": "성장레벨 인증 체크", "payload": "CERTIFICATION_CHECK"},
            {"text": "교육 이력 상세보기", "payload": "TRAINING_HISTORY"},
            {"text": "평가 이력 조회", "payload": "EVALUATION_HISTORY"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.PERSONAL_INFO,
            confidence=0.95,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            actions=actions,
            quick_replies=quick_replies,
            bookmarkable=True,
            bookmark_data={'type': 'personal_info', 'employee_id': profile.employee_id}
        )
    
    async def _handle_growth_level(self, state: ConversationState,
                                 user_data: Dict[str, Any]) -> ChatbotResponse:
        """성장레벨 조회"""
        current_level = user_data.get('growth_level', {}).get('current', 'Lv.1')
        certifications = user_data.get('growth_level', {}).get('certifications', [])
        
        # 다음 레벨 계산
        level_map = {
            'Lv.1': 'Lv.2', 'Lv.2': 'Lv.3',
            'Lv.3': 'Lv.4', 'Lv.4': 'Lv.5',
            'Lv.5': 'Lv.5'
        }
        next_level = level_map.get(current_level, 'Lv.2')
        
        # 인증 체크 (간단 버전)
        from certifications.certification_services import CertificationService
        cert_service = CertificationService()
        
        try:
            employee = Employee.objects.get(id=state.user_profile.employee_id)
            cert_result = cert_service.check_growth_level_certification(
                employee=employee,
                target_level=next_level
            )
            
            readiness = cert_result.get('certification_result', '미충족')
            progress = cert_result.get('progress', {}).get('overall', 0)
            
        except:
            readiness = '확인 필요'
            progress = 0
        
        message = f"""
🎯 **{state.user_profile.name}님의 성장레벨 현황**

현재 레벨: **{current_level}**
다음 목표: **{next_level}**

📊 **인증 준비도**
• 상태: {readiness}
• 진행률: {progress:.1f}%

"""
        
        # 진행률 시각화
        if readiness == '충족':
            message += "✅ 축하합니다! 다음 레벨 인증을 신청할 수 있습니다.\n"
        elif readiness == '부분충족':
            message += "📈 조금만 더 노력하시면 인증 요건을 충족할 수 있습니다!\n"
        else:
            message += "💪 성장을 위해 함께 계획을 세워보아요.\n"
        
        # 인증 이력
        if certifications:
            message += "\n📜 **인증 이력**\n"
            for cert in certifications[:3]:
                message += f"• {cert.target_level} - {cert.certified_date.strftime('%Y.%m.%d')}\n"
        
        # 시각화
        visualizations = [
            {
                'type': 'progress_chart',
                'title': '성장레벨 진행상황',
                'data': {
                    'current': current_level,
                    'target': next_level,
                    'progress': progress,
                    'areas': {
                        '평가': cert_result.get('progress', {}).get('evaluation', 0),
                        '교육': cert_result.get('progress', {}).get('training', 0),
                        '스킬': cert_result.get('progress', {}).get('skills', 0),
                        '경력': cert_result.get('progress', {}).get('experience', 0)
                    }
                }
            }
        ]
        
        # 추천 액션
        quick_replies = []
        if readiness == '충족':
            quick_replies.append({"text": "인증 신청하기", "payload": "APPLY_CERTIFICATION"})
        else:
            quick_replies.extend([
                {"text": "부족한 요건 확인", "payload": "CHECK_MISSING_REQUIREMENTS"},
                {"text": "교육 추천받기", "payload": "GET_TRAINING_RECOMMENDATIONS"},
                {"text": "성장 계획 세우기", "payload": "CREATE_DEVELOPMENT_PLAN"}
            ])
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.GROWTH_LEVEL,
            confidence=0.9,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            quick_replies=quick_replies,
            bookmarkable=True,
            bookmark_data={'type': 'growth_level', 'level': current_level}
        )
    
    async def _handle_certification_check(self, state: ConversationState,
                                        user_data: Dict[str, Any],
                                        message: str) -> ChatbotResponse:
        """인증 체크 처리"""
        # 목표 레벨 추출
        level_match = re.search(r'Lv\.?\s*(\d)', message)
        if level_match:
            target_level = f"Lv.{level_match.group(1)}"
        else:
            # 명확화 필요
            if state.context != ConversationContext.CLARIFICATION:
                return ChatbotResponse(
                    message="어떤 레벨의 인증을 확인하고 싶으신가요?",
                    intent=ConversationIntent.CERTIFICATION_CHECK,
                    confidence=0.8,
                    mode=ResponseMode.INTERACTIVE,
                    quick_replies=[
                        {"text": "Lv.2", "payload": "CHECK_LV2"},
                        {"text": "Lv.3", "payload": "CHECK_LV3"},
                        {"text": "Lv.4", "payload": "CHECK_LV4"},
                        {"text": "Lv.5", "payload": "CHECK_LV5"}
                    ]
                )
            else:
                # 기본값 사용
                current_level = user_data.get('growth_level', {}).get('current', 'Lv.1')
                level_map = {'Lv.1': 'Lv.2', 'Lv.2': 'Lv.3', 'Lv.3': 'Lv.4', 'Lv.4': 'Lv.5'}
                target_level = level_map.get(current_level, 'Lv.2')
        
        # 인증 체크 수행
        from certifications.certification_services import CertificationService
        cert_service = CertificationService()
        
        try:
            employee = Employee.objects.get(id=state.user_profile.employee_id)
            cert_result = cert_service.check_growth_level_certification(
                employee=employee,
                target_level=target_level
            )
            
            # 결과 메시지 구성
            message = f"""
🔍 **{target_level} 인증 체크 결과**

종합 결과: **{cert_result['certification_result']}**
전체 진행률: **{cert_result.get('progress', {}).get('overall', 0):.1f}%**

📋 **영역별 충족 현황**
"""
            
            # 체크 항목별 상태
            checks = cert_result.get('checks', {})
            check_items = [
                ('평가', checks.get('evaluation', False), cert_result.get('progress', {}).get('evaluation', 0)),
                ('교육', checks.get('training', False), cert_result.get('progress', {}).get('training', 0)),
                ('스킬', checks.get('skills', False), cert_result.get('progress', {}).get('skills', 0)),
                ('경력', checks.get('experience', False), cert_result.get('progress', {}).get('experience', 0))
            ]
            
            for item, passed, progress in check_items:
                icon = "✅" if passed else "❌"
                message += f"{icon} {item}: {progress:.0f}%\n"
            
            # 부족한 요건 상세
            if cert_result['details']['missing_courses']:
                message += f"\n📚 **필수 교육 미이수**\n"
                for course in cert_result['details']['missing_courses']:
                    message += f"• {course}\n"
            
            if cert_result['details']['missing_skills']:
                message += f"\n🛠️ **부족한 스킬**\n"
                for skill in cert_result['details']['missing_skills']:
                    message += f"• {skill}\n"
            
            # 예상 인증일
            if cert_result.get('expected_certification_date'):
                message += f"\n📅 예상 인증 가능일: {cert_result['expected_certification_date']}\n"
            
            # 권고사항
            if cert_result.get('recommendations'):
                message += "\n💡 **권고사항**\n"
                for rec in cert_result['recommendations'][:3]:
                    message += f"• {rec}\n"
            
            # 시각화
            visualizations = [
                {
                    'type': 'radar_chart',
                    'title': '인증 요건 충족도',
                    'data': {
                        'labels': ['평가', '교육', '스킬', '경력'],
                        'values': [
                            cert_result.get('progress', {}).get('evaluation', 0),
                            cert_result.get('progress', {}).get('training', 0),
                            cert_result.get('progress', {}).get('skills', 0),
                            cert_result.get('progress', {}).get('experience', 0)
                        ]
                    }
                }
            ]
            
            # 액션 버튼
            actions = []
            if cert_result['certification_result'] == '충족':
                actions.append({
                    'type': 'button',
                    'text': '인증 신청하기',
                    'action': 'APPLY_CERTIFICATION',
                    'data': {'level': target_level}
                })
            else:
                if cert_result['details']['missing_courses']:
                    actions.append({
                        'type': 'button',
                        'text': '필수 교육 신청',
                        'action': 'ENROLL_REQUIRED_COURSES',
                        'data': {'courses': cert_result['details']['missing_courses']}
                    })
                
                actions.append({
                    'type': 'button',
                    'text': '성장 계획 수립',
                    'action': 'CREATE_GROWTH_PLAN',
                    'data': {'target_level': target_level}
                })
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.CERTIFICATION_CHECK,
                confidence=0.95,
                mode=ResponseMode.VISUAL,
                visualizations=visualizations,
                actions=actions,
                bookmarkable=True,
                bookmark_data={
                    'type': 'certification_check',
                    'target_level': target_level,
                    'result': cert_result['certification_result']
                }
            )
            
        except Exception as e:
            return ChatbotResponse(
                message=f"인증 체크 중 오류가 발생했습니다: {str(e)}",
                intent=ConversationIntent.CERTIFICATION_CHECK,
                confidence=0.5,
                mode=ResponseMode.SIMPLE
            )
    
    async def _handle_training_inquiry(self, state: ConversationState,
                                     user_data: Dict[str, Any],
                                     message: str) -> ChatbotResponse:
        """교육 문의 처리"""
        # 키워드 추출
        keywords = self._extract_keywords(message)
        
        # 추천 교육 조회
        from trainings.training_services import TrainingRecommendationService
        training_service = TrainingRecommendationService()
        
        try:
            employee = Employee.objects.get(id=state.user_profile.employee_id)
            
            # 맞춤형 추천
            recommendations = training_service.get_employee_training_recommendations(
                employee=employee,
                max_recommendations=5
            )
            
            courses = recommendations.get('recommendations', [])
            
            if courses:
                message = f"""
📚 **{state.user_profile.name}님을 위한 맞춤 교육 추천**

"""
                
                for i, course in enumerate(courses, 1):
                    message += f"""
**{i}. {course['title']}**
• 코드: {course['course_code']}
• 카테고리: {course['category']}
• 교육시간: {course['duration_hours']}시간
• 매칭도: {course['match_score']:.0f}%
• 추천 이유: {course['recommendation_reason']}

"""
                
                # 학습 로드맵
                if recommendations.get('roadmap'):
                    message += "\n📅 **추천 학습 로드맵**\n"
                    for month_plan in recommendations['roadmap'][:3]:
                        message += f"\n{month_plan['month']}개월차:\n"
                        for course in month_plan['courses']:
                            message += f"• {course['title']}\n"
                
            else:
                message = "현재 추천할 교육과정이 없습니다. 키워드로 검색해보시겠어요?"
            
            # 시각화
            visualizations = []
            if courses:
                visualizations.append({
                    'type': 'course_cards',
                    'title': '추천 교육과정',
                    'data': courses[:3]
                })
            
            # 액션
            actions = []
            for course in courses[:3]:
                actions.append({
                    'type': 'button',
                    'text': f"{course['title']} 신청",
                    'action': 'ENROLL_COURSE',
                    'data': {'course_id': course['course_id']}
                })
            
            quick_replies = [
                {"text": "전체 교육 목록", "payload": "VIEW_ALL_COURSES"},
                {"text": "내 교육 이력", "payload": "MY_TRAINING_HISTORY"},
                {"text": "교육 일정 확인", "payload": "TRAINING_SCHEDULE"}
            ]
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.TRAINING_INQUIRY,
                confidence=0.9,
                mode=ResponseMode.VISUAL,
                visualizations=visualizations,
                actions=actions,
                quick_replies=quick_replies
            )
            
        except Exception as e:
            return ChatbotResponse(
                message=f"교육 추천 조회 중 오류가 발생했습니다: {str(e)}",
                intent=ConversationIntent.TRAINING_INQUIRY,
                confidence=0.5,
                mode=ResponseMode.SIMPLE
            )
    
    async def _handle_career_advice(self, state: ConversationState,
                                  user_data: Dict[str, Any],
                                  message: str) -> ChatbotResponse:
        """경력 조언 처리"""
        # GPT를 활용한 개인화된 조언 생성
        career_context = self._build_career_context(user_data)
        
        advice_prompt = f"""
        Based on the following employee profile, provide personalized career advice:
        
        {json.dumps(career_context, ensure_ascii=False, indent=2)}
        
        User's question: {message}
        
        Provide:
        1. Current situation analysis
        2. Short-term recommendations (3-6 months)
        3. Long-term career path options
        4. Specific action items
        
        Respond in Korean with empathy and encouragement.
        """
        
        try:
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": advice_prompt}
                ],
                max_tokens=self.max_tokens,
                temperature=self.temperature
            )
            
            advice_content = response.choices[0].message.content
            
            # 구조화된 응답 생성
            message = f"""
💼 **커리어 상담**

{advice_content}

---
*이 조언은 AI가 귀하의 프로필을 분석하여 생성한 것입니다. 
더 구체적인 상담이 필요하시면 HR팀과 1:1 상담을 예약하실 수 있습니다.*
"""
            
            # 시각화 - 경력 경로
            visualizations = [
                {
                    'type': 'career_path',
                    'title': '추천 경력 경로',
                    'data': self._generate_career_path_visualization(user_data)
                }
            ]
            
            # 액션
            actions = [
                {
                    'type': 'button',
                    'text': 'HR 상담 예약',
                    'action': 'SCHEDULE_HR_CONSULTATION'
                },
                {
                    'type': 'button',
                    'text': '멘토 찾기',
                    'action': 'FIND_MENTOR'
                }
            ]
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.CAREER_ADVICE,
                confidence=0.85,
                mode=ResponseMode.DETAILED,
                visualizations=visualizations,
                actions=actions,
                bookmarkable=True,
                bookmark_data={'type': 'career_advice', 'date': timezone.now().isoformat()}
            )
            
        except Exception as e:
            return ChatbotResponse(
                message="죄송합니다. 커리어 조언을 생성하는 중 오류가 발생했습니다.",
                intent=ConversationIntent.CAREER_ADVICE,
                confidence=0.5,
                mode=ResponseMode.SIMPLE
            )
    
    async def _handle_team_analytics(self, state: ConversationState,
                                   user_data: Dict[str, Any]) -> ChatbotResponse:
        """팀 분석 처리 (관리자용)"""
        if state.user_profile.role not in ['manager', 'executive']:
            return ChatbotResponse(
                message="팀 분석 기능은 관리자만 사용할 수 있습니다.",
                intent=ConversationIntent.TEAM_ANALYTICS,
                confidence=1.0,
                mode=ResponseMode.SIMPLE
            )
        
        # 팀 데이터 수집
        team_members = user_data.get('team_members', [])
        if not team_members:
            return ChatbotResponse(
                message="관리하는 팀원이 없습니다.",
                intent=ConversationIntent.TEAM_ANALYTICS,
                confidence=1.0,
                mode=ResponseMode.SIMPLE
            )
        
        # 팀 KPI 계산
        team_stats = {
            'total_members': team_members.count(),
            'avg_performance': 0,
            'training_participation': 0,
            'certification_progress': 0,
            'high_performers': 0,
            'development_needs': 0
        }
        
        # 팀원별 데이터 집계
        for member in team_members:
            # 최근 평가
            latest_eval = Evaluation.objects.filter(
                employee=member
            ).order_by('-evaluation_year', '-evaluation_quarter').first()
            
            if latest_eval:
                if latest_eval.grade in ['A+', 'A']:
                    team_stats['high_performers'] += 1
                elif latest_eval.grade in ['C', 'D']:
                    team_stats['development_needs'] += 1
            
            # 교육 참여
            recent_training = TrainingEnrollment.objects.filter(
                employee=member,
                enrolled_date__gte=timezone.now() - timedelta(days=90)
            ).exists()
            
            if recent_training:
                team_stats['training_participation'] += 1
        
        # 비율 계산
        team_stats['training_participation_rate'] = (
            team_stats['training_participation'] / team_stats['total_members'] * 100
        )
        team_stats['high_performer_rate'] = (
            team_stats['high_performers'] / team_stats['total_members'] * 100
        )
        
        message = f"""
📊 **{state.user_profile.department} 팀 현황**

👥 총 팀원: {team_stats['total_members']}명

**성과 분포**
• 고성과자 (A+/A): {team_stats['high_performers']}명 ({team_stats['high_performer_rate']:.0f}%)
• 개발 필요: {team_stats['development_needs']}명

**교육 참여**
• 최근 3개월 교육 참여: {team_stats['training_participation']}명 ({team_stats['training_participation_rate']:.0f}%)

**주요 인사이트**
"""
        
        # AI 인사이트 추가
        if team_stats['high_performer_rate'] > 30:
            message += "✅ 팀의 고성과자 비율이 높습니다. 우수 사례를 공유하면 좋겠습니다.\n"
        
        if team_stats['training_participation_rate'] < 50:
            message += "📚 교육 참여율이 낮습니다. 팀 단위 교육을 고려해보세요.\n"
        
        if team_stats['development_needs'] > 0:
            message += f"💡 {team_stats['development_needs']}명의 팀원이 추가 지원이 필요합니다.\n"
        
        # 시각화
        visualizations = [
            {
                'type': 'team_dashboard',
                'title': '팀 성과 대시보드',
                'data': team_stats
            }
        ]
        
        # 액션
        actions = [
            {
                'type': 'button',
                'text': '팀원별 상세 보기',
                'action': 'VIEW_TEAM_DETAILS'
            },
            {
                'type': 'button',
                'text': '팀 리포트 생성',
                'action': 'GENERATE_TEAM_REPORT'
            }
        ]
        
        quick_replies = [
            {"text": "팀 교육 계획", "payload": "TEAM_TRAINING_PLAN"},
            {"text": "1:1 면담 일정", "payload": "ONE_ON_ONE_SCHEDULE"},
            {"text": "성과 개선 전략", "payload": "PERFORMANCE_STRATEGY"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.TEAM_ANALYTICS,
            confidence=0.9,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            actions=actions,
            quick_replies=quick_replies
        )
    
    async def _handle_general_conversation(self, state: ConversationState,
                                         message: str,
                                         user_data: Dict[str, Any]) -> ChatbotResponse:
        """일반 대화 처리"""
        # GPT로 자연스러운 응답 생성
        conversation_context = self._build_conversation_context(state, user_data)
        
        chat_prompt = f"""
        Continue the HR chatbot conversation naturally:
        
        Context: {json.dumps(conversation_context, ensure_ascii=False)}
        User message: {message}
        
        Respond helpfully while staying within the HR assistant role.
        Suggest relevant HR services when appropriate.
        Keep the response concise and friendly.
        
        Language: Respond in the same language as the user's message.
        """
        
        try:
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": chat_prompt}
                ],
                max_tokens=500,
                temperature=self.temperature
            )
            
            response_text = response.choices[0].message.content
            
            # 관련 서비스 제안
            suggestions = self._generate_contextual_suggestions(message, user_data)
            
            return ChatbotResponse(
                message=response_text,
                intent=ConversationIntent.CHITCHAT,
                confidence=0.7,
                mode=ResponseMode.SIMPLE,
                suggestions=suggestions
            )
            
        except Exception as e:
            return ChatbotResponse(
                message="죄송합니다. 잠시 후 다시 시도해주세요.",
                intent=ConversationIntent.CHITCHAT,
                confidence=0.5,
                mode=ResponseMode.SIMPLE
            )
    
    async def _process_multimodal_input(self, message: str, 
                                      attachments: List[Dict[str, Any]]) -> str:
        """멀티모달 입력 처리"""
        processed_message = message
        
        for attachment in attachments:
            if attachment['type'] == 'image':
                # 이미지 분석
                image_description = await self._analyze_image(attachment['data'])
                processed_message += f"\n[이미지: {image_description}]"
            
            elif attachment['type'] == 'document':
                # 문서 내용 추출
                doc_content = await self._extract_document_content(attachment['data'])
                processed_message += f"\n[문서 내용: {doc_content[:200]}...]"
        
        return processed_message
    
    async def _analyze_image(self, image_data: str) -> str:
        """이미지 분석 (GPT-4 Vision)"""
        try:
            response = openai.ChatCompletion.create(
                model=self.vision_model,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "text",
                                "text": "Describe this image briefly in Korean."
                            },
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{image_data}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=200
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            return "이미지 분석 실패"
    
    def _save_conversation_turn(self, state: ConversationState,
                               user_message: str,
                               response: ChatbotResponse):
        """대화 턴 저장"""
        turn = {
            'timestamp': datetime.now(),
            'user_message': user_message,
            'bot_response': response.message,
            'intent': response.intent.value,
            'confidence': response.confidence,
            'requires_followup': len(response.quick_replies) > 0
        }
        
        state.conversation_history.append(turn)
        
        # 최대 20턴만 유지
        if len(state.conversation_history) > 20:
            state.conversation_history = state.conversation_history[-20:]
    
    def _save_conversation_state(self, session_id: str, state: ConversationState):
        """대화 상태 저장"""
        cache_key = f"chatbot_session_{session_id}"
        cache.set(cache_key, state, self.session_timeout)
    
    def _extract_keywords(self, message: str) -> List[str]:
        """키워드 추출"""
        # 간단한 키워드 추출 (실제로는 NLP 라이브러리 사용)
        stopwords = ['은', '는', '이', '가', '을', '를', '에', '에서', '으로', '와', '과']
        words = message.split()
        keywords = [w for w in words if w not in stopwords and len(w) > 1]
        return keywords
    
    def _build_career_context(self, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """경력 컨텍스트 구성"""
        context = {
            'current_position': user_data['profile'].position,
            'department': user_data['profile'].department,
            'growth_level': user_data.get('growth_level', {}).get('current', 'Lv.1'),
            'years_of_service': 3,  # 실제 계산 필요
            'recent_evaluation': None,
            'completed_trainings': [],
            'skills': []
        }
        
        if user_data.get('latest_evaluation'):
            context['recent_evaluation'] = {
                'grade': user_data['latest_evaluation'].grade,
                'score': user_data['latest_evaluation'].total_score
            }
        
        return context
    
    def _generate_career_path_visualization(self, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """경력 경로 시각화 데이터 생성"""
        current_level = user_data.get('growth_level', {}).get('current', 'Lv.1')
        
        # 예시 경로
        paths = {
            'Lv.1': [
                {'next': 'Lv.2', 'position': '주임', 'years': 2},
                {'next': 'Lv.3', 'position': '대리', 'years': 4},
                {'next': 'Lv.4', 'position': '과장', 'years': 7}
            ],
            'Lv.2': [
                {'next': 'Lv.3', 'position': '대리', 'years': 2},
                {'next': 'Lv.4', 'position': '과장', 'years': 5},
                {'next': 'Lv.5', 'position': '차장', 'years': 8}
            ]
        }
        
        return {
            'current': current_level,
            'paths': paths.get(current_level, [])
        }
    
    def _build_conversation_context(self, state: ConversationState,
                                  user_data: Dict[str, Any]) -> Dict[str, Any]:
        """대화 컨텍스트 구성"""
        return {
            'user_name': state.user_profile.name,
            'role': state.user_profile.role,
            'recent_topics': [turn['intent'] for turn in state.conversation_history[-5:]],
            'current_context': state.context.value,
            'pending_actions': state.pending_actions
        }
    
    def _generate_contextual_suggestions(self, message: str,
                                       user_data: Dict[str, Any]) -> List[str]:
        """컨텍스트 기반 제안 생성"""
        suggestions = []
        
        # 키워드 기반 제안
        if '교육' in message or 'training' in message.lower():
            suggestions.append("추천 교육과정 보기")
            suggestions.append("교육 일정 확인하기")
        
        if '평가' in message or 'evaluation' in message.lower():
            suggestions.append("평가 결과 조회하기")
            suggestions.append("평가 기준 확인하기")
        
        if '승진' in message or '리더' in message:
            suggestions.append("리더십 기회 확인하기")
            suggestions.append("승진 요건 체크하기")
        
        # 시즌별 제안
        current_month = datetime.now().month
        if current_month in [3, 6, 9, 12]:
            suggestions.append("분기 평가 일정 확인")
        
        if current_month in [11, 12]:
            suggestions.append("연간 성과 리뷰")
            suggestions.append("내년 목표 설정")
        
        return suggestions[:3]  # 최대 3개
    
    async def _handle_help(self, state: ConversationState) -> ChatbotResponse:
        """도움말 처리"""
        help_message = """
🤖 **eHR 챗봇 사용 가이드**

저는 다음과 같은 도움을 드릴 수 있습니다:

**📋 정보 조회**
• "내 정보 확인" - 인사 정보 조회
• "성장레벨 확인" - 현재 레벨 및 진행상황
• "평가 결과" - 최근 평가 결과 확인

**🎯 인증 & 성장**
• "Lv.3 인증 체크" - 특정 레벨 인증 요건 확인
• "인증 신청하기" - 성장레벨 인증 신청
• "부족한 요건 확인" - 미충족 요건 상세 조회

**📚 교육**
• "교육 추천" - 맞춤형 교육과정 추천
• "리더십 교육" - 리더십 과정 검색
• "교육 신청" - 교육과정 수강 신청

**💼 경력 개발**
• "커리어 상담" - AI 기반 경력 조언
• "승진 가능성" - 리더 추천 상태 확인
• "성장 계획" - 개인별 성장 로드맵

**📊 분석 & 리포트**
• "KPI 대시보드" - 주요 지표 확인
• "리포트 생성" - 각종 HR 리포트 생성

**💡 사용 팁**
• 구체적으로 질문할수록 정확한 답변을 받을 수 있습니다
• 이미지나 문서를 첨부하여 질문할 수 있습니다
• ⭐ 버튼으로 중요한 대화를 북마크할 수 있습니다

무엇을 도와드릴까요?
"""
        
        quick_replies = [
            {"text": "내 정보 확인", "payload": "PERSONAL_INFO"},
            {"text": "성장레벨 체크", "payload": "GROWTH_LEVEL"},
            {"text": "교육 추천받기", "payload": "TRAINING_INQUIRY"},
            {"text": "커리어 상담", "payload": "CAREER_ADVICE"}
        ]
        
        return ChatbotResponse(
            message=help_message,
            intent=ConversationIntent.HELP,
            confidence=1.0,
            mode=ResponseMode.INTERACTIVE,
            quick_replies=quick_replies
        )
    
    async def _handle_evaluation_status(self, state: ConversationState,
                                      user_data: Dict[str, Any]) -> ChatbotResponse:
        """평가 상태 조회"""
        latest_eval = user_data.get('latest_evaluation')
        
        if not latest_eval:
            message = "최근 평가 기록이 없습니다. HR팀에 문의해주세요."
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.EVALUATION_STATUS,
                confidence=0.9,
                mode=ResponseMode.SIMPLE
            )
        
        message = f"""
📊 **최근 평가 결과**

평가 기간: {latest_eval.evaluation_year}년 {latest_eval.evaluation_quarter}분기
종합 등급: **{latest_eval.grade}**
종합 점수: **{latest_eval.total_score}점**

**영역별 점수**
• 업무 성과: {latest_eval.performance_score}점
• 역량: {latest_eval.competency_score}점
• 협업: {latest_eval.collaboration_score}점
• 성장: {latest_eval.growth_score}점

**평가자 코멘트**
"{latest_eval.comments[:100]}..."
"""
        
        # 등급별 메시지 추가
        grade_messages = {
            'A+': "🌟 탁월한 성과입니다! 리더십 기회를 고려해보세요.",
            'A': "⭐ 우수한 성과입니다! 계속 이 추세를 유지하세요.",
            'B+': "👍 좋은 성과입니다. 조금만 더 노력하면 A등급도 가능합니다.",
            'B': "✅ 안정적인 성과입니다. 성장 영역을 찾아보세요.",
            'C': "💪 개선이 필요합니다. 함께 성장 계획을 세워봅시다."
        }
        
        if latest_eval.grade in grade_messages:
            message += f"\n\n{grade_messages[latest_eval.grade]}"
        
        # 시각화
        visualizations = [
            {
                'type': 'bar_chart',
                'title': '영역별 평가 점수',
                'data': {
                    'labels': ['업무성과', '역량', '협업', '성장'],
                    'values': [
                        latest_eval.performance_score,
                        latest_eval.competency_score,
                        latest_eval.collaboration_score,
                        latest_eval.growth_score
                    ]
                }
            }
        ]
        
        # 평가 이력 추가
        eval_history = Evaluation.objects.filter(
            employee_id=state.user_profile.employee_id
        ).order_by('-evaluation_year', '-evaluation_quarter')[:4]
        
        if eval_history.count() > 1:
            trend_data = {
                'labels': [f"{e.evaluation_year}-Q{e.evaluation_quarter}" for e in reversed(eval_history)],
                'values': [e.total_score for e in reversed(eval_history)]
            }
            
            visualizations.append({
                'type': 'line_chart',
                'title': '평가 점수 추이',
                'data': trend_data
            })
        
        quick_replies = [
            {"text": "평가 기준 확인", "payload": "VIEW_EVALUATION_CRITERIA"},
            {"text": "개선 계획 수립", "payload": "CREATE_IMPROVEMENT_PLAN"},
            {"text": "1:1 피드백 신청", "payload": "REQUEST_FEEDBACK"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.EVALUATION_STATUS,
            confidence=0.95,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            quick_replies=quick_replies,
            bookmarkable=True,
            bookmark_data={
                'type': 'evaluation',
                'period': f"{latest_eval.evaluation_year}-Q{latest_eval.evaluation_quarter}",
                'grade': latest_eval.grade
            }
        )
    
    async def _handle_leader_recommendation(self, state: ConversationState,
                                          user_data: Dict[str, Any]) -> ChatbotResponse:
        """리더 추천 조회"""
        recommendations = user_data.get('leader_recommendations', [])
        
        if not recommendations:
            message = """
아직 리더십 추천 기록이 없습니다.

리더십 기회를 준비하시려면:
1. 현재 레벨의 인증을 완료하세요
2. 리더십 교육과정을 이수하세요
3. 팀 프로젝트에서 리더 역할을 경험하세요
"""
            
            quick_replies = [
                {"text": "리더십 교육 찾기", "payload": "LEADERSHIP_TRAINING"},
                {"text": "인증 요건 확인", "payload": "CERTIFICATION_CHECK"},
                {"text": "멘토 찾기", "payload": "FIND_MENTOR"}
            ]
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.LEADER_RECOMMENDATION,
                confidence=0.9,
                mode=ResponseMode.INTERACTIVE,
                quick_replies=quick_replies
            )
        
        # 추천 내용 구성
        latest_rec = recommendations[0]
        
        message = f"""
🎯 **리더십 추천 현황**

추천 직무: **{latest_rec.target_job.title}**
준비도 점수: **{latest_rec.readiness_score}점**
추천일: {latest_rec.recommendation_date.strftime('%Y-%m-%d')}

**평가 요약**
• 강점: {latest_rec.strengths[:100]}...
• 개발 필요: {latest_rec.development_areas[:100]}...

**추천 사유**
{latest_rec.recommendation_reason[:200]}...
"""
        
        # 준비도에 따른 메시지
        if latest_rec.readiness_score >= 85:
            message += "\n\n✅ 즉시 리더 역할 수행이 가능합니다!"
        elif latest_rec.readiness_score >= 70:
            message += "\n\n📈 6개월 내 준비 완료가 예상됩니다."
        else:
            message += "\n\n💪 추가적인 역량 개발이 필요합니다."
        
        # 액션 플랜
        if latest_rec.action_plans:
            message += "\n\n**권장 액션 플랜**"
            plans = json.loads(latest_rec.action_plans)
            for i, plan in enumerate(plans[:3], 1):
                message += f"\n{i}. {plan}"
        
        visualizations = [
            {
                'type': 'gauge_chart',
                'title': '리더십 준비도',
                'data': {
                    'value': latest_rec.readiness_score,
                    'min': 0,
                    'max': 100,
                    'target': 85,
                    'zones': [
                        {'min': 0, 'max': 70, 'color': '#ff6b6b'},
                        {'min': 70, 'max': 85, 'color': '#ffd43b'},
                        {'min': 85, 'max': 100, 'color': '#51cf66'}
                    ]
                }
            }
        ]
        
        actions = []
        if latest_rec.readiness_score >= 85:
            actions.append({
                'type': 'button',
                'text': '리더 포지션 지원',
                'action': 'APPLY_LEADER_POSITION',
                'data': {'job_id': latest_rec.target_job.id}
            })
        
        quick_replies = [
            {"text": "개발 계획 보기", "payload": "VIEW_DEVELOPMENT_PLAN"},
            {"text": "리더십 교육", "payload": "LEADERSHIP_TRAINING"},
            {"text": "멘토링 신청", "payload": "REQUEST_MENTORING"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.LEADER_RECOMMENDATION,
            confidence=0.95,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            actions=actions,
            quick_replies=quick_replies,
            bookmarkable=True,
            bookmark_data={
                'type': 'leader_recommendation',
                'job': latest_rec.target_job.title,
                'score': latest_rec.readiness_score
            }
        )
    
    async def _handle_kpi_dashboard(self, state: ConversationState,
                                  user_data: Dict[str, Any],
                                  message: str) -> ChatbotResponse:
        """KPI 대시보드 조회"""
        # 권한 확인
        if state.user_profile.role not in ['hr', 'executive', 'manager']:
            return ChatbotResponse(
                message="KPI 대시보드는 관리자 이상만 접근 가능합니다.",
                intent=ConversationIntent.KPI_DASHBOARD,
                confidence=1.0,
                mode=ResponseMode.SIMPLE
            )
        
        # KPI 데이터 조회
        dept_id = None
        if state.user_profile.role == 'manager':
            # 매니저는 자기 부서만
            try:
                employee = Employee.objects.get(id=state.user_profile.employee_id)
                dept_id = str(employee.department.id) if employee.department else None
            except:
                pass
        
        # KPI 요약
        kpis = self.kpi_analytics.calculate_leader_pipeline_kpis(dept_id)
        cert_kpis = self.kpi_analytics.calculate_certification_progress_kpis(dept_id)
        training_kpis = self.kpi_analytics.calculate_training_effectiveness_kpis(dept_id)
        
        message = f"""
📊 **리더십 KPI 대시보드**
{f"부서: {state.user_profile.department}" if dept_id else "전사"}

**리더 파이프라인**
• 총 후보자: {kpis['total_candidates'].value}명
• 즉시 가능: {kpis['ready_now'].value}명
• 평균 준비도: {kpis['avg_readiness_score'].value}%

**인증 진행**
• 인증 완료율: {cert_kpis['certification_rate'].value}%
• 평균 소요일: {cert_kpis['avg_certification_days'].value}일

**교육 효과성**
• 참여율: {training_kpis['participation_rate'].value}%
• 이수율: {training_kpis['completion_rate'].value}%
"""
        
        # 트렌드 분석
        if kpis['total_candidates'].trend == 'up':
            message += "\n📈 리더 후보자 수가 증가 추세입니다."
        elif kpis['total_candidates'].trend == 'down':
            message += "\n📉 리더 후보자 수가 감소하고 있어 주의가 필요합니다."
        
        # 시각화
        visualizations = [
            {
                'type': 'kpi_cards',
                'title': '핵심 지표',
                'data': {
                    'cards': [
                        {
                            'title': '리더 후보자',
                            'value': kpis['total_candidates'].value,
                            'unit': '명',
                            'trend': kpis['total_candidates'].trend,
                            'change': kpis['total_candidates'].change_percent
                        },
                        {
                            'title': '인증 완료율',
                            'value': cert_kpis['certification_rate'].value,
                            'unit': '%',
                            'trend': cert_kpis['certification_rate'].trend
                        },
                        {
                            'title': '교육 참여율',
                            'value': training_kpis['participation_rate'].value,
                            'unit': '%',
                            'trend': training_kpis['participation_rate'].trend
                        }
                    ]
                }
            }
        ]
        
        actions = [
            {
                'type': 'button',
                'text': '상세 대시보드 열기',
                'action': 'OPEN_FULL_DASHBOARD',
                'data': {'url': '/leader-kpi-dashboard/'}
            },
            {
                'type': 'button',
                'text': 'PDF 리포트 생성',
                'action': 'GENERATE_KPI_REPORT',
                'data': {'format': 'pdf'}
            }
        ]
        
        quick_replies = [
            {"text": "부서별 비교", "payload": "DEPARTMENT_COMPARISON"},
            {"text": "월별 트렌드", "payload": "MONTHLY_TREND"},
            {"text": "AI 인사이트", "payload": "AI_INSIGHTS"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.KPI_DASHBOARD,
            confidence=0.95,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            actions=actions,
            quick_replies=quick_replies
        )


class ChatbotWebSocketHandler:
    """웹소켓 핸들러 (실시간 대화)"""
    
    def __init__(self):
        self.chatbot = EHRGPTChatbot()
        self.connections = {}
    
    async def connect(self, websocket, path):
        """웹소켓 연결"""
        session_id = str(uuid.uuid4())
        self.connections[session_id] = websocket
        
        # 환영 메시지
        welcome = {
            'type': 'connected',
            'session_id': session_id,
            'message': 'eHR 챗봇에 연결되었습니다.'
        }
        await websocket.send(json.dumps(welcome))
        
        try:
            async for message in websocket:
                data = json.loads(message)
                
                # 메시지 처리
                response = await self.chatbot.process_message(
                    user_id=data.get('user_id'),
                    message=data.get('message'),
                    attachments=data.get('attachments'),
                    session_id=session_id
                )
                
                # 응답 전송
                await self.send_response(websocket, response)
                
        except Exception as e:
            print(f"WebSocket error: {e}")
        finally:
            del self.connections[session_id]
    
    async def send_response(self, websocket, response: ChatbotResponse):
        """응답 전송"""
        response_data = {
            'type': 'message',
            'data': {
                'message': response.message,
                'intent': response.intent.value,
                'confidence': response.confidence,
                'mode': response.mode.value,
                'suggestions': response.suggestions,
                'actions': response.actions,
                'visualizations': response.visualizations,
                'quick_replies': response.quick_replies,
                'bookmarkable': response.bookmarkable,
                'bookmark_data': response.bookmark_data
            }
        }
        
        await websocket.send(json.dumps(response_data, ensure_ascii=False))


class ChatbotView(TemplateView):
    """챗봇 인터페이스 뷰"""
    template_name = 'chatbot/ehr_chatbot.html'
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # 사용자 정보
        context['user_id'] = self.request.user.id
        context['user_name'] = self.request.user.get_full_name() or self.request.user.username
        
        # 북마크 로드
        context['bookmarks'] = self._load_bookmarks(self.request.user)
        
        # 설정
        context['chatbot_settings'] = {
            'enable_voice': True,
            'enable_attachments': True,
            'max_file_size': 10 * 1024 * 1024,  # 10MB
            'allowed_file_types': ['image/jpeg', 'image/png', 'application/pdf']
        }
        
        return context
    
    def _load_bookmarks(self, user):
        """북마크 로드"""
        # 실제 구현시 북마크 모델에서 조회
        return []


class ChatbotAPIView(View):
    """챗봇 REST API"""
    
    def __init__(self):
        super().__init__()
        self.chatbot = EHRGPTChatbot()
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    async def post(self, request):
        """메시지 처리"""
        try:
            data = json.loads(request.body)
            
            # 비동기 처리
            response = await self.chatbot.process_message(
                user_id=str(request.user.id),
                message=data.get('message', ''),
                attachments=data.get('attachments', []),
                session_id=data.get('session_id')
            )
            
            # 응답 직렬화
            response_data = {
                'message': response.message,
                'intent': response.intent.value,
                'confidence': response.confidence,
                'mode': response.mode.value,
                'suggestions': response.suggestions,
                'actions': response.actions,
                'visualizations': response.visualizations,
                'attachments': response.attachments,
                'quick_replies': response.quick_replies,
                'bookmarkable': response.bookmarkable,
                'bookmark_data': response.bookmark_data,
                'timestamp': timezone.now().isoformat()
            }
            
            return JsonResponse(response_data)
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)


class ChatbotBookmarkView(View):
    """북마크 관리"""
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    def get(self, request):
        """북마크 목록 조회"""
        # 실제 구현시 북마크 모델에서 조회
        bookmarks = []
        
        return JsonResponse({'bookmarks': bookmarks})
    
    def post(self, request):
        """북마크 추가"""
        try:
            data = json.loads(request.body)
            
            # 북마크 저장
            # 실제 구현시 북마크 모델에 저장
            
            return JsonResponse({'message': '북마크가 추가되었습니다.'})
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)


# URL 패턴
urlpatterns = [
    # 챗봇 인터페이스
    path('chatbot/', ChatbotView.as_view(), name='chatbot'),
    
    # API 엔드포인트
    path('api/chatbot/message/', ChatbotAPIView.as_view(), name='chatbot_message'),
    path('api/chatbot/bookmarks/', ChatbotBookmarkView.as_view(), name='chatbot_bookmarks'),
]


# 챗봇 UI HTML
CHATBOT_HTML = """
<!-- templates/chatbot/ehr_chatbot.html -->
{% extends 'base.html' %}
{% load static %}

{% block title %}eHR AI 챗봇{% endblock %}

{% block extra_css %}
<style>
    .chatbot-container {
        max-width: 800px;
        margin: 0 auto;
        height: calc(100vh - 100px);
        display: flex;
        flex-direction: column;
        background: #f8f9fa;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .chatbot-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .chatbot-status {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #4ade80;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
    
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: white;
    }
    
    .message {
        margin-bottom: 20px;
        animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .message.user {
        text-align: right;
    }
    
    .message-bubble {
        display: inline-block;
        max-width: 70%;
        padding: 12px 20px;
        border-radius: 20px;
        position: relative;
    }
    
    .user .message-bubble {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-bottom-right-radius: 4px;
    }
    
    .bot .message-bubble {
        background: #f3f4f6;
        color: #1f2937;
        border-bottom-left-radius: 4px;
    }
    
    .message-time {
        font-size: 0.75rem;
        color: #9ca3af;
        margin-top: 4px;
    }
    
    .quick-replies {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .quick-reply-btn {
        padding: 8px 16px;
        border: 1px solid #e5e7eb;
        border-radius: 20px;
        background: white;
        color: #374151;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.875rem;
    }
    
    .quick-reply-btn:hover {
        background: #667eea;
        color: white;
        border-color: #667eea;
    }
    
    .action-buttons {
        margin-top: 15px;
        display: flex;
        gap: 10px;
    }
    
    .action-btn {
        padding: 10px 20px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .action-btn:hover {
        background: #5a67d8;
        transform: translateY(-1px);
    }
    
    .visualization {
        margin: 15px 0;
        padding: 20px;
        background: #f9fafb;
        border-radius: 8px;
        border: 1px solid #e5e7eb;
    }
    
    .chart-container {
        height: 300px;
        margin-top: 10px;
    }
    
    .info-card {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 20px;
        margin: 10px 0;
    }
    
    .info-card h4 {
        color: #667eea;
        margin-bottom: 15px;
    }
    
    .info-row {
        display: flex;
        justify-content: space-between;
        padding: 8px 0;
        border-bottom: 1px solid #f3f4f6;
    }
    
    .info-row:last-child {
        border-bottom: none;
    }
    
    .chat-input-container {
        padding: 20px;
        background: white;
        border-top: 1px solid #e5e7eb;
    }
    
    .input-wrapper {
        display: flex;
        gap: 10px;
        align-items: flex-end;
    }
    
    .chat-input {
        flex: 1;
        padding: 12px 20px;
        border: 2px solid #e5e7eb;
        border-radius: 25px;
        outline: none;
        font-size: 1rem;
        resize: none;
        max-height: 120px;
        transition: border-color 0.2s;
    }
    
    .chat-input:focus {
        border-color: #667eea;
    }
    
    .input-actions {
        display: flex;
        gap: 8px;
    }
    
    .input-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .send-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }
    
    .send-btn:hover {
        transform: scale(1.1);
    }
    
    .attach-btn {
        background: #f3f4f6;
        color: #6b7280;
    }
    
    .attach-btn:hover {
        background: #e5e7eb;
    }
    
    .typing-indicator {
        display: inline-flex;
        align-items: center;
        padding: 15px 20px;
        background: #f3f4f6;
        border-radius: 20px;
        border-bottom-left-radius: 4px;
    }
    
    .typing-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #9ca3af;
        margin: 0 2px;
        animation: typing 1.4s infinite;
    }
    
    .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
    }
    
    .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
    }
    
    @keyframes typing {
        0%, 60%, 100% {
            opacity: 0.2;
            transform: scale(0.8);
        }
        30% {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    .bookmark-btn {
        background: none;
        border: none;
        color: #fbbf24;
        cursor: pointer;
        font-size: 1.2rem;
        transition: all 0.2s;
    }
    
    .bookmark-btn:hover {
        transform: scale(1.2);
    }
    
    .bookmark-btn.bookmarked {
        color: #f59e0b;
    }
    
    .suggestions {
        margin-top: 10px;
        padding: 10px;
        background: #fef3c7;
        border-radius: 8px;
        font-size: 0.875rem;
    }
    
    .suggestions h5 {
        margin: 0 0 8px 0;
        color: #92400e;
    }
    
    .suggestions ul {
        margin: 0;
        padding-left: 20px;
    }
    
    @media (max-width: 768px) {
        .chatbot-container {
            height: 100vh;
            border-radius: 0;
        }
        
        .message-bubble {
            max-width: 85%;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="chatbot-container">
    <div class="chatbot-header">
        <div>
            <h3>eHR AI Assistant</h3>
            <div class="chatbot-status">
                <div class="status-dot"></div>
                <span>온라인</span>
            </div>
        </div>
        <div>
            <button class="bookmark-btn" id="bookmarkToggle">
                <i class="far fa-star"></i>
            </button>
        </div>
    </div>
    
    <div class="chat-messages" id="chatMessages">
        <!-- Messages will be dynamically added here -->
    </div>
    
    <div class="chat-input-container">
        <div class="input-wrapper">
            <textarea 
                id="chatInput" 
                class="chat-input" 
                placeholder="무엇을 도와드릴까요?"
                rows="1"
            ></textarea>
            <div class="input-actions">
                <button class="input-btn attach-btn" id="attachBtn">
                    <i class="fas fa-paperclip"></i>
                </button>
                <button class="input-btn send-btn" id="sendBtn">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
        <input type="file" id="fileInput" style="display: none;" accept="image/*,application/pdf">
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// Chatbot JavaScript Implementation
class EHRChatbot {
    constructor() {
        this.userId = '{{ user_id }}';
        this.userName = '{{ user_name }}';
        this.sessionId = this.generateSessionId();
        this.messagesContainer = document.getElementById('chatMessages');
        this.inputField = document.getElementById('chatInput');
        this.sendBtn = document.getElementById('sendBtn');
        this.attachBtn = document.getElementById('attachBtn');
        this.fileInput = document.getElementById('fileInput');
        this.bookmarkBtn = document.getElementById('bookmarkToggle');
        this.attachments = [];
        this.isTyping = false;
        
        this.initializeEventListeners();
        this.sendInitialGreeting();
    }
    
    generateSessionId() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    
    initializeEventListeners() {
        this.sendBtn.addEventListener('click', () => this.sendMessage());
        this.inputField.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });
        
        this.attachBtn.addEventListener('click', () => {
            this.fileInput.click();
        });
        
        this.fileInput.addEventListener('change', (e) => {
            this.handleFileSelect(e);
        });
        
        this.bookmarkBtn.addEventListener('click', () => {
            this.toggleBookmark();
        });
        
        // Auto-resize textarea
        this.inputField.addEventListener('input', () => {
            this.inputField.style.height = 'auto';
            this.inputField.style.height = this.inputField.scrollHeight + 'px';
        });
    }
    
    async sendInitialGreeting() {
        // Wait a moment before showing greeting
        setTimeout(() => {
            this.addBotMessage("안녕하세요! eHR AI 어시스턴트입니다. 무엇을 도와드릴까요? 😊", {
                quick_replies: [
                    {text: "내 정보 확인", payload: "PERSONAL_INFO"},
                    {text: "성장레벨 체크", payload: "GROWTH_LEVEL"},
                    {text: "교육 추천받기", payload: "TRAINING_INQUIRY"},
                    {text: "도움말", payload: "HELP"}
                ]
            });
        }, 500);
    }
    
    async sendMessage() {
        const message = this.inputField.value.trim();
        if (!message && this.attachments.length === 0) return;
        
        // Add user message
        this.addUserMessage(message);
        
        // Clear input
        this.inputField.value = '';
        this.inputField.style.height = 'auto';
        
        // Show typing indicator
        this.showTypingIndicator();
        
        try {
            const response = await fetch('/api/chatbot/message/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify({
                    message: message,
                    attachments: this.attachments,
                    session_id: this.sessionId
                })
            });
            
            const data = await response.json();
            
            // Remove typing indicator
            this.hideTypingIndicator();
            
            // Add bot response
            this.addBotMessage(data.message, data);
            
            // Clear attachments
            this.attachments = [];
            
        } catch (error) {
            this.hideTypingIndicator();
            this.addBotMessage("죄송합니다. 일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
        }
    }
    
    addUserMessage(message) {
        const messageDiv = this.createMessageElement('user', message);
        this.messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    addBotMessage(message, data = {}) {
        const messageDiv = this.createMessageElement('bot', message);
        
        // Add visualizations
        if (data.visualizations && data.visualizations.length > 0) {
            data.visualizations.forEach(viz => {
                const vizElement = this.createVisualization(viz);
                messageDiv.appendChild(vizElement);
            });
        }
        
        // Add action buttons
        if (data.actions && data.actions.length > 0) {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'action-buttons';
            
            data.actions.forEach(action => {
                const btn = document.createElement('button');
                btn.className = 'action-btn';
                btn.innerHTML = `<i class="fas fa-${this.getActionIcon(action.type)}"></i> ${action.text}`;
                btn.onclick = () => this.handleAction(action);
                actionsDiv.appendChild(btn);
            });
            
            messageDiv.appendChild(actionsDiv);
        }
        
        // Add suggestions
        if (data.suggestions && data.suggestions.length > 0) {
            const suggestionsDiv = document.createElement('div');
            suggestionsDiv.className = 'suggestions';
            suggestionsDiv.innerHTML = `
                <h5>관련 제안:</h5>
                <ul>
                    ${data.suggestions.map(s => `<li>${s}</li>`).join('')}
                </ul>
            `;
            messageDiv.appendChild(suggestionsDiv);
        }
        
        // Add quick replies
        if (data.quick_replies && data.quick_replies.length > 0) {
            const quickRepliesDiv = document.createElement('div');
            quickRepliesDiv.className = 'quick-replies';
            
            data.quick_replies.forEach(reply => {
                const btn = document.createElement('button');
                btn.className = 'quick-reply-btn';
                btn.textContent = reply.text;
                btn.onclick = () => {
                    this.inputField.value = reply.text;
                    this.sendMessage();
                };
                quickRepliesDiv.appendChild(btn);
            });
            
            messageDiv.appendChild(quickRepliesDiv);
        }
        
        // Add bookmark button if bookmarkable
        if (data.bookmarkable) {
            const bookmarkBtn = document.createElement('button');
            bookmarkBtn.className = 'bookmark-btn message-bookmark';
            bookmarkBtn.innerHTML = '<i class="far fa-star"></i>';
            bookmarkBtn.onclick = () => this.bookmarkMessage(data.bookmark_data);
            messageDiv.querySelector('.message-bubble').appendChild(bookmarkBtn);
        }
        
        this.messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    createMessageElement(sender, message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${sender}`;
        
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'message-bubble';
        bubbleDiv.innerHTML = this.formatMessage(message);
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = new Date().toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit'
        });
        
        messageDiv.appendChild(bubbleDiv);
        messageDiv.appendChild(timeDiv);
        
        return messageDiv;
    }
    
    formatMessage(message) {
        // Convert markdown-style formatting
        return message
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/\n/g, '<br>')
            .replace(/• /g, '• ');
    }
    
    createVisualization(viz) {
        const vizDiv = document.createElement('div');
        vizDiv.className = 'visualization';
        
        if (viz.type === 'info_card') {
            vizDiv.innerHTML = this.createInfoCard(viz);
        } else if (viz.type === 'chart') {
            vizDiv.innerHTML = `<div class="chart-container"><canvas id="chart-${Date.now()}"></canvas></div>`;
            setTimeout(() => this.renderChart(vizDiv.querySelector('canvas'), viz), 100);
        } else if (viz.type === 'progress_chart') {
            vizDiv.innerHTML = this.createProgressChart(viz);
        } else if (viz.type === 'kpi_cards') {
            vizDiv.innerHTML = this.createKPICards(viz);
        }
        
        return vizDiv;
    }
    
    createInfoCard(viz) {
        const data = viz.data;
        return `
            <div class="info-card">
                <h4>${viz.title}</h4>
                ${Object.entries(data).map(([key, value]) => `
                    <div class="info-row">
                        <span>${this.translateKey(key)}</span>
                        <strong>${value}</strong>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    createProgressChart(viz) {
        const areas = viz.data.areas;
        return `
            <div class="progress-chart">
                <h4>${viz.title}</h4>
                ${Object.entries(areas).map(([area, value]) => `
                    <div class="progress-item">
                        <div class="progress-label">
                            <span>${area}</span>
                            <span>${value}%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${value}%"></div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    createKPICards(viz) {
        return `
            <div class="kpi-cards">
                ${viz.data.cards.map(card => `
                    <div class="kpi-card">
                        <h5>${card.title}</h5>
                        <div class="kpi-value">${card.value}${card.unit}</div>
                        <div class="kpi-trend ${card.trend}">
                            ${card.trend === 'up' ? '↑' : card.trend === 'down' ? '↓' : '→'}
                            ${card.change || 0}%
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    renderChart(canvas, viz) {
        const ctx = canvas.getContext('2d');
        new Chart(ctx, {
            type: viz.data.type || 'bar',
            data: viz.data,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                ...viz.options
            }
        });
    }
    
    showTypingIndicator() {
        const typingDiv = document.createElement('div');
        typingDiv.className = 'message bot typing-message';
        typingDiv.innerHTML = `
            <div class="typing-indicator">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        `;
        this.messagesContainer.appendChild(typingDiv);
        this.scrollToBottom();
        this.isTyping = true;
    }
    
    hideTypingIndicator() {
        if (this.isTyping) {
            const typingMessage = this.messagesContainer.querySelector('.typing-message');
            if (typingMessage) {
                typingMessage.remove();
            }
            this.isTyping = false;
        }
    }
    
    handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                this.attachments.push({
                    type: file.type.startsWith('image/') ? 'image' : 'document',
                    name: file.name,
                    data: e.target.result.split(',')[1] // base64 data
                });
                
                // Show attachment indicator
                this.showAttachmentIndicator(file.name);
            };
            reader.readAsDataURL(file);
        }
    }
    
    showAttachmentIndicator(filename) {
        // Add visual indicator for attached file
        const indicator = document.createElement('div');
        indicator.className = 'attachment-indicator';
        indicator.innerHTML = `📎 ${filename}`;
        this.inputField.parentElement.appendChild(indicator);
    }
    
    handleAction(action) {
        switch(action.action) {
            case 'VIEW_DETAILED_HISTORY':
                window.location.href = '/employees/profile/';
                break;
            case 'APPLY_CERTIFICATION':
                window.location.href = `/certifications/apply/${action.data.level}`;
                break;
            case 'ENROLL_COURSE':
                window.location.href = `/trainings/enroll/${action.data.course_id}`;
                break;
            case 'OPEN_FULL_DASHBOARD':
                window.open(action.data.url, '_blank');
                break;
            case 'GENERATE_KPI_REPORT':
                this.generateReport(action.data);
                break;
            default:
                console.log('Unknown action:', action);
        }
    }
    
    async generateReport(data) {
        try {
            const response = await fetch('/api/generate-report/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify({
                    report_type: 'monthly_report',
                    format: data.format || 'pdf',
                    language: 'ko'
                })
            });
            
            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `report_${new Date().toISOString().split('T')[0]}.${data.format}`;
                a.click();
            }
        } catch (error) {
            console.error('Report generation failed:', error);
        }
    }
    
    async bookmarkMessage(bookmarkData) {
        try {
            const response = await fetch('/api/chatbot/bookmarks/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify(bookmarkData)
            });
            
            if (response.ok) {
                // Visual feedback
                this.showNotification('북마크가 저장되었습니다.');
            }
        } catch (error) {
            console.error('Bookmark failed:', error);
        }
    }
    
    toggleBookmark() {
        this.bookmarkBtn.classList.toggle('bookmarked');
        const icon = this.bookmarkBtn.querySelector('i');
        icon.classList.toggle('far');
        icon.classList.toggle('fas');
    }
    
    getActionIcon(actionType) {
        const icons = {
            'button': 'arrow-right',
            'link': 'external-link-alt',
            'download': 'download',
            'view': 'eye'
        };
        return icons[actionType] || 'arrow-right';
    }
    
    translateKey(key) {
        const translations = {
            'employee_id': '사번',
            'name': '성명',
            'position': '직급',
            'department': '부서',
            'growth_level': '성장레벨'
        };
        return translations[key] || key;
    }
    
    scrollToBottom() {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
    
    getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    showNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.classList.add('show');
        }, 100);
        
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
}

// Initialize chatbot
document.addEventListener('DOMContentLoaded', () => {
    const chatbot = new EHRChatbot();
});
</script>
{% endblock %}
"""