"""
í’ì„±í•œ GPT ê¸°ë°˜ eHR ì¸ì‚¬ ì±—ë´‡
Conversational AI-powered HR chatbot with multimodal capabilities
Generated by: Conversational UX designer + LLM HR analyst + API integrator
"""

from django.views import View
from django.views.generic import TemplateView
from django.http import JsonResponse, HttpResponse, StreamingHttpResponse
from django.utils.decorators import method_decorator
from django.contrib.auth.decorators import login_required
from django.core.cache import cache
from django.db.models import Q, Count, Avg
from django.utils import timezone
from django.template.loader import render_to_string
import openai
import json
import re
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Generator
from dataclasses import dataclass, field
from enum import Enum
import asyncio
from collections import defaultdict
import base64
from io import BytesIO
import requests

# Import existing modules
from employees.models import Employee, Department
from certifications.models import GrowthLevelCertification, CertificationCheckLog
from trainings.models import TrainingCourse, TrainingEnrollment
from evaluations.models import Evaluation
from job_profiles.models import JobLevelProfile, LeaderRecommendation
from leader_kpi_dashboard import LeaderKPIAnalytics
from leader_ai_assistant import LeadershipAIAssistant
from leader_strategy_reportgen import LeadershipStrategyReportGenerator, ReportType, ReportFormat


class ConversationIntent(Enum):
    """ëŒ€í™” ì˜ë„ ë¶„ë¥˜"""
    # ì •ë³´ ì¡°íšŒ
    PERSONAL_INFO = "personal_info"
    GROWTH_LEVEL = "growth_level"
    CERTIFICATION_CHECK = "certification_check"
    TRAINING_INQUIRY = "training_inquiry"
    EVALUATION_STATUS = "evaluation_status"
    LEADER_RECOMMENDATION = "leader_recommendation"
    
    # ì•¡ì…˜ ìš”ì²­
    CERTIFICATION_APPLY = "certification_apply"
    TRAINING_ENROLLMENT = "training_enrollment"
    REPORT_REQUEST = "report_request"
    SCHEDULE_MEETING = "schedule_meeting"
    
    # ë¶„ì„ ë° ì¡°ì–¸
    CAREER_ADVICE = "career_advice"
    SKILL_GAP_ANALYSIS = "skill_gap_analysis"
    PERFORMANCE_FEEDBACK = "performance_feedback"
    DEVELOPMENT_PLANNING = "development_planning"
    
    # ì¼ë°˜ ëŒ€í™”
    GREETING = "greeting"
    HELP = "help"
    CHITCHAT = "chitchat"
    FAREWELL = "farewell"
    
    # ê´€ë¦¬ì ê¸°ëŠ¥
    TEAM_ANALYTICS = "team_analytics"
    KPI_DASHBOARD = "kpi_dashboard"
    STRATEGIC_PLANNING = "strategic_planning"


class ResponseMode(Enum):
    """ì‘ë‹µ ëª¨ë“œ"""
    SIMPLE = "simple"           # ê°„ë‹¨í•œ ë‹µë³€
    DETAILED = "detailed"       # ìƒì„¸í•œ ì„¤ëª…
    VISUAL = "visual"          # ì°¨íŠ¸/ê·¸ë˜í”„ í¬í•¨
    INTERACTIVE = "interactive" # ë²„íŠ¼/ì˜µì…˜ í¬í•¨
    MULTIMODAL = "multimodal"  # í…ìŠ¤íŠ¸+ì´ë¯¸ì§€+ì°¨íŠ¸


class ConversationContext(Enum):
    """ëŒ€í™” ì»¨í…ìŠ¤íŠ¸"""
    INITIAL = "initial"
    FOLLOWUP = "followup"
    CLARIFICATION = "clarification"
    CONFIRMATION = "confirmation"
    COMPLETION = "completion"


@dataclass
class UserProfile:
    """ì‚¬ìš©ì í”„ë¡œí•„"""
    employee_id: str
    name: str
    position: str
    department: str
    role: str  # employee, manager, hr, executive
    preferences: Dict[str, Any] = field(default_factory=dict)
    conversation_history: List[Dict[str, Any]] = field(default_factory=list)
    bookmarks: List[str] = field(default_factory=list)


@dataclass
class ConversationState:
    """ëŒ€í™” ìƒíƒœ"""
    session_id: str
    user_profile: UserProfile
    current_intent: Optional[ConversationIntent] = None
    context: ConversationContext = ConversationContext.INITIAL
    context_data: Dict[str, Any] = field(default_factory=dict)
    pending_actions: List[Dict[str, Any]] = field(default_factory=list)
    clarification_needed: Optional[Dict[str, Any]] = None
    last_activity: datetime = field(default_factory=datetime.now)


@dataclass
class ChatbotResponse:
    """ì±—ë´‡ ì‘ë‹µ"""
    message: str
    intent: ConversationIntent
    confidence: float
    mode: ResponseMode
    suggestions: List[str] = field(default_factory=list)
    actions: List[Dict[str, Any]] = field(default_factory=list)
    visualizations: List[Dict[str, Any]] = field(default_factory=list)
    attachments: List[Dict[str, Any]] = field(default_factory=list)
    quick_replies: List[Dict[str, str]] = field(default_factory=list)
    bookmarkable: bool = False
    bookmark_data: Optional[Dict[str, Any]] = None


class EHRGPTChatbot:
    """eHR GPT ì±—ë´‡ ì—”ì§„"""
    
    def __init__(self):
        self.openai_api_key = settings.OPENAI_API_KEY
        openai.api_key = self.openai_api_key
        
        # GPT ì„¤ì •
        self.model = "gpt-4"
        self.vision_model = "gpt-4-vision-preview"
        self.max_tokens = 1500
        self.temperature = 0.8
        
        # ì„œë¹„ìŠ¤ í†µí•©
        self.kpi_analytics = LeaderKPIAnalytics()
        self.ai_assistant = LeadershipAIAssistant()
        self.report_generator = LeadershipStrategyReportGenerator()
        
        # ëŒ€í™” ìƒíƒœ ê´€ë¦¬
        self.conversation_states = {}
        self.session_timeout = 3600  # 1ì‹œê°„
        
        # ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸
        self.system_prompt = """
        You are an advanced HR assistant for the eHR system, designed to help employees with:
        1. Career development and growth planning
        2. Certification and training inquiries
        3. Performance feedback and evaluation
        4. Leadership development opportunities
        5. General HR questions and support
        
        Your personality:
        - Friendly, professional, and encouraging
        - Proactive in offering relevant suggestions
        - Context-aware and personalized responses
        - Clear and concise communication
        - Empathetic and supportive tone
        
        Key capabilities:
        - Access to employee data and HR systems
        - Real-time KPI and analytics
        - Training recommendations
        - Career path guidance
        - Report generation
        
        Always:
        - Greet users warmly
        - Understand their needs before responding
        - Provide actionable advice
        - Offer follow-up questions
        - Respect privacy and confidentiality
        
        Respond in the same language as the user's query.
        Use emojis sparingly but appropriately to enhance friendliness.
        """
        
        # ì˜ë„ íŒ¨í„´
        self.intent_patterns = self._initialize_intent_patterns()
        
    def _initialize_intent_patterns(self) -> Dict[ConversationIntent, List[str]]:
        """ì˜ë„ ì¸ì‹ íŒ¨í„´ ì´ˆê¸°í™”"""
        return {
            ConversationIntent.GREETING: [
                r'ì•ˆë…•|hello|hi|ë°˜ê°€ì›Œ|ì¢‹ì€\s*(ì•„ì¹¨|ì˜¤í›„|ì €ë…)',
                r'ì²˜ìŒ\s*ëµ™ê² ìŠµë‹ˆë‹¤|nice to meet'
            ],
            ConversationIntent.PERSONAL_INFO: [
                r'ë‚´\s*(ì •ë³´|í”„ë¡œí•„|ì¸ì‚¬.*ì •ë³´)|my\s*(info|profile)',
                r'ì§ê¸‰|ë¶€ì„œ|ì…ì‚¬ì¼|personal\s*information'
            ],
            ConversationIntent.GROWTH_LEVEL: [
                r'ì„±ì¥\s*ë ˆë²¨|growth\s*level|í˜„ì¬\s*ë ˆë²¨',
                r'ë ˆë²¨.*í™•ì¸|what.*my.*level'
            ],
            ConversationIntent.CERTIFICATION_CHECK: [
                r'ì¸ì¦.*ì²´í¬|ì¸ì¦.*í™•ì¸|certification.*check',
                r'ì¸ì¦.*ìš”ê±´|ìê²©.*í™•ì¸|eligible.*certification'
            ],
            ConversationIntent.TRAINING_INQUIRY: [
                r'êµìœ¡|training|course|ê°•ì˜|ìˆ˜ì—…',
                r'ìˆ˜ê°•.*ì‹ ì²­|êµìœ¡.*ì¶”ì²œ|recommend.*training'
            ],
            ConversationIntent.EVALUATION_STATUS: [
                r'í‰ê°€|evaluation|performance|ì„±ê³¼',
                r'í‰ê°€.*ê²°ê³¼|í‰ê°€.*ë“±ê¸‰|performance.*rating'
            ],
            ConversationIntent.LEADER_RECOMMENDATION: [
                r'ë¦¬ë”.*ì¶”ì²œ|leader.*recommendation|ìŠ¹ì§„',
                r'ë¦¬ë”ì‹­.*ê¸°íšŒ|leadership.*opportunity'
            ],
            ConversationIntent.CAREER_ADVICE: [
                r'ê²½ë ¥.*ì¡°ì–¸|career.*advice|ì»¤ë¦¬ì–´.*ìƒë‹´',
                r'ì•ìœ¼ë¡œ.*ì–´ë–»ê²Œ|ì„±ì¥.*ë°©í–¥|career.*path'
            ],
            ConversationIntent.HELP: [
                r'ë„ì›€|help|ì‚¬ìš©ë²•|how\s*to',
                r'ë¬´ì—‡.*í• .*ìˆ|what.*can.*do'
            ],
            ConversationIntent.TEAM_ANALYTICS: [
                r'íŒ€.*í˜„í™©|team.*analytics|ë¶€ì„œ.*ë¶„ì„',
                r'íŒ€ì›.*ì„±ê³¼|team.*performance'
            ],
            ConversationIntent.KPI_DASHBOARD: [
                r'kpi|ëŒ€ì‹œë³´ë“œ|dashboard|ì§€í‘œ',
                r'ë¦¬ë”ì‹­.*kpi|leadership.*metrics'
            ]
        }
    
    async def process_message(self, user_id: str, message: str, 
                            attachments: List[Dict[str, Any]] = None,
                            session_id: Optional[str] = None) -> ChatbotResponse:
        """ë©”ì‹œì§€ ì²˜ë¦¬ ë©”ì¸ í•¨ìˆ˜"""
        
        # ì„¸ì…˜ ê´€ë¦¬
        if not session_id:
            session_id = str(uuid.uuid4())
        
        # ëŒ€í™” ìƒíƒœ ë¡œë“œ ë˜ëŠ” ìƒì„±
        state = self._get_or_create_conversation_state(user_id, session_id)
        
        # ë©€í‹°ëª¨ë‹¬ ì…ë ¥ ì²˜ë¦¬
        if attachments:
            message = await self._process_multimodal_input(message, attachments)
        
        # ì˜ë„ ë¶„ì„
        intent, confidence = self._analyze_intent(message, state)
        state.current_intent = intent
        
        # ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        self._update_context(state, message, intent)
        
        # ì‘ë‹µ ìƒì„±
        response = await self._generate_response(state, message, intent, confidence)
        
        # ëŒ€í™” ê¸°ë¡ ì €ì¥
        self._save_conversation_turn(state, message, response)
        
        # ìƒíƒœ ì €ì¥
        self._save_conversation_state(session_id, state)
        
        return response
    
    def _get_or_create_conversation_state(self, user_id: str, 
                                        session_id: str) -> ConversationState:
        """ëŒ€í™” ìƒíƒœ ì¡°íšŒ ë˜ëŠ” ìƒì„±"""
        # ìºì‹œì—ì„œ ì¡°íšŒ
        cache_key = f"chatbot_session_{session_id}"
        state = cache.get(cache_key)
        
        if state:
            return state
        
        # ìƒˆ ìƒíƒœ ìƒì„±
        try:
            employee = Employee.objects.get(id=user_id)
            user_profile = UserProfile(
                employee_id=str(employee.id),
                name=employee.name,
                position=employee.position,
                department=employee.department.name if employee.department else "",
                role=self._determine_user_role(employee),
                preferences=self._load_user_preferences(employee)
            )
        except Employee.DoesNotExist:
            # ê¸°ë³¸ í”„ë¡œí•„
            user_profile = UserProfile(
                employee_id=user_id,
                name="User",
                position="",
                department="",
                role="employee"
            )
        
        state = ConversationState(
            session_id=session_id,
            user_profile=user_profile
        )
        
        return state
    
    def _determine_user_role(self, employee: Employee) -> str:
        """ì‚¬ìš©ì ì—­í•  ê²°ì •"""
        if employee.user.groups.filter(name='Executive').exists():
            return 'executive'
        elif employee.user.groups.filter(name='HR').exists():
            return 'hr'
        elif Employee.objects.filter(manager=employee).exists():
            return 'manager'
        else:
            return 'employee'
    
    def _load_user_preferences(self, employee: Employee) -> Dict[str, Any]:
        """ì‚¬ìš©ì ì„ í˜¸ ì„¤ì • ë¡œë“œ"""
        # ì‹¤ì œ êµ¬í˜„ì‹œ ì‚¬ìš©ì ì„¤ì • ëª¨ë¸ì—ì„œ ë¡œë“œ
        return {
            'language': 'ko',
            'response_mode': ResponseMode.DETAILED.value,
            'notification_enabled': True,
            'preferred_training_time': 'afternoon'
        }
    
    def _analyze_intent(self, message: str, state: ConversationState) -> Tuple[ConversationIntent, float]:
        """ì˜ë„ ë¶„ì„"""
        message_lower = message.lower()
        
        # íŒ¨í„´ ë§¤ì¹­
        for intent, patterns in self.intent_patterns.items():
            for pattern in patterns:
                if re.search(pattern, message_lower):
                    return intent, 0.9
        
        # GPT ê¸°ë°˜ ì˜ë„ ë¶„ë¥˜
        if state.context == ConversationContext.FOLLOWUP:
            # í›„ì† ëŒ€í™”ì¸ ê²½ìš° ì´ì „ ì˜ë„ ì°¸ê³ 
            return state.current_intent, 0.8
        
        # GPTë¡œ ì˜ë„ ë¶„ë¥˜
        intent_prompt = f"""
        Classify the user's intent from this message: "{message}"
        
        Available intents:
        - PERSONAL_INFO: Asking about personal HR information
        - GROWTH_LEVEL: Inquiring about growth levels
        - CERTIFICATION_CHECK: Checking certification eligibility
        - TRAINING_INQUIRY: Questions about training courses
        - EVALUATION_STATUS: Performance evaluation queries
        - LEADER_RECOMMENDATION: Leadership opportunities
        - CAREER_ADVICE: Career development guidance
        - TEAM_ANALYTICS: Team performance analysis (managers)
        - KPI_DASHBOARD: KPI and metrics queries
        - HELP: General help or how-to questions
        - GREETING: Greetings and pleasantries
        - CHITCHAT: General conversation
        
        Return only the intent name.
        """
        
        try:
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are an intent classifier."},
                    {"role": "user", "content": intent_prompt}
                ],
                max_tokens=50,
                temperature=0.3
            )
            
            intent_str = response.choices[0].message.content.strip().upper()
            intent = ConversationIntent[intent_str]
            return intent, 0.85
            
        except:
            # ê¸°ë³¸ê°’
            return ConversationIntent.CHITCHAT, 0.5
    
    def _update_context(self, state: ConversationState, message: str, 
                       intent: ConversationIntent):
        """ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸"""
        # ì´ì „ ëŒ€í™”ì™€ì˜ ê´€ë ¨ì„± í™•ì¸
        if state.conversation_history:
            last_turn = state.conversation_history[-1]
            time_diff = (datetime.now() - last_turn['timestamp']).total_seconds()
            
            if time_diff < 300:  # 5ë¶„ ì´ë‚´
                if last_turn.get('requires_followup'):
                    state.context = ConversationContext.FOLLOWUP
                elif '?' in message and len(message.split()) < 5:
                    state.context = ConversationContext.CLARIFICATION
            else:
                state.context = ConversationContext.INITIAL
        
        # ì˜ë„ë³„ ì»¨í…ìŠ¤íŠ¸ ë°ì´í„° ì„¤ì •
        if intent == ConversationIntent.CERTIFICATION_CHECK:
            state.context_data['requires_level'] = True
            state.context_data['requires_job'] = True
        elif intent == ConversationIntent.TRAINING_ENROLLMENT:
            state.context_data['requires_course_id'] = True
            state.context_data['requires_confirmation'] = True
    
    async def _generate_response(self, state: ConversationState, message: str,
                               intent: ConversationIntent, confidence: float) -> ChatbotResponse:
        """ì‘ë‹µ ìƒì„±"""
        # ì‚¬ìš©ì ë°ì´í„° ìˆ˜ì§‘
        user_data = self._collect_user_data(state.user_profile)
        
        # ì˜ë„ë³„ ì²˜ë¦¬
        if intent == ConversationIntent.GREETING:
            return await self._handle_greeting(state, user_data)
        
        elif intent == ConversationIntent.PERSONAL_INFO:
            return await self._handle_personal_info(state, user_data)
        
        elif intent == ConversationIntent.GROWTH_LEVEL:
            return await self._handle_growth_level(state, user_data)
        
        elif intent == ConversationIntent.CERTIFICATION_CHECK:
            return await self._handle_certification_check(state, user_data, message)
        
        elif intent == ConversationIntent.TRAINING_INQUIRY:
            return await self._handle_training_inquiry(state, user_data, message)
        
        elif intent == ConversationIntent.EVALUATION_STATUS:
            return await self._handle_evaluation_status(state, user_data)
        
        elif intent == ConversationIntent.LEADER_RECOMMENDATION:
            return await self._handle_leader_recommendation(state, user_data)
        
        elif intent == ConversationIntent.CAREER_ADVICE:
            return await self._handle_career_advice(state, user_data, message)
        
        elif intent == ConversationIntent.TEAM_ANALYTICS:
            return await self._handle_team_analytics(state, user_data)
        
        elif intent == ConversationIntent.KPI_DASHBOARD:
            return await self._handle_kpi_dashboard(state, user_data, message)
        
        elif intent == ConversationIntent.HELP:
            return await self._handle_help(state)
        
        else:
            # ì¼ë°˜ ëŒ€í™” ì²˜ë¦¬
            return await self._handle_general_conversation(state, message, user_data)
    
    def _collect_user_data(self, profile: UserProfile) -> Dict[str, Any]:
        """ì‚¬ìš©ì ê´€ë ¨ ë°ì´í„° ìˆ˜ì§‘"""
        data = {
            'profile': profile,
            'current_date': timezone.now()
        }
        
        try:
            employee = Employee.objects.get(id=profile.employee_id)
            
            # ì„±ì¥ ë ˆë²¨ ì •ë³´
            data['growth_level'] = {
                'current': getattr(employee, 'growth_level', 'Lv.1'),
                'certifications': GrowthLevelCertification.objects.filter(
                    employee=employee,
                    status='CERTIFIED'
                ).order_by('-certified_date')
            }
            
            # ìµœê·¼ í‰ê°€
            data['latest_evaluation'] = Evaluation.objects.filter(
                employee=employee
            ).order_by('-evaluation_year', '-evaluation_quarter').first()
            
            # êµìœ¡ ì´ë ¥
            data['training_history'] = TrainingEnrollment.objects.filter(
                employee=employee
            ).order_by('-enrolled_date')[:5]
            
            # ë¦¬ë” ì¶”ì²œ
            data['leader_recommendations'] = LeaderRecommendation.objects.filter(
                employee=employee,
                is_active=True
            ).order_by('-recommendation_date')
            
            # íŒ€ ì •ë³´ (ë§¤ë‹ˆì €ì¸ ê²½ìš°)
            if profile.role in ['manager', 'executive']:
                data['team_members'] = Employee.objects.filter(
                    manager=employee,
                    is_active=True
                )
                
        except Employee.DoesNotExist:
            pass
        
        return data
    
    async def _handle_greeting(self, state: ConversationState, 
                             user_data: Dict[str, Any]) -> ChatbotResponse:
        """ì¸ì‚¬ ì²˜ë¦¬"""
        hour = datetime.now().hour
        time_greeting = "ì¢‹ì€ ì•„ì¹¨ì…ë‹ˆë‹¤" if hour < 12 else "ì¢‹ì€ ì˜¤í›„ì…ë‹ˆë‹¤" if hour < 18 else "ì¢‹ì€ ì €ë…ì…ë‹ˆë‹¤"
        
        message = f"""
{time_greeting}, {state.user_profile.name}ë‹˜! ğŸ˜Š

eHR ì±—ë´‡ ì„œë¹„ìŠ¤ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤.
ì˜¤ëŠ˜ì€ ì–´ë–¤ ë„ì›€ì´ í•„ìš”í•˜ì‹ ê°€ìš”?
"""
        
        # ê°œì¸í™”ëœ ì œì•ˆ
        suggestions = []
        
        # ìµœê·¼ ì¸ì¦ ì²´í¬ê°€ ìˆì—ˆë‹¤ë©´
        if user_data.get('growth_level', {}).get('certifications'):
            suggestions.append("ì„±ì¥ë ˆë²¨ ì¸ì¦ ì§„í–‰ìƒí™© í™•ì¸")
        
        # êµìœ¡ ì¶”ì²œ
        suggestions.append("ë§ì¶¤í˜• êµìœ¡ê³¼ì • ì¶”ì²œë°›ê¸°")
        
        # í‰ê°€ ì‹œì¦Œì´ë©´
        current_month = datetime.now().month
        if current_month in [3, 6, 9, 12]:
            suggestions.append("í‰ê°€ ê²°ê³¼ í™•ì¸í•˜ê¸°")
        
        # ë§¤ë‹ˆì €ë¼ë©´
        if state.user_profile.role in ['manager', 'executive']:
            suggestions.append("íŒ€ ì„±ê³¼ ëŒ€ì‹œë³´ë“œ ë³´ê¸°")
        
        quick_replies = [
            {"text": "ë‚´ ì •ë³´ í™•ì¸", "payload": "PERSONAL_INFO"},
            {"text": "ì„±ì¥ë ˆë²¨ ì²´í¬", "payload": "GROWTH_LEVEL"},
            {"text": "êµìœ¡ ê³¼ì • ì°¾ê¸°", "payload": "TRAINING_INQUIRY"},
            {"text": "ë„ì›€ë§", "payload": "HELP"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.GREETING,
            confidence=1.0,
            mode=ResponseMode.INTERACTIVE,
            suggestions=suggestions,
            quick_replies=quick_replies
        )
    
    async def _handle_personal_info(self, state: ConversationState,
                                  user_data: Dict[str, Any]) -> ChatbotResponse:
        """ê°œì¸ì •ë³´ ì¡°íšŒ"""
        profile = state.user_profile
        
        # ìƒì„¸ ì •ë³´ êµ¬ì„±
        info_sections = []
        
        # ê¸°ë³¸ ì •ë³´
        basic_info = f"""
ğŸ“‹ **ê¸°ë³¸ ì •ë³´**
â€¢ ì„±ëª…: {profile.name}
â€¢ ì‚¬ë²ˆ: {profile.employee_id}
â€¢ ì§ê¸‰: {profile.position}
â€¢ ë¶€ì„œ: {profile.department}
"""
        info_sections.append(basic_info)
        
        # ì„±ì¥ ë ˆë²¨
        growth_info = f"""
ğŸ“ˆ **ì„±ì¥ ë ˆë²¨**
â€¢ í˜„ì¬ ë ˆë²¨: {user_data.get('growth_level', {}).get('current', 'Lv.1')}
â€¢ ì¸ì¦ ì´ë ¥: {len(user_data.get('growth_level', {}).get('certifications', []))}ê±´
"""
        info_sections.append(growth_info)
        
        # ìµœê·¼ í‰ê°€
        if user_data.get('latest_evaluation'):
            eval_data = user_data['latest_evaluation']
            eval_info = f"""
ğŸ“Š **ìµœê·¼ í‰ê°€**
â€¢ í‰ê°€ ê¸°ê°„: {eval_data.evaluation_year}ë…„ {eval_data.evaluation_quarter}ë¶„ê¸°
â€¢ í‰ê°€ ë“±ê¸‰: {eval_data.grade}
â€¢ ì¢…í•© ì ìˆ˜: {eval_data.total_score}ì 
"""
            info_sections.append(eval_info)
        
        # êµìœ¡ ì´ìˆ˜
        training_count = user_data.get('training_history', []).count()
        if training_count > 0:
            training_info = f"""
ğŸ“š **êµìœ¡ í˜„í™©**
â€¢ ì´ ì´ìˆ˜ ê³¼ì •: {training_count}ê°œ
â€¢ ìµœê·¼ êµìœ¡: {user_data['training_history'][0].course.title if training_count > 0 else '-'}
"""
            info_sections.append(training_info)
        
        message = "\n".join(info_sections)
        
        # ì‹œê°í™” ì¶”ê°€
        visualizations = [
            {
                'type': 'info_card',
                'title': 'ë‚˜ì˜ HR í”„ë¡œí•„',
                'data': {
                    'employee_id': profile.employee_id,
                    'name': profile.name,
                    'position': profile.position,
                    'department': profile.department,
                    'growth_level': user_data.get('growth_level', {}).get('current', 'Lv.1')
                }
            }
        ]
        
        # ê´€ë ¨ ì•¡ì…˜
        actions = [
            {
                'type': 'button',
                'text': 'ìƒì„¸ ì´ë ¥ ë³´ê¸°',
                'action': 'VIEW_DETAILED_HISTORY'
            },
            {
                'type': 'button',
                'text': 'ì •ë³´ ìˆ˜ì • ìš”ì²­',
                'action': 'REQUEST_INFO_UPDATE'
            }
        ]
        
        quick_replies = [
            {"text": "ì„±ì¥ë ˆë²¨ ì¸ì¦ ì²´í¬", "payload": "CERTIFICATION_CHECK"},
            {"text": "êµìœ¡ ì´ë ¥ ìƒì„¸ë³´ê¸°", "payload": "TRAINING_HISTORY"},
            {"text": "í‰ê°€ ì´ë ¥ ì¡°íšŒ", "payload": "EVALUATION_HISTORY"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.PERSONAL_INFO,
            confidence=0.95,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            actions=actions,
            quick_replies=quick_replies,
            bookmarkable=True,
            bookmark_data={'type': 'personal_info', 'employee_id': profile.employee_id}
        )
    
    async def _handle_growth_level(self, state: ConversationState,
                                 user_data: Dict[str, Any]) -> ChatbotResponse:
        """ì„±ì¥ë ˆë²¨ ì¡°íšŒ"""
        current_level = user_data.get('growth_level', {}).get('current', 'Lv.1')
        certifications = user_data.get('growth_level', {}).get('certifications', [])
        
        # ë‹¤ìŒ ë ˆë²¨ ê³„ì‚°
        level_map = {
            'Lv.1': 'Lv.2', 'Lv.2': 'Lv.3',
            'Lv.3': 'Lv.4', 'Lv.4': 'Lv.5',
            'Lv.5': 'Lv.5'
        }
        next_level = level_map.get(current_level, 'Lv.2')
        
        # ì¸ì¦ ì²´í¬ (ê°„ë‹¨ ë²„ì „)
        from certifications.certification_services import CertificationService
        cert_service = CertificationService()
        
        try:
            employee = Employee.objects.get(id=state.user_profile.employee_id)
            cert_result = cert_service.check_growth_level_certification(
                employee=employee,
                target_level=next_level
            )
            
            readiness = cert_result.get('certification_result', 'ë¯¸ì¶©ì¡±')
            progress = cert_result.get('progress', {}).get('overall', 0)
            
        except:
            readiness = 'í™•ì¸ í•„ìš”'
            progress = 0
        
        message = f"""
ğŸ¯ **{state.user_profile.name}ë‹˜ì˜ ì„±ì¥ë ˆë²¨ í˜„í™©**

í˜„ì¬ ë ˆë²¨: **{current_level}**
ë‹¤ìŒ ëª©í‘œ: **{next_level}**

ğŸ“Š **ì¸ì¦ ì¤€ë¹„ë„**
â€¢ ìƒíƒœ: {readiness}
â€¢ ì§„í–‰ë¥ : {progress:.1f}%

"""
        
        # ì§„í–‰ë¥  ì‹œê°í™”
        if readiness == 'ì¶©ì¡±':
            message += "âœ… ì¶•í•˜í•©ë‹ˆë‹¤! ë‹¤ìŒ ë ˆë²¨ ì¸ì¦ì„ ì‹ ì²­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
        elif readiness == 'ë¶€ë¶„ì¶©ì¡±':
            message += "ğŸ“ˆ ì¡°ê¸ˆë§Œ ë” ë…¸ë ¥í•˜ì‹œë©´ ì¸ì¦ ìš”ê±´ì„ ì¶©ì¡±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!\n"
        else:
            message += "ğŸ’ª ì„±ì¥ì„ ìœ„í•´ í•¨ê»˜ ê³„íšì„ ì„¸ì›Œë³´ì•„ìš”.\n"
        
        # ì¸ì¦ ì´ë ¥
        if certifications:
            message += "\nğŸ“œ **ì¸ì¦ ì´ë ¥**\n"
            for cert in certifications[:3]:
                message += f"â€¢ {cert.target_level} - {cert.certified_date.strftime('%Y.%m.%d')}\n"
        
        # ì‹œê°í™”
        visualizations = [
            {
                'type': 'progress_chart',
                'title': 'ì„±ì¥ë ˆë²¨ ì§„í–‰ìƒí™©',
                'data': {
                    'current': current_level,
                    'target': next_level,
                    'progress': progress,
                    'areas': {
                        'í‰ê°€': cert_result.get('progress', {}).get('evaluation', 0),
                        'êµìœ¡': cert_result.get('progress', {}).get('training', 0),
                        'ìŠ¤í‚¬': cert_result.get('progress', {}).get('skills', 0),
                        'ê²½ë ¥': cert_result.get('progress', {}).get('experience', 0)
                    }
                }
            }
        ]
        
        # ì¶”ì²œ ì•¡ì…˜
        quick_replies = []
        if readiness == 'ì¶©ì¡±':
            quick_replies.append({"text": "ì¸ì¦ ì‹ ì²­í•˜ê¸°", "payload": "APPLY_CERTIFICATION"})
        else:
            quick_replies.extend([
                {"text": "ë¶€ì¡±í•œ ìš”ê±´ í™•ì¸", "payload": "CHECK_MISSING_REQUIREMENTS"},
                {"text": "êµìœ¡ ì¶”ì²œë°›ê¸°", "payload": "GET_TRAINING_RECOMMENDATIONS"},
                {"text": "ì„±ì¥ ê³„íš ì„¸ìš°ê¸°", "payload": "CREATE_DEVELOPMENT_PLAN"}
            ])
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.GROWTH_LEVEL,
            confidence=0.9,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            quick_replies=quick_replies,
            bookmarkable=True,
            bookmark_data={'type': 'growth_level', 'level': current_level}
        )
    
    async def _handle_certification_check(self, state: ConversationState,
                                        user_data: Dict[str, Any],
                                        message: str) -> ChatbotResponse:
        """ì¸ì¦ ì²´í¬ ì²˜ë¦¬"""
        # ëª©í‘œ ë ˆë²¨ ì¶”ì¶œ
        level_match = re.search(r'Lv\.?\s*(\d)', message)
        if level_match:
            target_level = f"Lv.{level_match.group(1)}"
        else:
            # ëª…í™•í™” í•„ìš”
            if state.context != ConversationContext.CLARIFICATION:
                return ChatbotResponse(
                    message="ì–´ë–¤ ë ˆë²¨ì˜ ì¸ì¦ì„ í™•ì¸í•˜ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
                    intent=ConversationIntent.CERTIFICATION_CHECK,
                    confidence=0.8,
                    mode=ResponseMode.INTERACTIVE,
                    quick_replies=[
                        {"text": "Lv.2", "payload": "CHECK_LV2"},
                        {"text": "Lv.3", "payload": "CHECK_LV3"},
                        {"text": "Lv.4", "payload": "CHECK_LV4"},
                        {"text": "Lv.5", "payload": "CHECK_LV5"}
                    ]
                )
            else:
                # ê¸°ë³¸ê°’ ì‚¬ìš©
                current_level = user_data.get('growth_level', {}).get('current', 'Lv.1')
                level_map = {'Lv.1': 'Lv.2', 'Lv.2': 'Lv.3', 'Lv.3': 'Lv.4', 'Lv.4': 'Lv.5'}
                target_level = level_map.get(current_level, 'Lv.2')
        
        # ì¸ì¦ ì²´í¬ ìˆ˜í–‰
        from certifications.certification_services import CertificationService
        cert_service = CertificationService()
        
        try:
            employee = Employee.objects.get(id=state.user_profile.employee_id)
            cert_result = cert_service.check_growth_level_certification(
                employee=employee,
                target_level=target_level
            )
            
            # ê²°ê³¼ ë©”ì‹œì§€ êµ¬ì„±
            message = f"""
ğŸ” **{target_level} ì¸ì¦ ì²´í¬ ê²°ê³¼**

ì¢…í•© ê²°ê³¼: **{cert_result['certification_result']}**
ì „ì²´ ì§„í–‰ë¥ : **{cert_result.get('progress', {}).get('overall', 0):.1f}%**

ğŸ“‹ **ì˜ì—­ë³„ ì¶©ì¡± í˜„í™©**
"""
            
            # ì²´í¬ í•­ëª©ë³„ ìƒíƒœ
            checks = cert_result.get('checks', {})
            check_items = [
                ('í‰ê°€', checks.get('evaluation', False), cert_result.get('progress', {}).get('evaluation', 0)),
                ('êµìœ¡', checks.get('training', False), cert_result.get('progress', {}).get('training', 0)),
                ('ìŠ¤í‚¬', checks.get('skills', False), cert_result.get('progress', {}).get('skills', 0)),
                ('ê²½ë ¥', checks.get('experience', False), cert_result.get('progress', {}).get('experience', 0))
            ]
            
            for item, passed, progress in check_items:
                icon = "âœ…" if passed else "âŒ"
                message += f"{icon} {item}: {progress:.0f}%\n"
            
            # ë¶€ì¡±í•œ ìš”ê±´ ìƒì„¸
            if cert_result['details']['missing_courses']:
                message += f"\nğŸ“š **í•„ìˆ˜ êµìœ¡ ë¯¸ì´ìˆ˜**\n"
                for course in cert_result['details']['missing_courses']:
                    message += f"â€¢ {course}\n"
            
            if cert_result['details']['missing_skills']:
                message += f"\nğŸ› ï¸ **ë¶€ì¡±í•œ ìŠ¤í‚¬**\n"
                for skill in cert_result['details']['missing_skills']:
                    message += f"â€¢ {skill}\n"
            
            # ì˜ˆìƒ ì¸ì¦ì¼
            if cert_result.get('expected_certification_date'):
                message += f"\nğŸ“… ì˜ˆìƒ ì¸ì¦ ê°€ëŠ¥ì¼: {cert_result['expected_certification_date']}\n"
            
            # ê¶Œê³ ì‚¬í•­
            if cert_result.get('recommendations'):
                message += "\nğŸ’¡ **ê¶Œê³ ì‚¬í•­**\n"
                for rec in cert_result['recommendations'][:3]:
                    message += f"â€¢ {rec}\n"
            
            # ì‹œê°í™”
            visualizations = [
                {
                    'type': 'radar_chart',
                    'title': 'ì¸ì¦ ìš”ê±´ ì¶©ì¡±ë„',
                    'data': {
                        'labels': ['í‰ê°€', 'êµìœ¡', 'ìŠ¤í‚¬', 'ê²½ë ¥'],
                        'values': [
                            cert_result.get('progress', {}).get('evaluation', 0),
                            cert_result.get('progress', {}).get('training', 0),
                            cert_result.get('progress', {}).get('skills', 0),
                            cert_result.get('progress', {}).get('experience', 0)
                        ]
                    }
                }
            ]
            
            # ì•¡ì…˜ ë²„íŠ¼
            actions = []
            if cert_result['certification_result'] == 'ì¶©ì¡±':
                actions.append({
                    'type': 'button',
                    'text': 'ì¸ì¦ ì‹ ì²­í•˜ê¸°',
                    'action': 'APPLY_CERTIFICATION',
                    'data': {'level': target_level}
                })
            else:
                if cert_result['details']['missing_courses']:
                    actions.append({
                        'type': 'button',
                        'text': 'í•„ìˆ˜ êµìœ¡ ì‹ ì²­',
                        'action': 'ENROLL_REQUIRED_COURSES',
                        'data': {'courses': cert_result['details']['missing_courses']}
                    })
                
                actions.append({
                    'type': 'button',
                    'text': 'ì„±ì¥ ê³„íš ìˆ˜ë¦½',
                    'action': 'CREATE_GROWTH_PLAN',
                    'data': {'target_level': target_level}
                })
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.CERTIFICATION_CHECK,
                confidence=0.95,
                mode=ResponseMode.VISUAL,
                visualizations=visualizations,
                actions=actions,
                bookmarkable=True,
                bookmark_data={
                    'type': 'certification_check',
                    'target_level': target_level,
                    'result': cert_result['certification_result']
                }
            )
            
        except Exception as e:
            return ChatbotResponse(
                message=f"ì¸ì¦ ì²´í¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}",
                intent=ConversationIntent.CERTIFICATION_CHECK,
                confidence=0.5,
                mode=ResponseMode.SIMPLE
            )
    
    async def _handle_training_inquiry(self, state: ConversationState,
                                     user_data: Dict[str, Any],
                                     message: str) -> ChatbotResponse:
        """êµìœ¡ ë¬¸ì˜ ì²˜ë¦¬"""
        # í‚¤ì›Œë“œ ì¶”ì¶œ
        keywords = self._extract_keywords(message)
        
        # ì¶”ì²œ êµìœ¡ ì¡°íšŒ
        from trainings.training_services import TrainingRecommendationService
        training_service = TrainingRecommendationService()
        
        try:
            employee = Employee.objects.get(id=state.user_profile.employee_id)
            
            # ë§ì¶¤í˜• ì¶”ì²œ
            recommendations = training_service.get_employee_training_recommendations(
                employee=employee,
                max_recommendations=5
            )
            
            courses = recommendations.get('recommendations', [])
            
            if courses:
                message = f"""
ğŸ“š **{state.user_profile.name}ë‹˜ì„ ìœ„í•œ ë§ì¶¤ êµìœ¡ ì¶”ì²œ**

"""
                
                for i, course in enumerate(courses, 1):
                    message += f"""
**{i}. {course['title']}**
â€¢ ì½”ë“œ: {course['course_code']}
â€¢ ì¹´í…Œê³ ë¦¬: {course['category']}
â€¢ êµìœ¡ì‹œê°„: {course['duration_hours']}ì‹œê°„
â€¢ ë§¤ì¹­ë„: {course['match_score']:.0f}%
â€¢ ì¶”ì²œ ì´ìœ : {course['recommendation_reason']}

"""
                
                # í•™ìŠµ ë¡œë“œë§µ
                if recommendations.get('roadmap'):
                    message += "\nğŸ“… **ì¶”ì²œ í•™ìŠµ ë¡œë“œë§µ**\n"
                    for month_plan in recommendations['roadmap'][:3]:
                        message += f"\n{month_plan['month']}ê°œì›”ì°¨:\n"
                        for course in month_plan['courses']:
                            message += f"â€¢ {course['title']}\n"
                
            else:
                message = "í˜„ì¬ ì¶”ì²œí•  êµìœ¡ê³¼ì •ì´ ì—†ìŠµë‹ˆë‹¤. í‚¤ì›Œë“œë¡œ ê²€ìƒ‰í•´ë³´ì‹œê² ì–´ìš”?"
            
            # ì‹œê°í™”
            visualizations = []
            if courses:
                visualizations.append({
                    'type': 'course_cards',
                    'title': 'ì¶”ì²œ êµìœ¡ê³¼ì •',
                    'data': courses[:3]
                })
            
            # ì•¡ì…˜
            actions = []
            for course in courses[:3]:
                actions.append({
                    'type': 'button',
                    'text': f"{course['title']} ì‹ ì²­",
                    'action': 'ENROLL_COURSE',
                    'data': {'course_id': course['course_id']}
                })
            
            quick_replies = [
                {"text": "ì „ì²´ êµìœ¡ ëª©ë¡", "payload": "VIEW_ALL_COURSES"},
                {"text": "ë‚´ êµìœ¡ ì´ë ¥", "payload": "MY_TRAINING_HISTORY"},
                {"text": "êµìœ¡ ì¼ì • í™•ì¸", "payload": "TRAINING_SCHEDULE"}
            ]
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.TRAINING_INQUIRY,
                confidence=0.9,
                mode=ResponseMode.VISUAL,
                visualizations=visualizations,
                actions=actions,
                quick_replies=quick_replies
            )
            
        except Exception as e:
            return ChatbotResponse(
                message=f"êµìœ¡ ì¶”ì²œ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}",
                intent=ConversationIntent.TRAINING_INQUIRY,
                confidence=0.5,
                mode=ResponseMode.SIMPLE
            )
    
    async def _handle_career_advice(self, state: ConversationState,
                                  user_data: Dict[str, Any],
                                  message: str) -> ChatbotResponse:
        """ê²½ë ¥ ì¡°ì–¸ ì²˜ë¦¬"""
        # GPTë¥¼ í™œìš©í•œ ê°œì¸í™”ëœ ì¡°ì–¸ ìƒì„±
        career_context = self._build_career_context(user_data)
        
        advice_prompt = f"""
        Based on the following employee profile, provide personalized career advice:
        
        {json.dumps(career_context, ensure_ascii=False, indent=2)}
        
        User's question: {message}
        
        Provide:
        1. Current situation analysis
        2. Short-term recommendations (3-6 months)
        3. Long-term career path options
        4. Specific action items
        
        Respond in Korean with empathy and encouragement.
        """
        
        try:
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": advice_prompt}
                ],
                max_tokens=self.max_tokens,
                temperature=self.temperature
            )
            
            advice_content = response.choices[0].message.content
            
            # êµ¬ì¡°í™”ëœ ì‘ë‹µ ìƒì„±
            message = f"""
ğŸ’¼ **ì»¤ë¦¬ì–´ ìƒë‹´**

{advice_content}

---
*ì´ ì¡°ì–¸ì€ AIê°€ ê·€í•˜ì˜ í”„ë¡œí•„ì„ ë¶„ì„í•˜ì—¬ ìƒì„±í•œ ê²ƒì…ë‹ˆë‹¤. 
ë” êµ¬ì²´ì ì¸ ìƒë‹´ì´ í•„ìš”í•˜ì‹œë©´ HRíŒ€ê³¼ 1:1 ìƒë‹´ì„ ì˜ˆì•½í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.*
"""
            
            # ì‹œê°í™” - ê²½ë ¥ ê²½ë¡œ
            visualizations = [
                {
                    'type': 'career_path',
                    'title': 'ì¶”ì²œ ê²½ë ¥ ê²½ë¡œ',
                    'data': self._generate_career_path_visualization(user_data)
                }
            ]
            
            # ì•¡ì…˜
            actions = [
                {
                    'type': 'button',
                    'text': 'HR ìƒë‹´ ì˜ˆì•½',
                    'action': 'SCHEDULE_HR_CONSULTATION'
                },
                {
                    'type': 'button',
                    'text': 'ë©˜í†  ì°¾ê¸°',
                    'action': 'FIND_MENTOR'
                }
            ]
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.CAREER_ADVICE,
                confidence=0.85,
                mode=ResponseMode.DETAILED,
                visualizations=visualizations,
                actions=actions,
                bookmarkable=True,
                bookmark_data={'type': 'career_advice', 'date': timezone.now().isoformat()}
            )
            
        except Exception as e:
            return ChatbotResponse(
                message="ì£„ì†¡í•©ë‹ˆë‹¤. ì»¤ë¦¬ì–´ ì¡°ì–¸ì„ ìƒì„±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
                intent=ConversationIntent.CAREER_ADVICE,
                confidence=0.5,
                mode=ResponseMode.SIMPLE
            )
    
    async def _handle_team_analytics(self, state: ConversationState,
                                   user_data: Dict[str, Any]) -> ChatbotResponse:
        """íŒ€ ë¶„ì„ ì²˜ë¦¬ (ê´€ë¦¬ììš©)"""
        if state.user_profile.role not in ['manager', 'executive']:
            return ChatbotResponse(
                message="íŒ€ ë¶„ì„ ê¸°ëŠ¥ì€ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
                intent=ConversationIntent.TEAM_ANALYTICS,
                confidence=1.0,
                mode=ResponseMode.SIMPLE
            )
        
        # íŒ€ ë°ì´í„° ìˆ˜ì§‘
        team_members = user_data.get('team_members', [])
        if not team_members:
            return ChatbotResponse(
                message="ê´€ë¦¬í•˜ëŠ” íŒ€ì›ì´ ì—†ìŠµë‹ˆë‹¤.",
                intent=ConversationIntent.TEAM_ANALYTICS,
                confidence=1.0,
                mode=ResponseMode.SIMPLE
            )
        
        # íŒ€ KPI ê³„ì‚°
        team_stats = {
            'total_members': team_members.count(),
            'avg_performance': 0,
            'training_participation': 0,
            'certification_progress': 0,
            'high_performers': 0,
            'development_needs': 0
        }
        
        # íŒ€ì›ë³„ ë°ì´í„° ì§‘ê³„
        for member in team_members:
            # ìµœê·¼ í‰ê°€
            latest_eval = Evaluation.objects.filter(
                employee=member
            ).order_by('-evaluation_year', '-evaluation_quarter').first()
            
            if latest_eval:
                if latest_eval.grade in ['A+', 'A']:
                    team_stats['high_performers'] += 1
                elif latest_eval.grade in ['C', 'D']:
                    team_stats['development_needs'] += 1
            
            # êµìœ¡ ì°¸ì—¬
            recent_training = TrainingEnrollment.objects.filter(
                employee=member,
                enrolled_date__gte=timezone.now() - timedelta(days=90)
            ).exists()
            
            if recent_training:
                team_stats['training_participation'] += 1
        
        # ë¹„ìœ¨ ê³„ì‚°
        team_stats['training_participation_rate'] = (
            team_stats['training_participation'] / team_stats['total_members'] * 100
        )
        team_stats['high_performer_rate'] = (
            team_stats['high_performers'] / team_stats['total_members'] * 100
        )
        
        message = f"""
ğŸ“Š **{state.user_profile.department} íŒ€ í˜„í™©**

ğŸ‘¥ ì´ íŒ€ì›: {team_stats['total_members']}ëª…

**ì„±ê³¼ ë¶„í¬**
â€¢ ê³ ì„±ê³¼ì (A+/A): {team_stats['high_performers']}ëª… ({team_stats['high_performer_rate']:.0f}%)
â€¢ ê°œë°œ í•„ìš”: {team_stats['development_needs']}ëª…

**êµìœ¡ ì°¸ì—¬**
â€¢ ìµœê·¼ 3ê°œì›” êµìœ¡ ì°¸ì—¬: {team_stats['training_participation']}ëª… ({team_stats['training_participation_rate']:.0f}%)

**ì£¼ìš” ì¸ì‚¬ì´íŠ¸**
"""
        
        # AI ì¸ì‚¬ì´íŠ¸ ì¶”ê°€
        if team_stats['high_performer_rate'] > 30:
            message += "âœ… íŒ€ì˜ ê³ ì„±ê³¼ì ë¹„ìœ¨ì´ ë†’ìŠµë‹ˆë‹¤. ìš°ìˆ˜ ì‚¬ë¡€ë¥¼ ê³µìœ í•˜ë©´ ì¢‹ê² ìŠµë‹ˆë‹¤.\n"
        
        if team_stats['training_participation_rate'] < 50:
            message += "ğŸ“š êµìœ¡ ì°¸ì—¬ìœ¨ì´ ë‚®ìŠµë‹ˆë‹¤. íŒ€ ë‹¨ìœ„ êµìœ¡ì„ ê³ ë ¤í•´ë³´ì„¸ìš”.\n"
        
        if team_stats['development_needs'] > 0:
            message += f"ğŸ’¡ {team_stats['development_needs']}ëª…ì˜ íŒ€ì›ì´ ì¶”ê°€ ì§€ì›ì´ í•„ìš”í•©ë‹ˆë‹¤.\n"
        
        # ì‹œê°í™”
        visualizations = [
            {
                'type': 'team_dashboard',
                'title': 'íŒ€ ì„±ê³¼ ëŒ€ì‹œë³´ë“œ',
                'data': team_stats
            }
        ]
        
        # ì•¡ì…˜
        actions = [
            {
                'type': 'button',
                'text': 'íŒ€ì›ë³„ ìƒì„¸ ë³´ê¸°',
                'action': 'VIEW_TEAM_DETAILS'
            },
            {
                'type': 'button',
                'text': 'íŒ€ ë¦¬í¬íŠ¸ ìƒì„±',
                'action': 'GENERATE_TEAM_REPORT'
            }
        ]
        
        quick_replies = [
            {"text": "íŒ€ êµìœ¡ ê³„íš", "payload": "TEAM_TRAINING_PLAN"},
            {"text": "1:1 ë©´ë‹´ ì¼ì •", "payload": "ONE_ON_ONE_SCHEDULE"},
            {"text": "ì„±ê³¼ ê°œì„  ì „ëµ", "payload": "PERFORMANCE_STRATEGY"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.TEAM_ANALYTICS,
            confidence=0.9,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            actions=actions,
            quick_replies=quick_replies
        )
    
    async def _handle_general_conversation(self, state: ConversationState,
                                         message: str,
                                         user_data: Dict[str, Any]) -> ChatbotResponse:
        """ì¼ë°˜ ëŒ€í™” ì²˜ë¦¬"""
        # GPTë¡œ ìì—°ìŠ¤ëŸ¬ìš´ ì‘ë‹µ ìƒì„±
        conversation_context = self._build_conversation_context(state, user_data)
        
        chat_prompt = f"""
        Continue the HR chatbot conversation naturally:
        
        Context: {json.dumps(conversation_context, ensure_ascii=False)}
        User message: {message}
        
        Respond helpfully while staying within the HR assistant role.
        Suggest relevant HR services when appropriate.
        Keep the response concise and friendly.
        
        Language: Respond in the same language as the user's message.
        """
        
        try:
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": chat_prompt}
                ],
                max_tokens=500,
                temperature=self.temperature
            )
            
            response_text = response.choices[0].message.content
            
            # ê´€ë ¨ ì„œë¹„ìŠ¤ ì œì•ˆ
            suggestions = self._generate_contextual_suggestions(message, user_data)
            
            return ChatbotResponse(
                message=response_text,
                intent=ConversationIntent.CHITCHAT,
                confidence=0.7,
                mode=ResponseMode.SIMPLE,
                suggestions=suggestions
            )
            
        except Exception as e:
            return ChatbotResponse(
                message="ì£„ì†¡í•©ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
                intent=ConversationIntent.CHITCHAT,
                confidence=0.5,
                mode=ResponseMode.SIMPLE
            )
    
    async def _process_multimodal_input(self, message: str, 
                                      attachments: List[Dict[str, Any]]) -> str:
        """ë©€í‹°ëª¨ë‹¬ ì…ë ¥ ì²˜ë¦¬"""
        processed_message = message
        
        for attachment in attachments:
            if attachment['type'] == 'image':
                # ì´ë¯¸ì§€ ë¶„ì„
                image_description = await self._analyze_image(attachment['data'])
                processed_message += f"\n[ì´ë¯¸ì§€: {image_description}]"
            
            elif attachment['type'] == 'document':
                # ë¬¸ì„œ ë‚´ìš© ì¶”ì¶œ
                doc_content = await self._extract_document_content(attachment['data'])
                processed_message += f"\n[ë¬¸ì„œ ë‚´ìš©: {doc_content[:200]}...]"
        
        return processed_message
    
    async def _analyze_image(self, image_data: str) -> str:
        """ì´ë¯¸ì§€ ë¶„ì„ (GPT-4 Vision)"""
        try:
            response = openai.ChatCompletion.create(
                model=self.vision_model,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "text",
                                "text": "Describe this image briefly in Korean."
                            },
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{image_data}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=200
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            return "ì´ë¯¸ì§€ ë¶„ì„ ì‹¤íŒ¨"
    
    def _save_conversation_turn(self, state: ConversationState,
                               user_message: str,
                               response: ChatbotResponse):
        """ëŒ€í™” í„´ ì €ì¥"""
        turn = {
            'timestamp': datetime.now(),
            'user_message': user_message,
            'bot_response': response.message,
            'intent': response.intent.value,
            'confidence': response.confidence,
            'requires_followup': len(response.quick_replies) > 0
        }
        
        state.conversation_history.append(turn)
        
        # ìµœëŒ€ 20í„´ë§Œ ìœ ì§€
        if len(state.conversation_history) > 20:
            state.conversation_history = state.conversation_history[-20:]
    
    def _save_conversation_state(self, session_id: str, state: ConversationState):
        """ëŒ€í™” ìƒíƒœ ì €ì¥"""
        cache_key = f"chatbot_session_{session_id}"
        cache.set(cache_key, state, self.session_timeout)
    
    def _extract_keywords(self, message: str) -> List[str]:
        """í‚¤ì›Œë“œ ì¶”ì¶œ"""
        # ê°„ë‹¨í•œ í‚¤ì›Œë“œ ì¶”ì¶œ (ì‹¤ì œë¡œëŠ” NLP ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©)
        stopwords = ['ì€', 'ëŠ”', 'ì´', 'ê°€', 'ì„', 'ë¥¼', 'ì—', 'ì—ì„œ', 'ìœ¼ë¡œ', 'ì™€', 'ê³¼']
        words = message.split()
        keywords = [w for w in words if w not in stopwords and len(w) > 1]
        return keywords
    
    def _build_career_context(self, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """ê²½ë ¥ ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±"""
        context = {
            'current_position': user_data['profile'].position,
            'department': user_data['profile'].department,
            'growth_level': user_data.get('growth_level', {}).get('current', 'Lv.1'),
            'years_of_service': 3,  # ì‹¤ì œ ê³„ì‚° í•„ìš”
            'recent_evaluation': None,
            'completed_trainings': [],
            'skills': []
        }
        
        if user_data.get('latest_evaluation'):
            context['recent_evaluation'] = {
                'grade': user_data['latest_evaluation'].grade,
                'score': user_data['latest_evaluation'].total_score
            }
        
        return context
    
    def _generate_career_path_visualization(self, user_data: Dict[str, Any]) -> Dict[str, Any]:
        """ê²½ë ¥ ê²½ë¡œ ì‹œê°í™” ë°ì´í„° ìƒì„±"""
        current_level = user_data.get('growth_level', {}).get('current', 'Lv.1')
        
        # ì˜ˆì‹œ ê²½ë¡œ
        paths = {
            'Lv.1': [
                {'next': 'Lv.2', 'position': 'ì£¼ì„', 'years': 2},
                {'next': 'Lv.3', 'position': 'ëŒ€ë¦¬', 'years': 4},
                {'next': 'Lv.4', 'position': 'ê³¼ì¥', 'years': 7}
            ],
            'Lv.2': [
                {'next': 'Lv.3', 'position': 'ëŒ€ë¦¬', 'years': 2},
                {'next': 'Lv.4', 'position': 'ê³¼ì¥', 'years': 5},
                {'next': 'Lv.5', 'position': 'ì°¨ì¥', 'years': 8}
            ]
        }
        
        return {
            'current': current_level,
            'paths': paths.get(current_level, [])
        }
    
    def _build_conversation_context(self, state: ConversationState,
                                  user_data: Dict[str, Any]) -> Dict[str, Any]:
        """ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±"""
        return {
            'user_name': state.user_profile.name,
            'role': state.user_profile.role,
            'recent_topics': [turn['intent'] for turn in state.conversation_history[-5:]],
            'current_context': state.context.value,
            'pending_actions': state.pending_actions
        }
    
    def _generate_contextual_suggestions(self, message: str,
                                       user_data: Dict[str, Any]) -> List[str]:
        """ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì œì•ˆ ìƒì„±"""
        suggestions = []
        
        # í‚¤ì›Œë“œ ê¸°ë°˜ ì œì•ˆ
        if 'êµìœ¡' in message or 'training' in message.lower():
            suggestions.append("ì¶”ì²œ êµìœ¡ê³¼ì • ë³´ê¸°")
            suggestions.append("êµìœ¡ ì¼ì • í™•ì¸í•˜ê¸°")
        
        if 'í‰ê°€' in message or 'evaluation' in message.lower():
            suggestions.append("í‰ê°€ ê²°ê³¼ ì¡°íšŒí•˜ê¸°")
            suggestions.append("í‰ê°€ ê¸°ì¤€ í™•ì¸í•˜ê¸°")
        
        if 'ìŠ¹ì§„' in message or 'ë¦¬ë”' in message:
            suggestions.append("ë¦¬ë”ì‹­ ê¸°íšŒ í™•ì¸í•˜ê¸°")
            suggestions.append("ìŠ¹ì§„ ìš”ê±´ ì²´í¬í•˜ê¸°")
        
        # ì‹œì¦Œë³„ ì œì•ˆ
        current_month = datetime.now().month
        if current_month in [3, 6, 9, 12]:
            suggestions.append("ë¶„ê¸° í‰ê°€ ì¼ì • í™•ì¸")
        
        if current_month in [11, 12]:
            suggestions.append("ì—°ê°„ ì„±ê³¼ ë¦¬ë·°")
            suggestions.append("ë‚´ë…„ ëª©í‘œ ì„¤ì •")
        
        return suggestions[:3]  # ìµœëŒ€ 3ê°œ
    
    async def _handle_help(self, state: ConversationState) -> ChatbotResponse:
        """ë„ì›€ë§ ì²˜ë¦¬"""
        help_message = """
ğŸ¤– **eHR ì±—ë´‡ ì‚¬ìš© ê°€ì´ë“œ**

ì €ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë„ì›€ì„ ë“œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

**ğŸ“‹ ì •ë³´ ì¡°íšŒ**
â€¢ "ë‚´ ì •ë³´ í™•ì¸" - ì¸ì‚¬ ì •ë³´ ì¡°íšŒ
â€¢ "ì„±ì¥ë ˆë²¨ í™•ì¸" - í˜„ì¬ ë ˆë²¨ ë° ì§„í–‰ìƒí™©
â€¢ "í‰ê°€ ê²°ê³¼" - ìµœê·¼ í‰ê°€ ê²°ê³¼ í™•ì¸

**ğŸ¯ ì¸ì¦ & ì„±ì¥**
â€¢ "Lv.3 ì¸ì¦ ì²´í¬" - íŠ¹ì • ë ˆë²¨ ì¸ì¦ ìš”ê±´ í™•ì¸
â€¢ "ì¸ì¦ ì‹ ì²­í•˜ê¸°" - ì„±ì¥ë ˆë²¨ ì¸ì¦ ì‹ ì²­
â€¢ "ë¶€ì¡±í•œ ìš”ê±´ í™•ì¸" - ë¯¸ì¶©ì¡± ìš”ê±´ ìƒì„¸ ì¡°íšŒ

**ğŸ“š êµìœ¡**
â€¢ "êµìœ¡ ì¶”ì²œ" - ë§ì¶¤í˜• êµìœ¡ê³¼ì • ì¶”ì²œ
â€¢ "ë¦¬ë”ì‹­ êµìœ¡" - ë¦¬ë”ì‹­ ê³¼ì • ê²€ìƒ‰
â€¢ "êµìœ¡ ì‹ ì²­" - êµìœ¡ê³¼ì • ìˆ˜ê°• ì‹ ì²­

**ğŸ’¼ ê²½ë ¥ ê°œë°œ**
â€¢ "ì»¤ë¦¬ì–´ ìƒë‹´" - AI ê¸°ë°˜ ê²½ë ¥ ì¡°ì–¸
â€¢ "ìŠ¹ì§„ ê°€ëŠ¥ì„±" - ë¦¬ë” ì¶”ì²œ ìƒíƒœ í™•ì¸
â€¢ "ì„±ì¥ ê³„íš" - ê°œì¸ë³„ ì„±ì¥ ë¡œë“œë§µ

**ğŸ“Š ë¶„ì„ & ë¦¬í¬íŠ¸**
â€¢ "KPI ëŒ€ì‹œë³´ë“œ" - ì£¼ìš” ì§€í‘œ í™•ì¸
â€¢ "ë¦¬í¬íŠ¸ ìƒì„±" - ê°ì¢… HR ë¦¬í¬íŠ¸ ìƒì„±

**ğŸ’¡ ì‚¬ìš© íŒ**
â€¢ êµ¬ì²´ì ìœ¼ë¡œ ì§ˆë¬¸í• ìˆ˜ë¡ ì •í™•í•œ ë‹µë³€ì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤
â€¢ ì´ë¯¸ì§€ë‚˜ ë¬¸ì„œë¥¼ ì²¨ë¶€í•˜ì—¬ ì§ˆë¬¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
â€¢ â­ ë²„íŠ¼ìœ¼ë¡œ ì¤‘ìš”í•œ ëŒ€í™”ë¥¼ ë¶ë§ˆí¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?
"""
        
        quick_replies = [
            {"text": "ë‚´ ì •ë³´ í™•ì¸", "payload": "PERSONAL_INFO"},
            {"text": "ì„±ì¥ë ˆë²¨ ì²´í¬", "payload": "GROWTH_LEVEL"},
            {"text": "êµìœ¡ ì¶”ì²œë°›ê¸°", "payload": "TRAINING_INQUIRY"},
            {"text": "ì»¤ë¦¬ì–´ ìƒë‹´", "payload": "CAREER_ADVICE"}
        ]
        
        return ChatbotResponse(
            message=help_message,
            intent=ConversationIntent.HELP,
            confidence=1.0,
            mode=ResponseMode.INTERACTIVE,
            quick_replies=quick_replies
        )
    
    async def _handle_evaluation_status(self, state: ConversationState,
                                      user_data: Dict[str, Any]) -> ChatbotResponse:
        """í‰ê°€ ìƒíƒœ ì¡°íšŒ"""
        latest_eval = user_data.get('latest_evaluation')
        
        if not latest_eval:
            message = "ìµœê·¼ í‰ê°€ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤. HRíŒ€ì— ë¬¸ì˜í•´ì£¼ì„¸ìš”."
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.EVALUATION_STATUS,
                confidence=0.9,
                mode=ResponseMode.SIMPLE
            )
        
        message = f"""
ğŸ“Š **ìµœê·¼ í‰ê°€ ê²°ê³¼**

í‰ê°€ ê¸°ê°„: {latest_eval.evaluation_year}ë…„ {latest_eval.evaluation_quarter}ë¶„ê¸°
ì¢…í•© ë“±ê¸‰: **{latest_eval.grade}**
ì¢…í•© ì ìˆ˜: **{latest_eval.total_score}ì **

**ì˜ì—­ë³„ ì ìˆ˜**
â€¢ ì—…ë¬´ ì„±ê³¼: {latest_eval.performance_score}ì 
â€¢ ì—­ëŸ‰: {latest_eval.competency_score}ì 
â€¢ í˜‘ì—…: {latest_eval.collaboration_score}ì 
â€¢ ì„±ì¥: {latest_eval.growth_score}ì 

**í‰ê°€ì ì½”ë©˜íŠ¸**
"{latest_eval.comments[:100]}..."
"""
        
        # ë“±ê¸‰ë³„ ë©”ì‹œì§€ ì¶”ê°€
        grade_messages = {
            'A+': "ğŸŒŸ íƒì›”í•œ ì„±ê³¼ì…ë‹ˆë‹¤! ë¦¬ë”ì‹­ ê¸°íšŒë¥¼ ê³ ë ¤í•´ë³´ì„¸ìš”.",
            'A': "â­ ìš°ìˆ˜í•œ ì„±ê³¼ì…ë‹ˆë‹¤! ê³„ì† ì´ ì¶”ì„¸ë¥¼ ìœ ì§€í•˜ì„¸ìš”.",
            'B+': "ğŸ‘ ì¢‹ì€ ì„±ê³¼ì…ë‹ˆë‹¤. ì¡°ê¸ˆë§Œ ë” ë…¸ë ¥í•˜ë©´ Aë“±ê¸‰ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.",
            'B': "âœ… ì•ˆì •ì ì¸ ì„±ê³¼ì…ë‹ˆë‹¤. ì„±ì¥ ì˜ì—­ì„ ì°¾ì•„ë³´ì„¸ìš”.",
            'C': "ğŸ’ª ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤. í•¨ê»˜ ì„±ì¥ ê³„íšì„ ì„¸ì›Œë´…ì‹œë‹¤."
        }
        
        if latest_eval.grade in grade_messages:
            message += f"\n\n{grade_messages[latest_eval.grade]}"
        
        # ì‹œê°í™”
        visualizations = [
            {
                'type': 'bar_chart',
                'title': 'ì˜ì—­ë³„ í‰ê°€ ì ìˆ˜',
                'data': {
                    'labels': ['ì—…ë¬´ì„±ê³¼', 'ì—­ëŸ‰', 'í˜‘ì—…', 'ì„±ì¥'],
                    'values': [
                        latest_eval.performance_score,
                        latest_eval.competency_score,
                        latest_eval.collaboration_score,
                        latest_eval.growth_score
                    ]
                }
            }
        ]
        
        # í‰ê°€ ì´ë ¥ ì¶”ê°€
        eval_history = Evaluation.objects.filter(
            employee_id=state.user_profile.employee_id
        ).order_by('-evaluation_year', '-evaluation_quarter')[:4]
        
        if eval_history.count() > 1:
            trend_data = {
                'labels': [f"{e.evaluation_year}-Q{e.evaluation_quarter}" for e in reversed(eval_history)],
                'values': [e.total_score for e in reversed(eval_history)]
            }
            
            visualizations.append({
                'type': 'line_chart',
                'title': 'í‰ê°€ ì ìˆ˜ ì¶”ì´',
                'data': trend_data
            })
        
        quick_replies = [
            {"text": "í‰ê°€ ê¸°ì¤€ í™•ì¸", "payload": "VIEW_EVALUATION_CRITERIA"},
            {"text": "ê°œì„  ê³„íš ìˆ˜ë¦½", "payload": "CREATE_IMPROVEMENT_PLAN"},
            {"text": "1:1 í”¼ë“œë°± ì‹ ì²­", "payload": "REQUEST_FEEDBACK"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.EVALUATION_STATUS,
            confidence=0.95,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            quick_replies=quick_replies,
            bookmarkable=True,
            bookmark_data={
                'type': 'evaluation',
                'period': f"{latest_eval.evaluation_year}-Q{latest_eval.evaluation_quarter}",
                'grade': latest_eval.grade
            }
        )
    
    async def _handle_leader_recommendation(self, state: ConversationState,
                                          user_data: Dict[str, Any]) -> ChatbotResponse:
        """ë¦¬ë” ì¶”ì²œ ì¡°íšŒ"""
        recommendations = user_data.get('leader_recommendations', [])
        
        if not recommendations:
            message = """
ì•„ì§ ë¦¬ë”ì‹­ ì¶”ì²œ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.

ë¦¬ë”ì‹­ ê¸°íšŒë¥¼ ì¤€ë¹„í•˜ì‹œë ¤ë©´:
1. í˜„ì¬ ë ˆë²¨ì˜ ì¸ì¦ì„ ì™„ë£Œí•˜ì„¸ìš”
2. ë¦¬ë”ì‹­ êµìœ¡ê³¼ì •ì„ ì´ìˆ˜í•˜ì„¸ìš”
3. íŒ€ í”„ë¡œì íŠ¸ì—ì„œ ë¦¬ë” ì—­í• ì„ ê²½í—˜í•˜ì„¸ìš”
"""
            
            quick_replies = [
                {"text": "ë¦¬ë”ì‹­ êµìœ¡ ì°¾ê¸°", "payload": "LEADERSHIP_TRAINING"},
                {"text": "ì¸ì¦ ìš”ê±´ í™•ì¸", "payload": "CERTIFICATION_CHECK"},
                {"text": "ë©˜í†  ì°¾ê¸°", "payload": "FIND_MENTOR"}
            ]
            
            return ChatbotResponse(
                message=message,
                intent=ConversationIntent.LEADER_RECOMMENDATION,
                confidence=0.9,
                mode=ResponseMode.INTERACTIVE,
                quick_replies=quick_replies
            )
        
        # ì¶”ì²œ ë‚´ìš© êµ¬ì„±
        latest_rec = recommendations[0]
        
        message = f"""
ğŸ¯ **ë¦¬ë”ì‹­ ì¶”ì²œ í˜„í™©**

ì¶”ì²œ ì§ë¬´: **{latest_rec.target_job.title}**
ì¤€ë¹„ë„ ì ìˆ˜: **{latest_rec.readiness_score}ì **
ì¶”ì²œì¼: {latest_rec.recommendation_date.strftime('%Y-%m-%d')}

**í‰ê°€ ìš”ì•½**
â€¢ ê°•ì : {latest_rec.strengths[:100]}...
â€¢ ê°œë°œ í•„ìš”: {latest_rec.development_areas[:100]}...

**ì¶”ì²œ ì‚¬ìœ **
{latest_rec.recommendation_reason[:200]}...
"""
        
        # ì¤€ë¹„ë„ì— ë”°ë¥¸ ë©”ì‹œì§€
        if latest_rec.readiness_score >= 85:
            message += "\n\nâœ… ì¦‰ì‹œ ë¦¬ë” ì—­í•  ìˆ˜í–‰ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤!"
        elif latest_rec.readiness_score >= 70:
            message += "\n\nğŸ“ˆ 6ê°œì›” ë‚´ ì¤€ë¹„ ì™„ë£Œê°€ ì˜ˆìƒë©ë‹ˆë‹¤."
        else:
            message += "\n\nğŸ’ª ì¶”ê°€ì ì¸ ì—­ëŸ‰ ê°œë°œì´ í•„ìš”í•©ë‹ˆë‹¤."
        
        # ì•¡ì…˜ í”Œëœ
        if latest_rec.action_plans:
            message += "\n\n**ê¶Œì¥ ì•¡ì…˜ í”Œëœ**"
            plans = json.loads(latest_rec.action_plans)
            for i, plan in enumerate(plans[:3], 1):
                message += f"\n{i}. {plan}"
        
        visualizations = [
            {
                'type': 'gauge_chart',
                'title': 'ë¦¬ë”ì‹­ ì¤€ë¹„ë„',
                'data': {
                    'value': latest_rec.readiness_score,
                    'min': 0,
                    'max': 100,
                    'target': 85,
                    'zones': [
                        {'min': 0, 'max': 70, 'color': '#ff6b6b'},
                        {'min': 70, 'max': 85, 'color': '#ffd43b'},
                        {'min': 85, 'max': 100, 'color': '#51cf66'}
                    ]
                }
            }
        ]
        
        actions = []
        if latest_rec.readiness_score >= 85:
            actions.append({
                'type': 'button',
                'text': 'ë¦¬ë” í¬ì§€ì…˜ ì§€ì›',
                'action': 'APPLY_LEADER_POSITION',
                'data': {'job_id': latest_rec.target_job.id}
            })
        
        quick_replies = [
            {"text": "ê°œë°œ ê³„íš ë³´ê¸°", "payload": "VIEW_DEVELOPMENT_PLAN"},
            {"text": "ë¦¬ë”ì‹­ êµìœ¡", "payload": "LEADERSHIP_TRAINING"},
            {"text": "ë©˜í† ë§ ì‹ ì²­", "payload": "REQUEST_MENTORING"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.LEADER_RECOMMENDATION,
            confidence=0.95,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            actions=actions,
            quick_replies=quick_replies,
            bookmarkable=True,
            bookmark_data={
                'type': 'leader_recommendation',
                'job': latest_rec.target_job.title,
                'score': latest_rec.readiness_score
            }
        )
    
    async def _handle_kpi_dashboard(self, state: ConversationState,
                                  user_data: Dict[str, Any],
                                  message: str) -> ChatbotResponse:
        """KPI ëŒ€ì‹œë³´ë“œ ì¡°íšŒ"""
        # ê¶Œí•œ í™•ì¸
        if state.user_profile.role not in ['hr', 'executive', 'manager']:
            return ChatbotResponse(
                message="KPI ëŒ€ì‹œë³´ë“œëŠ” ê´€ë¦¬ì ì´ìƒë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤.",
                intent=ConversationIntent.KPI_DASHBOARD,
                confidence=1.0,
                mode=ResponseMode.SIMPLE
            )
        
        # KPI ë°ì´í„° ì¡°íšŒ
        dept_id = None
        if state.user_profile.role == 'manager':
            # ë§¤ë‹ˆì €ëŠ” ìê¸° ë¶€ì„œë§Œ
            try:
                employee = Employee.objects.get(id=state.user_profile.employee_id)
                dept_id = str(employee.department.id) if employee.department else None
            except:
                pass
        
        # KPI ìš”ì•½
        kpis = self.kpi_analytics.calculate_leader_pipeline_kpis(dept_id)
        cert_kpis = self.kpi_analytics.calculate_certification_progress_kpis(dept_id)
        training_kpis = self.kpi_analytics.calculate_training_effectiveness_kpis(dept_id)
        
        message = f"""
ğŸ“Š **ë¦¬ë”ì‹­ KPI ëŒ€ì‹œë³´ë“œ**
{f"ë¶€ì„œ: {state.user_profile.department}" if dept_id else "ì „ì‚¬"}

**ë¦¬ë” íŒŒì´í”„ë¼ì¸**
â€¢ ì´ í›„ë³´ì: {kpis['total_candidates'].value}ëª…
â€¢ ì¦‰ì‹œ ê°€ëŠ¥: {kpis['ready_now'].value}ëª…
â€¢ í‰ê·  ì¤€ë¹„ë„: {kpis['avg_readiness_score'].value}%

**ì¸ì¦ ì§„í–‰**
â€¢ ì¸ì¦ ì™„ë£Œìœ¨: {cert_kpis['certification_rate'].value}%
â€¢ í‰ê·  ì†Œìš”ì¼: {cert_kpis['avg_certification_days'].value}ì¼

**êµìœ¡ íš¨ê³¼ì„±**
â€¢ ì°¸ì—¬ìœ¨: {training_kpis['participation_rate'].value}%
â€¢ ì´ìˆ˜ìœ¨: {training_kpis['completion_rate'].value}%
"""
        
        # íŠ¸ë Œë“œ ë¶„ì„
        if kpis['total_candidates'].trend == 'up':
            message += "\nğŸ“ˆ ë¦¬ë” í›„ë³´ì ìˆ˜ê°€ ì¦ê°€ ì¶”ì„¸ì…ë‹ˆë‹¤."
        elif kpis['total_candidates'].trend == 'down':
            message += "\nğŸ“‰ ë¦¬ë” í›„ë³´ì ìˆ˜ê°€ ê°ì†Œí•˜ê³  ìˆì–´ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤."
        
        # ì‹œê°í™”
        visualizations = [
            {
                'type': 'kpi_cards',
                'title': 'í•µì‹¬ ì§€í‘œ',
                'data': {
                    'cards': [
                        {
                            'title': 'ë¦¬ë” í›„ë³´ì',
                            'value': kpis['total_candidates'].value,
                            'unit': 'ëª…',
                            'trend': kpis['total_candidates'].trend,
                            'change': kpis['total_candidates'].change_percent
                        },
                        {
                            'title': 'ì¸ì¦ ì™„ë£Œìœ¨',
                            'value': cert_kpis['certification_rate'].value,
                            'unit': '%',
                            'trend': cert_kpis['certification_rate'].trend
                        },
                        {
                            'title': 'êµìœ¡ ì°¸ì—¬ìœ¨',
                            'value': training_kpis['participation_rate'].value,
                            'unit': '%',
                            'trend': training_kpis['participation_rate'].trend
                        }
                    ]
                }
            }
        ]
        
        actions = [
            {
                'type': 'button',
                'text': 'ìƒì„¸ ëŒ€ì‹œë³´ë“œ ì—´ê¸°',
                'action': 'OPEN_FULL_DASHBOARD',
                'data': {'url': '/leader-kpi-dashboard/'}
            },
            {
                'type': 'button',
                'text': 'PDF ë¦¬í¬íŠ¸ ìƒì„±',
                'action': 'GENERATE_KPI_REPORT',
                'data': {'format': 'pdf'}
            }
        ]
        
        quick_replies = [
            {"text": "ë¶€ì„œë³„ ë¹„êµ", "payload": "DEPARTMENT_COMPARISON"},
            {"text": "ì›”ë³„ íŠ¸ë Œë“œ", "payload": "MONTHLY_TREND"},
            {"text": "AI ì¸ì‚¬ì´íŠ¸", "payload": "AI_INSIGHTS"}
        ]
        
        return ChatbotResponse(
            message=message,
            intent=ConversationIntent.KPI_DASHBOARD,
            confidence=0.95,
            mode=ResponseMode.VISUAL,
            visualizations=visualizations,
            actions=actions,
            quick_replies=quick_replies
        )


class ChatbotWebSocketHandler:
    """ì›¹ì†Œì¼“ í•¸ë“¤ëŸ¬ (ì‹¤ì‹œê°„ ëŒ€í™”)"""
    
    def __init__(self):
        self.chatbot = EHRGPTChatbot()
        self.connections = {}
    
    async def connect(self, websocket, path):
        """ì›¹ì†Œì¼“ ì—°ê²°"""
        session_id = str(uuid.uuid4())
        self.connections[session_id] = websocket
        
        # í™˜ì˜ ë©”ì‹œì§€
        welcome = {
            'type': 'connected',
            'session_id': session_id,
            'message': 'eHR ì±—ë´‡ì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.'
        }
        await websocket.send(json.dumps(welcome))
        
        try:
            async for message in websocket:
                data = json.loads(message)
                
                # ë©”ì‹œì§€ ì²˜ë¦¬
                response = await self.chatbot.process_message(
                    user_id=data.get('user_id'),
                    message=data.get('message'),
                    attachments=data.get('attachments'),
                    session_id=session_id
                )
                
                # ì‘ë‹µ ì „ì†¡
                await self.send_response(websocket, response)
                
        except Exception as e:
            print(f"WebSocket error: {e}")
        finally:
            del self.connections[session_id]
    
    async def send_response(self, websocket, response: ChatbotResponse):
        """ì‘ë‹µ ì „ì†¡"""
        response_data = {
            'type': 'message',
            'data': {
                'message': response.message,
                'intent': response.intent.value,
                'confidence': response.confidence,
                'mode': response.mode.value,
                'suggestions': response.suggestions,
                'actions': response.actions,
                'visualizations': response.visualizations,
                'quick_replies': response.quick_replies,
                'bookmarkable': response.bookmarkable,
                'bookmark_data': response.bookmark_data
            }
        }
        
        await websocket.send(json.dumps(response_data, ensure_ascii=False))


class ChatbotView(TemplateView):
    """ì±—ë´‡ ì¸í„°í˜ì´ìŠ¤ ë·°"""
    template_name = 'chatbot/ehr_chatbot.html'
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # ì‚¬ìš©ì ì •ë³´
        context['user_id'] = self.request.user.id
        context['user_name'] = self.request.user.get_full_name() or self.request.user.username
        
        # ë¶ë§ˆí¬ ë¡œë“œ
        context['bookmarks'] = self._load_bookmarks(self.request.user)
        
        # ì„¤ì •
        context['chatbot_settings'] = {
            'enable_voice': True,
            'enable_attachments': True,
            'max_file_size': 10 * 1024 * 1024,  # 10MB
            'allowed_file_types': ['image/jpeg', 'image/png', 'application/pdf']
        }
        
        return context
    
    def _load_bookmarks(self, user):
        """ë¶ë§ˆí¬ ë¡œë“œ"""
        # ì‹¤ì œ êµ¬í˜„ì‹œ ë¶ë§ˆí¬ ëª¨ë¸ì—ì„œ ì¡°íšŒ
        return []


class ChatbotAPIView(View):
    """ì±—ë´‡ REST API"""
    
    def __init__(self):
        super().__init__()
        self.chatbot = EHRGPTChatbot()
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    async def post(self, request):
        """ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            data = json.loads(request.body)
            
            # ë¹„ë™ê¸° ì²˜ë¦¬
            response = await self.chatbot.process_message(
                user_id=str(request.user.id),
                message=data.get('message', ''),
                attachments=data.get('attachments', []),
                session_id=data.get('session_id')
            )
            
            # ì‘ë‹µ ì§ë ¬í™”
            response_data = {
                'message': response.message,
                'intent': response.intent.value,
                'confidence': response.confidence,
                'mode': response.mode.value,
                'suggestions': response.suggestions,
                'actions': response.actions,
                'visualizations': response.visualizations,
                'attachments': response.attachments,
                'quick_replies': response.quick_replies,
                'bookmarkable': response.bookmarkable,
                'bookmark_data': response.bookmark_data,
                'timestamp': timezone.now().isoformat()
            }
            
            return JsonResponse(response_data)
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)


class ChatbotBookmarkView(View):
    """ë¶ë§ˆí¬ ê´€ë¦¬"""
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)
    
    def get(self, request):
        """ë¶ë§ˆí¬ ëª©ë¡ ì¡°íšŒ"""
        # ì‹¤ì œ êµ¬í˜„ì‹œ ë¶ë§ˆí¬ ëª¨ë¸ì—ì„œ ì¡°íšŒ
        bookmarks = []
        
        return JsonResponse({'bookmarks': bookmarks})
    
    def post(self, request):
        """ë¶ë§ˆí¬ ì¶”ê°€"""
        try:
            data = json.loads(request.body)
            
            # ë¶ë§ˆí¬ ì €ì¥
            # ì‹¤ì œ êµ¬í˜„ì‹œ ë¶ë§ˆí¬ ëª¨ë¸ì— ì €ì¥
            
            return JsonResponse({'message': 'ë¶ë§ˆí¬ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.'})
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)


# URL íŒ¨í„´
urlpatterns = [
    # ì±—ë´‡ ì¸í„°í˜ì´ìŠ¤
    path('chatbot/', ChatbotView.as_view(), name='chatbot'),
    
    # API ì—”ë“œí¬ì¸íŠ¸
    path('api/chatbot/message/', ChatbotAPIView.as_view(), name='chatbot_message'),
    path('api/chatbot/bookmarks/', ChatbotBookmarkView.as_view(), name='chatbot_bookmarks'),
]


# ì±—ë´‡ UI HTML
CHATBOT_HTML = """
<!-- templates/chatbot/ehr_chatbot.html -->
{% extends 'base.html' %}
{% load static %}

{% block title %}eHR AI ì±—ë´‡{% endblock %}

{% block extra_css %}
<style>
    .chatbot-container {
        max-width: 800px;
        margin: 0 auto;
        height: calc(100vh - 100px);
        display: flex;
        flex-direction: column;
        background: #f8f9fa;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .chatbot-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .chatbot-status {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #4ade80;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
    
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: white;
    }
    
    .message {
        margin-bottom: 20px;
        animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .message.user {
        text-align: right;
    }
    
    .message-bubble {
        display: inline-block;
        max-width: 70%;
        padding: 12px 20px;
        border-radius: 20px;
        position: relative;
    }
    
    .user .message-bubble {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-bottom-right-radius: 4px;
    }
    
    .bot .message-bubble {
        background: #f3f4f6;
        color: #1f2937;
        border-bottom-left-radius: 4px;
    }
    
    .message-time {
        font-size: 0.75rem;
        color: #9ca3af;
        margin-top: 4px;
    }
    
    .quick-replies {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .quick-reply-btn {
        padding: 8px 16px;
        border: 1px solid #e5e7eb;
        border-radius: 20px;
        background: white;
        color: #374151;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.875rem;
    }
    
    .quick-reply-btn:hover {
        background: #667eea;
        color: white;
        border-color: #667eea;
    }
    
    .action-buttons {
        margin-top: 15px;
        display: flex;
        gap: 10px;
    }
    
    .action-btn {
        padding: 10px 20px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .action-btn:hover {
        background: #5a67d8;
        transform: translateY(-1px);
    }
    
    .visualization {
        margin: 15px 0;
        padding: 20px;
        background: #f9fafb;
        border-radius: 8px;
        border: 1px solid #e5e7eb;
    }
    
    .chart-container {
        height: 300px;
        margin-top: 10px;
    }
    
    .info-card {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 20px;
        margin: 10px 0;
    }
    
    .info-card h4 {
        color: #667eea;
        margin-bottom: 15px;
    }
    
    .info-row {
        display: flex;
        justify-content: space-between;
        padding: 8px 0;
        border-bottom: 1px solid #f3f4f6;
    }
    
    .info-row:last-child {
        border-bottom: none;
    }
    
    .chat-input-container {
        padding: 20px;
        background: white;
        border-top: 1px solid #e5e7eb;
    }
    
    .input-wrapper {
        display: flex;
        gap: 10px;
        align-items: flex-end;
    }
    
    .chat-input {
        flex: 1;
        padding: 12px 20px;
        border: 2px solid #e5e7eb;
        border-radius: 25px;
        outline: none;
        font-size: 1rem;
        resize: none;
        max-height: 120px;
        transition: border-color 0.2s;
    }
    
    .chat-input:focus {
        border-color: #667eea;
    }
    
    .input-actions {
        display: flex;
        gap: 8px;
    }
    
    .input-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .send-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }
    
    .send-btn:hover {
        transform: scale(1.1);
    }
    
    .attach-btn {
        background: #f3f4f6;
        color: #6b7280;
    }
    
    .attach-btn:hover {
        background: #e5e7eb;
    }
    
    .typing-indicator {
        display: inline-flex;
        align-items: center;
        padding: 15px 20px;
        background: #f3f4f6;
        border-radius: 20px;
        border-bottom-left-radius: 4px;
    }
    
    .typing-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #9ca3af;
        margin: 0 2px;
        animation: typing 1.4s infinite;
    }
    
    .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
    }
    
    .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
    }
    
    @keyframes typing {
        0%, 60%, 100% {
            opacity: 0.2;
            transform: scale(0.8);
        }
        30% {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    .bookmark-btn {
        background: none;
        border: none;
        color: #fbbf24;
        cursor: pointer;
        font-size: 1.2rem;
        transition: all 0.2s;
    }
    
    .bookmark-btn:hover {
        transform: scale(1.2);
    }
    
    .bookmark-btn.bookmarked {
        color: #f59e0b;
    }
    
    .suggestions {
        margin-top: 10px;
        padding: 10px;
        background: #fef3c7;
        border-radius: 8px;
        font-size: 0.875rem;
    }
    
    .suggestions h5 {
        margin: 0 0 8px 0;
        color: #92400e;
    }
    
    .suggestions ul {
        margin: 0;
        padding-left: 20px;
    }
    
    @media (max-width: 768px) {
        .chatbot-container {
            height: 100vh;
            border-radius: 0;
        }
        
        .message-bubble {
            max-width: 85%;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="chatbot-container">
    <div class="chatbot-header">
        <div>
            <h3>eHR AI Assistant</h3>
            <div class="chatbot-status">
                <div class="status-dot"></div>
                <span>ì˜¨ë¼ì¸</span>
            </div>
        </div>
        <div>
            <button class="bookmark-btn" id="bookmarkToggle">
                <i class="far fa-star"></i>
            </button>
        </div>
    </div>
    
    <div class="chat-messages" id="chatMessages">
        <!-- Messages will be dynamically added here -->
    </div>
    
    <div class="chat-input-container">
        <div class="input-wrapper">
            <textarea 
                id="chatInput" 
                class="chat-input" 
                placeholder="ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?"
                rows="1"
            ></textarea>
            <div class="input-actions">
                <button class="input-btn attach-btn" id="attachBtn">
                    <i class="fas fa-paperclip"></i>
                </button>
                <button class="input-btn send-btn" id="sendBtn">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
        <input type="file" id="fileInput" style="display: none;" accept="image/*,application/pdf">
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// Chatbot JavaScript Implementation
class EHRChatbot {
    constructor() {
        this.userId = '{{ user_id }}';
        this.userName = '{{ user_name }}';
        this.sessionId = this.generateSessionId();
        this.messagesContainer = document.getElementById('chatMessages');
        this.inputField = document.getElementById('chatInput');
        this.sendBtn = document.getElementById('sendBtn');
        this.attachBtn = document.getElementById('attachBtn');
        this.fileInput = document.getElementById('fileInput');
        this.bookmarkBtn = document.getElementById('bookmarkToggle');
        this.attachments = [];
        this.isTyping = false;
        
        this.initializeEventListeners();
        this.sendInitialGreeting();
    }
    
    generateSessionId() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    
    initializeEventListeners() {
        this.sendBtn.addEventListener('click', () => this.sendMessage());
        this.inputField.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });
        
        this.attachBtn.addEventListener('click', () => {
            this.fileInput.click();
        });
        
        this.fileInput.addEventListener('change', (e) => {
            this.handleFileSelect(e);
        });
        
        this.bookmarkBtn.addEventListener('click', () => {
            this.toggleBookmark();
        });
        
        // Auto-resize textarea
        this.inputField.addEventListener('input', () => {
            this.inputField.style.height = 'auto';
            this.inputField.style.height = this.inputField.scrollHeight + 'px';
        });
    }
    
    async sendInitialGreeting() {
        // Wait a moment before showing greeting
        setTimeout(() => {
            this.addBotMessage("ì•ˆë…•í•˜ì„¸ìš”! eHR AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤. ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”? ğŸ˜Š", {
                quick_replies: [
                    {text: "ë‚´ ì •ë³´ í™•ì¸", payload: "PERSONAL_INFO"},
                    {text: "ì„±ì¥ë ˆë²¨ ì²´í¬", payload: "GROWTH_LEVEL"},
                    {text: "êµìœ¡ ì¶”ì²œë°›ê¸°", payload: "TRAINING_INQUIRY"},
                    {text: "ë„ì›€ë§", payload: "HELP"}
                ]
            });
        }, 500);
    }
    
    async sendMessage() {
        const message = this.inputField.value.trim();
        if (!message && this.attachments.length === 0) return;
        
        // Add user message
        this.addUserMessage(message);
        
        // Clear input
        this.inputField.value = '';
        this.inputField.style.height = 'auto';
        
        // Show typing indicator
        this.showTypingIndicator();
        
        try {
            const response = await fetch('/api/chatbot/message/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify({
                    message: message,
                    attachments: this.attachments,
                    session_id: this.sessionId
                })
            });
            
            const data = await response.json();
            
            // Remove typing indicator
            this.hideTypingIndicator();
            
            // Add bot response
            this.addBotMessage(data.message, data);
            
            // Clear attachments
            this.attachments = [];
            
        } catch (error) {
            this.hideTypingIndicator();
            this.addBotMessage("ì£„ì†¡í•©ë‹ˆë‹¤. ì¼ì‹œì ì¸ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
        }
    }
    
    addUserMessage(message) {
        const messageDiv = this.createMessageElement('user', message);
        this.messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    addBotMessage(message, data = {}) {
        const messageDiv = this.createMessageElement('bot', message);
        
        // Add visualizations
        if (data.visualizations && data.visualizations.length > 0) {
            data.visualizations.forEach(viz => {
                const vizElement = this.createVisualization(viz);
                messageDiv.appendChild(vizElement);
            });
        }
        
        // Add action buttons
        if (data.actions && data.actions.length > 0) {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'action-buttons';
            
            data.actions.forEach(action => {
                const btn = document.createElement('button');
                btn.className = 'action-btn';
                btn.innerHTML = `<i class="fas fa-${this.getActionIcon(action.type)}"></i> ${action.text}`;
                btn.onclick = () => this.handleAction(action);
                actionsDiv.appendChild(btn);
            });
            
            messageDiv.appendChild(actionsDiv);
        }
        
        // Add suggestions
        if (data.suggestions && data.suggestions.length > 0) {
            const suggestionsDiv = document.createElement('div');
            suggestionsDiv.className = 'suggestions';
            suggestionsDiv.innerHTML = `
                <h5>ê´€ë ¨ ì œì•ˆ:</h5>
                <ul>
                    ${data.suggestions.map(s => `<li>${s}</li>`).join('')}
                </ul>
            `;
            messageDiv.appendChild(suggestionsDiv);
        }
        
        // Add quick replies
        if (data.quick_replies && data.quick_replies.length > 0) {
            const quickRepliesDiv = document.createElement('div');
            quickRepliesDiv.className = 'quick-replies';
            
            data.quick_replies.forEach(reply => {
                const btn = document.createElement('button');
                btn.className = 'quick-reply-btn';
                btn.textContent = reply.text;
                btn.onclick = () => {
                    this.inputField.value = reply.text;
                    this.sendMessage();
                };
                quickRepliesDiv.appendChild(btn);
            });
            
            messageDiv.appendChild(quickRepliesDiv);
        }
        
        // Add bookmark button if bookmarkable
        if (data.bookmarkable) {
            const bookmarkBtn = document.createElement('button');
            bookmarkBtn.className = 'bookmark-btn message-bookmark';
            bookmarkBtn.innerHTML = '<i class="far fa-star"></i>';
            bookmarkBtn.onclick = () => this.bookmarkMessage(data.bookmark_data);
            messageDiv.querySelector('.message-bubble').appendChild(bookmarkBtn);
        }
        
        this.messagesContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    createMessageElement(sender, message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${sender}`;
        
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'message-bubble';
        bubbleDiv.innerHTML = this.formatMessage(message);
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = new Date().toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit'
        });
        
        messageDiv.appendChild(bubbleDiv);
        messageDiv.appendChild(timeDiv);
        
        return messageDiv;
    }
    
    formatMessage(message) {
        // Convert markdown-style formatting
        return message
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/\n/g, '<br>')
            .replace(/â€¢ /g, 'â€¢ ');
    }
    
    createVisualization(viz) {
        const vizDiv = document.createElement('div');
        vizDiv.className = 'visualization';
        
        if (viz.type === 'info_card') {
            vizDiv.innerHTML = this.createInfoCard(viz);
        } else if (viz.type === 'chart') {
            vizDiv.innerHTML = `<div class="chart-container"><canvas id="chart-${Date.now()}"></canvas></div>`;
            setTimeout(() => this.renderChart(vizDiv.querySelector('canvas'), viz), 100);
        } else if (viz.type === 'progress_chart') {
            vizDiv.innerHTML = this.createProgressChart(viz);
        } else if (viz.type === 'kpi_cards') {
            vizDiv.innerHTML = this.createKPICards(viz);
        }
        
        return vizDiv;
    }
    
    createInfoCard(viz) {
        const data = viz.data;
        return `
            <div class="info-card">
                <h4>${viz.title}</h4>
                ${Object.entries(data).map(([key, value]) => `
                    <div class="info-row">
                        <span>${this.translateKey(key)}</span>
                        <strong>${value}</strong>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    createProgressChart(viz) {
        const areas = viz.data.areas;
        return `
            <div class="progress-chart">
                <h4>${viz.title}</h4>
                ${Object.entries(areas).map(([area, value]) => `
                    <div class="progress-item">
                        <div class="progress-label">
                            <span>${area}</span>
                            <span>${value}%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${value}%"></div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    createKPICards(viz) {
        return `
            <div class="kpi-cards">
                ${viz.data.cards.map(card => `
                    <div class="kpi-card">
                        <h5>${card.title}</h5>
                        <div class="kpi-value">${card.value}${card.unit}</div>
                        <div class="kpi-trend ${card.trend}">
                            ${card.trend === 'up' ? 'â†‘' : card.trend === 'down' ? 'â†“' : 'â†’'}
                            ${card.change || 0}%
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    renderChart(canvas, viz) {
        const ctx = canvas.getContext('2d');
        new Chart(ctx, {
            type: viz.data.type || 'bar',
            data: viz.data,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                ...viz.options
            }
        });
    }
    
    showTypingIndicator() {
        const typingDiv = document.createElement('div');
        typingDiv.className = 'message bot typing-message';
        typingDiv.innerHTML = `
            <div class="typing-indicator">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        `;
        this.messagesContainer.appendChild(typingDiv);
        this.scrollToBottom();
        this.isTyping = true;
    }
    
    hideTypingIndicator() {
        if (this.isTyping) {
            const typingMessage = this.messagesContainer.querySelector('.typing-message');
            if (typingMessage) {
                typingMessage.remove();
            }
            this.isTyping = false;
        }
    }
    
    handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                this.attachments.push({
                    type: file.type.startsWith('image/') ? 'image' : 'document',
                    name: file.name,
                    data: e.target.result.split(',')[1] // base64 data
                });
                
                // Show attachment indicator
                this.showAttachmentIndicator(file.name);
            };
            reader.readAsDataURL(file);
        }
    }
    
    showAttachmentIndicator(filename) {
        // Add visual indicator for attached file
        const indicator = document.createElement('div');
        indicator.className = 'attachment-indicator';
        indicator.innerHTML = `ğŸ“ ${filename}`;
        this.inputField.parentElement.appendChild(indicator);
    }
    
    handleAction(action) {
        switch(action.action) {
            case 'VIEW_DETAILED_HISTORY':
                window.location.href = '/employees/profile/';
                break;
            case 'APPLY_CERTIFICATION':
                window.location.href = `/certifications/apply/${action.data.level}`;
                break;
            case 'ENROLL_COURSE':
                window.location.href = `/trainings/enroll/${action.data.course_id}`;
                break;
            case 'OPEN_FULL_DASHBOARD':
                window.open(action.data.url, '_blank');
                break;
            case 'GENERATE_KPI_REPORT':
                this.generateReport(action.data);
                break;
            default:
                console.log('Unknown action:', action);
        }
    }
    
    async generateReport(data) {
        try {
            const response = await fetch('/api/generate-report/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify({
                    report_type: 'monthly_report',
                    format: data.format || 'pdf',
                    language: 'ko'
                })
            });
            
            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `report_${new Date().toISOString().split('T')[0]}.${data.format}`;
                a.click();
            }
        } catch (error) {
            console.error('Report generation failed:', error);
        }
    }
    
    async bookmarkMessage(bookmarkData) {
        try {
            const response = await fetch('/api/chatbot/bookmarks/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCookie('csrftoken')
                },
                body: JSON.stringify(bookmarkData)
            });
            
            if (response.ok) {
                // Visual feedback
                this.showNotification('ë¶ë§ˆí¬ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('Bookmark failed:', error);
        }
    }
    
    toggleBookmark() {
        this.bookmarkBtn.classList.toggle('bookmarked');
        const icon = this.bookmarkBtn.querySelector('i');
        icon.classList.toggle('far');
        icon.classList.toggle('fas');
    }
    
    getActionIcon(actionType) {
        const icons = {
            'button': 'arrow-right',
            'link': 'external-link-alt',
            'download': 'download',
            'view': 'eye'
        };
        return icons[actionType] || 'arrow-right';
    }
    
    translateKey(key) {
        const translations = {
            'employee_id': 'ì‚¬ë²ˆ',
            'name': 'ì„±ëª…',
            'position': 'ì§ê¸‰',
            'department': 'ë¶€ì„œ',
            'growth_level': 'ì„±ì¥ë ˆë²¨'
        };
        return translations[key] || key;
    }
    
    scrollToBottom() {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
    
    getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    showNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.classList.add('show');
        }, 100);
        
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
}

// Initialize chatbot
document.addEventListener('DOMContentLoaded', () => {
    const chatbot = new EHRChatbot();
});
</script>
{% endblock %}
"""